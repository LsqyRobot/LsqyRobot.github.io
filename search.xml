<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Articulated-Body Algorithm (ABA) 笔记</title>
      <link href="/2025/09/17/continue_ABA_Pinocchio/"/>
      <url>/2025/09/17/continue_ABA_Pinocchio/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#articulated-body-algorithm-aba-笔记">Articulated-Body Algorithm (ABA) 笔记</a><ul><li><a href="#简介">简介</a></li><li><a href="#动力学背景">动力学背景</a></li><li><a href="#算法流程">算法流程</a><ul><li><a href="#step-1-前向遍历-forward-pass">Step 1: 前向遍历 (Forward pass)</a></li><li><a href="#step-2-反向遍历-backward-pass">Step 2: 反向遍历 (Backward pass)</a></li><li><a href="#step-3-前向求解-forward-pass">Step 3: 前向求解 (Forward pass)</a></li></ul></li><li><a href="#算法示意图">算法示意图</a><ul><li><a href="#三关节机械臂的递归传播">三关节机械臂的递归传播</a></li></ul></li><li><a href="#"></a></li><li><a href="#应用">应用</a></li><li><a href="#伪代码示例">伪代码示例</a></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="Articulated-Body-Algorithm-ABA-笔记"><a href="#Articulated-Body-Algorithm-ABA-笔记" class="headerlink" title="Articulated-Body Algorithm (ABA) 笔记"></a>Articulated-Body Algorithm (ABA) 笔记</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Articulated-Body Algorithm（简称 <strong>ABA</strong>）是 Featherstone 提出的机器人动力学高效算法，主要用于 <strong>前向动力学 (Forward Dynamics)</strong> 计算：</p><ul><li>已知：关节位置 <strong>q</strong>、关节速度 <strong>q̇</strong>、关节力矩 <strong>τ</strong></li><li>计算：关节加速度 <strong>q̈</strong></li></ul><p>与传统方法相比，ABA 避免了质量矩阵 <strong>M(q)</strong> 的显式求逆，将复杂度从 <strong>O(n³)</strong> 降到 <strong>O(n)</strong>（n 为关节数）。</p><hr><h2 id="动力学背景"><a href="#动力学背景" class="headerlink" title="动力学背景"></a>动力学背景</h2><p>动力学方程：<br>[<br>M(q)\ddot{q} + h(q, \dot{q}) = τ<br>]</p><ul><li><strong>M(q)</strong>：质量矩阵  </li><li><strong>h(q, q̇)</strong>：科氏力、离心力、重力等  </li><li><strong>τ</strong>：广义力矩  </li></ul><p>直接解需要：<br>[<br>\ddot{q} = M^{-1}(τ - h)<br>]</p><p>但矩阵求逆代价高 → <strong>ABA</strong> 通过递归传播替代矩阵求逆。</p><hr><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><h3 id="Step-1-前向遍历-Forward-pass"><a href="#Step-1-前向遍历-Forward-pass" class="headerlink" title="Step 1: 前向遍历 (Forward pass)"></a>Step 1: 前向遍历 (Forward pass)</h3><ul><li>从基座到末端</li><li>计算每个关节的：<ul><li>空间速度 <strong>vᵢ</strong></li><li>偏加速度 <strong>cᵢ</strong>（Coriolis/重力项）</li></ul></li></ul><h3 id="Step-2-反向遍历-Backward-pass"><a href="#Step-2-反向遍历-Backward-pass" class="headerlink" title="Step 2: 反向遍历 (Backward pass)"></a>Step 2: 反向遍历 (Backward pass)</h3><ul><li>从末端到基座</li><li>计算每个关节的：<ul><li>有效惯性 (<strong>articulated-body inertia</strong>) <strong>Iᵢ*</strong></li><li>偏广义力 <strong>pᵢ*</strong></li></ul></li><li>聚合子关节的信息，逐层往上传递</li></ul><h3 id="Step-3-前向求解-Forward-pass"><a href="#Step-3-前向求解-Forward-pass" class="headerlink" title="Step 3: 前向求解 (Forward pass)"></a>Step 3: 前向求解 (Forward pass)</h3><ul><li>从基座再到末端</li><li>解出每个关节的加速度 <strong>q̈ᵢ</strong></li><li>结合 τ 和上一步结果，传播最终加速度</li></ul><hr><h2 id="算法示意图"><a href="#算法示意图" class="headerlink" title="算法示意图"></a>算法示意图</h2><h3 id="三关节机械臂的递归传播"><a href="#三关节机械臂的递归传播" class="headerlink" title="三关节机械臂的递归传播"></a>三关节机械臂的递归传播</h3><ul><li><strong>蓝色箭头</strong>：速度/偏加速度从基座传到末端  </li><li><strong>红色箭头</strong>：力和惯性从末端传回基座  </li><li><strong>绿色箭头</strong>：加速度从基座传到末端  </li></ul><p>（见图：三关节机械臂的 ABA 流程）</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/img/postImg/32_robotics/2_ABA/output.png" alt=""></h2><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li><strong>机器人仿真引擎</strong>：Gazebo、MuJoCo、Isaac Sim  </li><li><strong>动力学库</strong>：RBDL、Pinocchio、Drake  </li><li><strong>控制算法</strong>：MPC、RL 等需要实时动力学计算的场景</li></ul><hr><h2 id="伪代码示例"><a href="#伪代码示例" class="headerlink" title="伪代码示例"></a>伪代码示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> ABA(q, qd, tau):</span><br><span class="line">    <span class="comment"># Step 1: Forward pass</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">link</span> <span class="keyword">in</span> tree(root → leaves):</span><br><span class="line">        compute spatial velocity v[<span class="built_in">link</span>]</span><br><span class="line">        compute bias acceleration c[<span class="built_in">link</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 2: Backward pass</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">link</span> <span class="keyword">in</span> tree(leaves → root):</span><br><span class="line">        compute articulated inertia I_star[<span class="built_in">link</span>]</span><br><span class="line">        compute bias force p_star[<span class="built_in">link</span>]</span><br><span class="line">        propagate to parent</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 3: Forward pass</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">link</span> <span class="keyword">in</span> tree(root → leaves):</span><br><span class="line">        compute joint acceleration qdd[<span class="built_in">link</span>]</span><br><span class="line">        propagate to child</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> qdd</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1) R. Featherstone, The Calculation of Robot Dynamics Using Articulated-Body Inertias, 1983.</p><p>2) Featherstone, Rigid Body Dynamics Algorithms, 2008.</p><p>3) Pinocchio / RBDL 源码实现</p>]]></content>
      
      
      <categories>
          
          <category> ROBOTICS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> robotics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS2 QoS 配置策略</title>
      <link href="/2025/09/15/continue_ros2_Qos/"/>
      <url>/2025/09/15/continue_ros2_Qos/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#简介">简介</a></li><li><a href="#ros-2-常见-qos-策略">ROS 2 常见 QoS 策略</a></li><li><a href="#ros-2-内置-qos-配置">ROS 2 内置 QoS 配置</a></li><li><a href="#不同场景下常用-qos-配置对照表">不同场景下常用 QoS 配置对照表</a></li><li><a href="#小技巧">小技巧</a><ul><li><a href="#内置-qos-配置">内置 QoS 配置</a></li><li><a href="#调试-qos-不匹配">调试 QoS 不匹配</a></li><li><a href="#qos-和实时性">QoS 和实时性</a></li></ul></li></ul><!-- vim-markdown-toc --><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>QoS（Quality of Service，服务质量）配置策略。这是 ROS 2 相比 ROS 1 的一个重要特性，因为它基于 DDS（Data Distribution Service），通信时可以灵活配置不同的 QoS 策略，适应不同的应用场景（比如机器人控制 vs 传感器数据流）。</p><h1 id="ROS-2-常见-QoS-策略"><a href="#ROS-2-常见-QoS-策略" class="headerlink" title="ROS 2 常见 QoS 策略"></a>ROS 2 常见 QoS 策略</h1><p>在 ROS 2 里，QoS 策略主要包含以下几个方面：</p><ol><li><p><strong>Reliability（可靠性）</strong></p><ul><li><strong>RELIABLE</strong>: 确保消息一定会送达（适合命令、关键数据）</li><li><strong>BEST_EFFORT</strong>: 尽量传输，不保证（适合高频传感器，如激光雷达点云）</li></ul></li><li><p><strong>Durability（持久性）</strong></p><ul><li><strong>VOLATILE</strong>: 只接收订阅后发布的新消息</li><li><strong>TRANSIENT_LOCAL</strong>: 订阅者一旦加入，可以收到历史消息（适合参数或状态发布）</li></ul></li><li><p><strong>History（历史缓存策略）</strong></p><ul><li><strong>KEEP_LAST(n)</strong>: 只保留最近 n 条消息</li><li><strong>KEEP_ALL</strong>: 保留所有消息（受限于内存）</li></ul></li><li><p><strong>Deadline（截止时间）</strong></p><p>指定发布周期约束，订阅者能检测消息是否延迟。</p></li><li><p><strong>Liveliness（活跃性）</strong></p><p>检测发布者是否仍然活着，可以选择自动或手动信号。</p></li><li><p><strong>Lifespan（消息寿命）</strong></p><p>消息在网络中存活的时间，超时会丢弃</p></li></ol><h1 id="ROS-2-内置-QoS-配置"><a href="#ROS-2-内置-QoS-配置" class="headerlink" title="ROS 2 内置 QoS 配置"></a>ROS 2 内置 QoS 配置</h1><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">在 rclcpp 和 rclpy 中，ROS <span class="number">2</span> 已经内置了一些常用 QoS profile，方便直接使用：</span><br><span class="line"></span><br><span class="line">qos<span class="number">_p</span>rofile<span class="number">_</span><span class="keyword">default</span>：默认设置</span><br><span class="line"></span><br><span class="line">qos<span class="number">_p</span>rofile<span class="number">_</span>sensor<span class="number">_</span>data：高频传感器，BEST<span class="number">_</span>EFFORT + KEEP<span class="number">_</span>LAST(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">qos<span class="number">_p</span>rofile<span class="number">_</span>services<span class="number">_</span><span class="keyword">default</span>：服务调用用</span><br><span class="line"></span><br><span class="line">qos<span class="number">_p</span>rofile<span class="number">_p</span>arameter<span class="number">_</span>events：参数事件</span><br><span class="line"></span><br><span class="line">qos<span class="number">_p</span>rofile<span class="number">_</span>system<span class="number">_</span><span class="keyword">default</span>：跟随 DDS 默认配置</span><br></pre></td></tr></table></figure><p>示例（C++）：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">rclcpp::QoS <span class="title function_ invoke__">qos</span>(rclcpp::<span class="title function_ invoke__">KeepLast</span>(<span class="number">10</span>));</span><br><span class="line">qos.<span class="title function_ invoke__">reliability</span>(RMW_QOS_POLICY_RELIABILITY_RELIABLE);</span><br><span class="line">qos.<span class="title function_ invoke__">durability</span>(RMW_QOS_POLICY_DURABILITY_VOLATILE);</span><br><span class="line"></span><br><span class="line">auto sub = node<span class="punctuation">-&gt;</span>create_subscription&lt;std_msgs::msg::<span class="type">String</span>&gt;(</span><br><span class="line">    <span class="string">&quot;chatter&quot;</span>, qos,</span><br><span class="line">    [](std_msgs::msg::<span class="type">String</span>::SharedPtr msg) &#123;</span><br><span class="line">        <span class="title function_ invoke__">RCLCPP_INFO</span>(node<span class="punctuation">-&gt;</span><span class="title function_ invoke__">get_logger</span>(), <span class="string">&quot;I heard: &#x27;%s&#x27;&quot;</span>, msg<span class="punctuation">-&gt;</span>data.<span class="title function_ invoke__">c_str</span>());</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h1 id="不同场景下常用-QoS-配置对照表"><a href="#不同场景下常用-QoS-配置对照表" class="headerlink" title="不同场景下常用 QoS 配置对照表"></a>不同场景下常用 QoS 配置对照表</h1><div class="table-container"><table><thead><tr><th>场景</th><th>推荐 QoS 配置</th><th>说明</th></tr></thead><tbody><tr><td><strong>激光雷达 / 相机图像</strong>（高频传感器数据）</td><td><code>BEST_EFFORT + KEEP_LAST(1)</code> （<code>qos_profile_sensor_data</code>）</td><td>高频大数据流，丢少量数据不影响整体，减少带宽和延迟</td></tr><tr><td><strong>IMU 数据</strong></td><td><code>BEST_EFFORT + KEEP_LAST(5)</code></td><td>高频，但每个数据包较小，允许丢少量数据</td></tr><tr><td><strong>机器人控制命令</strong>（关节/速度/力矩指令）</td><td><code>RELIABLE + KEEP_LAST(1)</code></td><td>必须保证命令送达，但只要最新的，历史没用</td></tr><tr><td><strong>状态反馈</strong>（关节角度、电流等）</td><td><code>RELIABLE + KEEP_LAST(10)</code></td><td>确保可靠传输，可以保留最近一段时间的数据</td></tr><tr><td><strong>地图、参数、静态 TF</strong></td><td><code>RELIABLE + TRANSIENT_LOCAL + KEEP_LAST(1)</code></td><td>新订阅者加入时也能收到最近的消息（如静态地图、TF 树）</td></tr><tr><td><strong>参数事件</strong>（Parameter Events）</td><td><code>RELIABLE + KEEP_ALL</code>（<code>qos_profile_parameter_events</code>）</td><td>确保不丢失参数变更通知</td></tr><tr><td><strong>服务（Service）</strong></td><td><code>RELIABLE + KEEP_LAST(1)</code>（<code>qos_profile_services_default</code>）</td><td>请求-应答模式，必须可靠</td></tr><tr><td><strong>Action（动作接口）</strong></td><td><code>RELIABLE + KEEP_LAST(10)</code></td><td>动作反馈需要可靠传输</td></tr></tbody></table></div><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="内置-QoS-配置"><a href="#内置-QoS-配置" class="headerlink" title="内置 QoS 配置"></a>内置 QoS 配置</h2><p>ROS 2 已经提供了常见 QoS，例如：</p><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">qos<span class="number">_p</span>rofile<span class="number">_</span>sensor<span class="number">_</span>data → 传感器</span><br><span class="line"></span><br><span class="line">qos<span class="number">_p</span>rofile<span class="number">_</span>services<span class="number">_</span><span class="keyword">default</span> → 服务</span><br><span class="line"></span><br><span class="line">qos<span class="number">_p</span>rofile<span class="number">_p</span>arameter<span class="number">_</span>events → 参数</span><br></pre></td></tr></table></figure><h2 id="调试-QoS-不匹配"><a href="#调试-QoS-不匹配" class="headerlink" title="调试 QoS 不匹配"></a>调试 QoS 不匹配</h2><p>发布者和订阅者的 QoS 策略必须“兼容”，否则无法通信。</p><p>可以用命令行工具检查：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">ros2 topic info <span class="string">/topic_name</span> <span class="params">--verbose</span></span><br></pre></td></tr></table></figure><h2 id="QoS-和实时性"><a href="#QoS-和实时性" class="headerlink" title="QoS 和实时性"></a>QoS 和实时性</h2><ul><li><p>控制指令 → 要求低延迟（只要最新消息）。</p></li><li><p>感知数据 → 要求高吞吐（丢数据没关系）。</p></li><li><p>状态/参数 → 要求高可靠性（不能丢）。</p></li></ul><!-- vim-markdown-toc -->]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ros2 </tag>
            
            <tag> QoS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 多段提交合并为一条</title>
      <link href="/2025/07/20/archived_%E5%A4%9A%E6%AE%B5git%E6%8F%90%E4%BA%A4%E5%90%88%E5%B9%B6%E4%B8%BA%E4%B8%80%E6%9D%A1/"/>
      <url>/2025/07/20/archived_%E5%A4%9A%E6%AE%B5git%E6%8F%90%E4%BA%A4%E5%90%88%E5%B9%B6%E4%B8%BA%E4%B8%80%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#将多段-git-提交合并为一条squash-commits">将多段 Git 提交合并为一条(Squash Commits)</a><ul><li><a href="#总体流程图">总体流程图</a></li></ul></li><li><a href="#一选择合并范围">一、选择合并范围</a></li><li><a href="#二交互式-rebase推荐">二、交互式 Rebase（推荐）</a><ul><li><a href="#21-打开交互式-rebase">2.1 打开交互式 rebase</a></li><li><a href="#22-编辑待办列表pick--squash--fixup">2.2 编辑待办列表（pick / squash / fixup）</a></li><li><a href="#23-编辑最终提交信息">2.3 编辑最终提交信息</a></li><li><a href="#24-解决冲突与继续">2.4 解决冲突与继续</a></li><li><a href="#25-推送强制">2.5 推送（强制）</a></li></ul></li><li><a href="#三软重置法快速合并">三、软重置法（快速合并）</a></li><li><a href="#四故障排查与回滚流程图">四、故障排查与回滚流程图</a></li><li><a href="#五最佳实践">五、最佳实践</a></li><li><a href="#附录常用命令速查">附录：常用命令速查</a></li></ul><!-- vim-markdown-toc --><h1 id="将多段-Git-提交合并为一条-Squash-Commits"><a href="#将多段-Git-提交合并为一条-Squash-Commits" class="headerlink" title="将多段 Git 提交合并为一条(Squash Commits)"></a>将多段 Git 提交合并为一条(Squash Commits)</h1><p>本文档介绍如何把一段提交历史压缩为一条干净的提交。适用于在合并分支 / 提交 PR / 发布版本前精简历史。</p><blockquote><p>适用读者：日常使用 Git 的开发者<br>适用范围：本地分支（多人协作请先沟通，改写历史需要强制推送）</p></blockquote><h2 id="总体流程图"><a href="#总体流程图" class="headerlink" title="总体流程图"></a>总体流程图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">  A[确定合并范围&lt;br/&gt;识别最早提交 commitA] --&gt; B&#123;选择方式&#125;</span><br><span class="line">  B --&gt;|推荐| C[交互式 rebase&lt;br/&gt;git rebase -i commitA^]</span><br><span class="line">  B --&gt;|替代| D[软重置法&lt;br/&gt;git reset --soft commitA^]</span><br><span class="line"></span><br><span class="line">  C --&gt; E[编辑待办列表：&lt;br/&gt;第一条 pick/reword，其余 squash/fixup]</span><br><span class="line">  E --&gt; F&#123;是否冲突?&#125;</span><br><span class="line">  F --&gt;|是| G[逐个解决冲突&lt;br/&gt;git add ...&lt;br/&gt;git rebase --continue]</span><br><span class="line">  F --&gt;|否| H[编辑最终提交信息&lt;br/&gt;(如使用 squash)]</span><br><span class="line">  G --&gt; F</span><br><span class="line">  H --&gt; I[强制推送&lt;br/&gt;git push --force]</span><br><span class="line"></span><br><span class="line">  D --&gt; J[一次性提交&lt;br/&gt;git commit -m &#x27;...&#x27;]</span><br><span class="line">  J --&gt; I</span><br></pre></td></tr></table></figure><h1 id="一、选择合并范围"><a href="#一、选择合并范围" class="headerlink" title="一、选择合并范围"></a>一、选择合并范围</h1><p>查看历史，找到要合并段落中最早的那条提交（记为 commitA）：</p><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">git log</span> <span class="literal">--</span><span class="comment">oneline</span> <span class="literal">--</span><span class="comment">decorate</span> <span class="literal">--</span><span class="comment">graph</span> <span class="literal">--</span><span class="comment">all</span></span><br></pre></td></tr></table></figure><p>接下来示例都以 <commitA> 表示该起点。不要把真实哈希写进文档中。</p><h1 id="二、交互式-Rebase（推荐）"><a href="#二、交互式-Rebase（推荐）" class="headerlink" title="二、交互式 Rebase（推荐）"></a>二、交互式 Rebase（推荐）</h1><h2 id="2-1-打开交互式-rebase"><a href="#2-1-打开交互式-rebase" class="headerlink" title="2.1 打开交互式 rebase"></a>2.1 打开交互式 rebase</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git rebase -i <span class="tag">&lt;<span class="name">commitA</span>&gt;</span>^</span><br></pre></td></tr></table></figure><p>^ 表示从 commitA 的前一个提交开始变基，确保列表中包含 commitA。</p><h2 id="2-2-编辑待办列表（pick-squash-fixup）"><a href="#2-2-编辑待办列表（pick-squash-fixup）" class="headerlink" title="2.2 编辑待办列表（pick / squash / fixup）"></a>2.2 编辑待办列表（pick / squash / fixup）</h2><p>编辑器会打开从老到新的提交列表，例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">pick <span class="tag">&lt;<span class="name">commitA</span>&gt;</span>   描述 A</span><br><span class="line">pick <span class="tag">&lt;<span class="name">commitB</span>&gt;</span>   描述 B</span><br><span class="line">pick <span class="tag">&lt;<span class="name">commitC</span>&gt;</span>   描述 C</span><br></pre></td></tr></table></figure><p>将第一条保留为 pick（或改为 reword 以修改最终说明），其余全部改为 squash（合并并保留说明进行编辑）或 fixup（合并但丢弃说明）：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">pick  <span class="tag">&lt;<span class="name">commitA</span>&gt;</span>  描述 A</span><br><span class="line">fixup <span class="tag">&lt;<span class="name">commitB</span>&gt;</span>  描述 B</span><br><span class="line">fixup <span class="tag">&lt;<span class="name">commitC</span>&gt;</span>  描述 C</span><br></pre></td></tr></table></figure><p>想把中间说明合并整理进最终提交 → squash</p><p>想让历史更干净简短，只保留第一条说明 → fixup</p><h2 id="2-3-编辑最终提交信息"><a href="#2-3-编辑最终提交信息" class="headerlink" title="2.3 编辑最终提交信息"></a>2.3 编辑最终提交信息</h2><p>使用了 squash 时，Git 会提示你合并并编辑 message。建议使用统一规范（如 Conventional Commits）：</p><figure class="highlight ldif"><table><tr><td class="code"><pre><span class="line"><span class="attribute">feat</span>: 初始化核心模块并完善配置加载/状态更新/推理接口</span><br><span class="line"></span><br><span class="line"><span class="literal">-</span> 支持配置解析与模型加载</span><br><span class="line"><span class="literal">-</span> 新增观测量处理逻辑与缓存</span><br><span class="line"><span class="literal">-</span> 增加控制参数下发与限幅</span><br><span class="line">保存并继续。</span><br></pre></td></tr></table></figure><h2 id="2-4-解决冲突与继续"><a href="#2-4-解决冲突与继续" class="headerlink" title="2.4 解决冲突与继续"></a>2.4 解决冲突与继续</h2><p>遇到冲突时：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解决冲突</span></span><br><span class="line">git add &lt;文件1&gt; &lt;文件2&gt; <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续 rebase</span></span><br><span class="line">git rebase <span class="params">--continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 放弃本次 rebase（回到开始前状态）</span></span><br><span class="line">git rebase <span class="params">--abort</span></span><br></pre></td></tr></table></figure><h2 id="2-5-推送（强制）"><a href="#2-5-推送（强制）" class="headerlink" title="2.5 推送（强制）"></a>2.5 推送（强制）</h2><p>改写了历史，需要强制推送：</p><figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">push</span> origin &lt;分支名&gt; --<span class="literal">force</span></span><br><span class="line"><span class="comment"># 或更安全：</span></span><br><span class="line">git <span class="keyword">push</span> origin &lt;分支名&gt; --<span class="literal">force</span>-with-lease</span><br></pre></td></tr></table></figure><h1 id="三、软重置法（快速合并）"><a href="#三、软重置法（快速合并）" class="headerlink" title="三、软重置法（快速合并）"></a>三、软重置法（快速合并）</h1><p>当列表很长或只想“粗暴合并”时可用：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回退到 commitA 的上一个，但保留工作区/暂存区</span></span><br><span class="line">git reset <span class="comment">--soft &lt;commitA&gt;^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前所有变更一次性提交为一条</span></span><br><span class="line">git commit -m <span class="string">&quot;feat: （你的最终提交说明）&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送（改写历史）</span></span><br><span class="line">git push origin &lt;分支名&gt; <span class="comment">--force</span></span><br></pre></td></tr></table></figure><p>特点：过程短、一步到位；但不会逐条整理中间提交的说明。</p><h1 id="四、故障排查与回滚流程图"><a href="#四、故障排查与回滚流程图" class="headerlink" title="四、故障排查与回滚流程图"></a>四、故障排查与回滚流程图</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">  S[开始] --&gt; A&#123;rebase 进行中?&#125;</span><br><span class="line">  A --&gt;|是| B&#123;冲突?&#125;</span><br><span class="line">  B --&gt;|是| C[解决冲突&lt;br/&gt;git add ...&lt;br/&gt;git rebase --continue]</span><br><span class="line">  C --&gt; A</span><br><span class="line">  B --&gt;|否| D[完成 rebase]</span><br><span class="line">  A --&gt;|否| D</span><br><span class="line"></span><br><span class="line">  D --&gt; E&#123;推送失败?&#125;</span><br><span class="line">  E --&gt;|是| F[改写历史导致拒绝&lt;br/&gt;使用 --force/--force-with-lease]</span><br><span class="line">  F --&gt; G[git push --force(-with-lease)]</span><br><span class="line">  E --&gt;|否| H[结束]</span><br><span class="line"></span><br><span class="line">  G --&gt; H[结束]</span><br><span class="line"></span><br><span class="line">  %% 回滚支线</span><br><span class="line">  subgraph 回滚/救援</span><br><span class="line">    I[误操作?] --&gt; J&#123;要回到 rebase 前?&#125;</span><br><span class="line">    J --&gt;|是| K[git rebase --abort]</span><br><span class="line">    J --&gt;|否| L[通过 reflog 找回]</span><br><span class="line">    L --&gt; M[git reflog → 找到安全点]</span><br><span class="line">    M --&gt; N[git reset --hard &lt;安全点SHA&gt;]</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><h1 id="五、最佳实践"><a href="#五、最佳实践" class="headerlink" title="五、最佳实践"></a>五、最佳实践</h1><p>在私有分支上频繁整理历史；提交 PR/合并前保持 1～数条语义清晰的提交。</p><p>与协作者沟通后再进行改写历史操作；推送时优先用 —force-with-lease。</p><p>善用 fixup! 工作流：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">commit</span> <span class="comment">--fixup=&lt;基准SHA&gt;</span></span><br><span class="line">git rebase <span class="operator">-</span>i <span class="comment">--autosquash &lt;基准SHA&gt;^</span></span><br></pre></td></tr></table></figure><p>让 Git 自动把修复提交贴到目标提交后，减少手动编辑。</p><p>使用统一提交规范（如 Conventional Commits），方便生成变更日志。</p><p>常见问题 FAQ</p><p>Q1：rebase 列表里最新的提交在最上面还是最下面？<br>A：一般最上面是最早，最下面是最新。如果只出现一条，检查你是否使用了 <commitA>^ 作为起点。</p><p>Q2：squash 和 fixup 如何选择？<br>A：希望整合并编辑中间信息 → squash；希望直接合并且不保留中间信息 → fixup。</p><p>Q3：强制推送有什么风险？<br>A：会覆盖远端历史。多人协作时建议先沟通，或使用 —force-with-lease 以避免覆盖他人最新提交。</p><p>Q4：合并后发现说明不完整怎么办？<br>A：使用 git commit —amend 修改最近一次提交；或通过 git reflog 回到合并前重新整理。</p><h1 id="附录：常用命令速查"><a href="#附录：常用命令速查" class="headerlink" title="附录：常用命令速查"></a>附录：常用命令速查</h1><figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看历史</span></span><br><span class="line"><span class="string">git</span> <span class="string">log</span> <span class="built_in">--oneline</span> <span class="built_in">--decorate</span> <span class="built_in">--graph</span> <span class="built_in">--all</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式合并一段历史</span></span><br><span class="line"><span class="string">git</span> <span class="string">rebase</span> -<span class="string">i</span> &lt;<span class="string">commitA</span>&gt;^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续 / 放弃 rebase</span></span><br><span class="line"><span class="string">git</span> <span class="string">rebase</span> <span class="built_in">--continue</span></span><br><span class="line"><span class="string">git</span> <span class="string">rebase</span> <span class="built_in">--abort</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 软重置到 commitA 之前</span></span><br><span class="line"><span class="string">git</span> <span class="string">reset</span> <span class="built_in">--soft</span> &lt;<span class="string">commitA</span>&gt;^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修订最近一次提交（信息或内容）</span></span><br><span class="line"><span class="string">git</span> <span class="string">commit</span> <span class="built_in">--amend</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制推送（或更安全的强推）</span></span><br><span class="line"><span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> &lt;<span class="string">branch</span>&gt; <span class="built_in">--force</span></span><br><span class="line"><span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> &lt;<span class="string">branch</span>&gt; <span class="built_in">--force-with-lease</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 reflog 找回历史</span></span><br><span class="line"><span class="string">git</span> <span class="string">reflog</span></span><br><span class="line"><span class="string">git</span> <span class="string">reset</span> <span class="built_in">--hard</span> &lt;<span class="string">sha</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GIT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tools </tag>
            
            <tag> vim </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年总结与展望</title>
      <link href="/2024/12/31/archived_2024_summary_2025_plan/"/>
      <url>/2024/12/31/archived_2024_summary_2025_plan/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实2024年挺精彩的，个人也学习了不少的技能。从2024年年初说起吧，瑟瑟发抖的见了媳妇的父母，那心里叫一个忐忑啊，自己也不怎么会说话，忐忑中就迷迷糊糊的见了对方父母，刺激。</p><p>2024年上半年学习了一些现代机器人学，也学了一些ROS类的仿真，其他的技能类的内容记忆真不深刻，唯一深刻的就是减肥了，天天挨饿，最后结果还行，减到了这几年体重的最低点，也实现了自己的一个想法，独自一天内环了太湖，环完后在家躺了两天，身体那叫做一个疼！</p><p>下半年记忆就明显深刻很多了，一个是重新找了工作，当然，整个过程极其顺利，从更新简历到被录用，几天时间。。。。也阔别了昔日的同事，还真的很舍不得，不过还能偶尔碰个面，挺好的。</p><p>接下来就是买房，订婚，出差深圳等等让人印象深刻的事情。</p><h1 id="2024-年计划达成情况"><a href="#2024-年计划达成情况" class="headerlink" title="2024 年计划达成情况"></a>2024 年计划达成情况</h1><p>和过去几年一样，看看当初设立的目标，能完成的还是挺少的，实际上真的减肥到120斤以内了，不过现在又胖回来了。。。。。</p><p><del>1, 会用吉他弹一些小曲, 如《天空之城》。</del></p><p><del>2, 会用电子钢琴弹一些简单的曲,如《遇见》。</del></p><p><del>3, 学习数据结构,对简单的数据结构做到非常熟悉。</del></p><p>4, 会用Mathematica分析控制系统</p><p>5, 减肥至120斤以内。 </p><p>6, 见媳妇对方父母。</p><p>7，使用ROS对复杂构型建立运动学/动力学建模并实现仿真绘制， 并将整个过程输出到博客记录中；</p><p>8, 与媳妇解锁至少两座没有去过的城市, 想解锁厦门和云南，还有聊城，去看看小强；</p><p><del>9，工作上能够将柔度补偿算法给落地了，毕竟折腾了这么久了；</del></p><p>10, 订婚，订婚，订婚！！！</p><h1 id="2025-年目标"><a href="#2025-年目标" class="headerlink" title="2025 年目标"></a>2025 年目标</h1><p>目标定的小一些，不然总是处于未完成状态！</p><p>1, 吉他，吉他，还是吉他，始终没能坚持下来，啊！！！！！！！！，一定要会弹一点点！！！</p><p>2，电子钢琴，能做到看谱弹奏，不要求速度，（手动狗头，估计还是做不到）</p><p>3，学习数据结构，重点在树和图。</p><p>4，带媳妇去云南和四川玩。</p><p>5, 学习一些SLAM的知识</p><p>6，英语单词量破万, 最好能够流畅的用英语去表达和沟通。</p><p>7，力扣刷题200道（突然想到了一个笑话：有人相爱，有人夜里开车看海，有人leetcode第一题都做不出来。）</p><p>8，输出20篇以上的博客记录。</p><p>9, 学习足式机器人的运动/动力学控制, 以及动力学仿真，并做相关记录。</p><p>10， 结婚，结婚，结婚！！！ </p>]]></content>
      
      
      <categories>
          
          <category> LIFE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> dots </tag>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的优化算法</title>
      <link href="/2024/12/15/archived_optimal_%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
      <url>/2024/12/15/archived_optimal_%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#梯度下降法">梯度下降法</a><ul><li><a href="#描述">描述</a></li><li><a href="#例子">例子</a></li><li><a href="#缺点">缺点</a></li><li><a href="#批量梯度下降法">批量梯度下降法</a></li><li><a href="#随机梯度下降">随机梯度下降</a></li></ul></li><li><a href="#牛顿法和拟牛顿法">牛顿法和拟牛顿法</a><ul><li><a href="#牛顿法">牛顿法</a><ul><li><a href="#方法说明">方法说明</a></li><li><a href="#牛顿法的优缺点总结">牛顿法的优缺点总结：</a></li></ul></li><li><a href="#拟牛顿法">拟牛顿法</a><ul><li><a href="#搜索极值">搜索极值</a></li></ul></li></ul></li><li><a href="#共轭梯度法">共轭梯度法</a><ul><li><a href="#方法的表述">方法的表述</a></li><li><a href="#算法">算法</a></li></ul></li><li><a href="#序列二次规划">序列二次规划</a><ul><li><a href="#简介">简介</a><ul><li><a href="#sqp特点与应用">SQP特点与应用</a></li></ul></li><li><a href="#newton-raphson-n-r-方法简述">Newton-Raphson (N-R) 方法简述</a></li><li><a href="#lagrange-newton-基于-sqp-的方法">Lagrange-Newton 基于 SQP 的方法</a><ul><li><a href="#1-lagrangian-方程">1. Lagrangian 方程</a></li></ul></li></ul></li><li><a href="#todo">TODO</a><pre><code>  * [2. KKT 条件](#2-kkt-条件)</code></pre></li><li><a href="#todo-1">TODO</a><pre><code>  * [3. SQP 的二次规划近似](#3-sqp-的二次规划近似)</code></pre></li><li><a href="#endbmatrix">\end{bmatrix}</a><ul><li><a href="#sqp方法的基本步骤">SQP方法的基本步骤</a><ul><li><a href="#目标函数和约束的泰勒展开">目标函数和约束的泰勒展开</a></li><li><a href="#构造二次规划子问题">构造二次规划子问题</a></li><li><a href="#解二次规划子问题">解二次规划子问题</a></li><li><a href="#判断收敛性">判断收敛性</a></li><li><a href="#约束处理">约束处理</a></li></ul></li><li><a href="#sqp的优点">SQP的优点</a></li><li><a href="#sqp的缺点">SQP的缺点</a></li><li><a href="#应用领域">应用领域</a></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最优化方法是一种数学方法，它是研究在给定约束之下如何寻求某些因素(的量)，以使某一(或某些)指标达到最优的一些学科的总称。</p><p>常见的优化算法有很多，涵盖了数学、工程、机器学习等多个领域。以下是一些常见的优化算法的概述：</p><p>1) <code>梯度下降法(Gradient Descent)</code></p><p>原理：通过计算目标函数的梯度(偏导数)来更新参数，使得目标函数最小化。梯度下降法的基本思想是沿着梯度的反方向更新参数，以最快的速度减少目标函数值。</p><p>种类：</p><p>&bull; 批量梯度下降(Batch Gradient Descent)：每次迭代计算整个数据集的梯度，适合数据量小的情况。</p><p>&bull; 随机梯度下降(Stochastic Gradient Descent, SGD)：每次迭代使用一个样本来计算梯度，适合数据量大的情况。</p><p>&bull; 小批量梯度下降(Mini-batch Gradient Descent)：每次迭代使用数据集的一个小批量样本，结合了批量和随机梯度下降的优点。</p><p>2) <code>牛顿法(Newton&#39;s Method)</code></p><p>原理：利用目标函数的二阶导数(即Hessian矩阵)来加速优化过程。与梯度下降法相比，牛顿法每次更新时考虑了函数的曲率，因此收敛速度较快，但计算代价较高。</p><p>应用：适用于目标函数二阶导数可计算且问题规模较小的情况。</p><p>3) <code>拟牛顿法(Quasi-Newton Methods)</code></p><p>原理：拟牛顿法不直接计算Hessian矩阵，而是通过近似的方法来估算它，从而降低计算成本。最著名的拟牛顿法是BFGS(Broyden–Fletcher–Goldfarb–Shanno)算法。</p><p>应用：适用于中等规模的优化问题，尤其是在计算Hessian矩阵过于昂贵时。</p><p>4) <code>共轭梯度法(Conjugate Gradient Method)</code></p><p>原理：对于二次优化问题，共轭梯度法是一种迭代优化方法，它通过构造一组共轭方向来减少迭代次数。每一步的方向都是与之前的搜索方向“共轭”的。</p><p>应用：常用于大型稀疏线性系统的优化问题，尤其适用于内存限制较大的情境。</p><p>5) <code>启发式优化算法</code></p><p>a) <code>遗传算法(Genetic Algorithm, GA)</code></p><p>原理：遗传算法是一种基于自然选择和遗传机制的全局优化方法，通过模拟生物的进化过程来寻找最优解。基本操作包括选择、交叉、变异等。</p><p>应用：适用于搜索空间复杂、目标函数非线性且没有明显数学形式的优化问题。</p><p>b) <code>粒子群优化(Particle Swarm Optimization, PSO)</code></p><p>原理：粒子群优化是一种模拟鸟群觅食行为的优化算法。每个“粒子”代表一个潜在解，粒子通过个体历史最优位置和全体群体历史最优位置来更新自己的位置。</p><p>应用：适用于全局优化问题，特别是高维、多峰值问题。</p><p>c) <code>模拟退火(Simulated Annealing, SA)</code></p><p>原理：模拟退火算法模仿物理学中的退火过程，通过控制“温度”逐渐降低，从而在搜索空间中找到全局最优解。它允许接受一些次优解来跳出局部最优解。</p><p>应用：适用于解决组合优化问题，如旅行商问题(TSP)和调度问题。</p><p>6) <code>拉格朗日乘子法(Lagrange Multiplier Method)</code></p><p>原理：拉格朗日乘子法是一种求解约束优化问题的技术。通过引入拉格朗日乘子，将约束条件合并到目标函数中，从而转化为无约束问题进行优化。</p><p>应用：常用于带有等式约束的优化问题。高等数学里面有关于这部分的学习和使用，就不做介绍了。</p><p>7) <code>线性规划(Linear Programming, LP)</code></p><p>原理：线性规划求解的是具有线性目标函数和线性约束条件的优化问题。常用的求解方法有单纯形法和内点法。</p><p>应用：广泛应用于物流、生产调度、资源分配等领域。</p><p>用于求解线性规划类问题的工具个人推崇<code>Lingo</code>, 非常好用，Mathematica求解这类问题有大量丰富的函数，也强烈推荐使用。</p><p>8) <code>凸优化(Convex Optimization)</code></p><p>原理：凸优化问题是指目标函数是凸函数且约束条件也是凸的优化问题。凸优化理论提供了强大的数学工具，保证了全局最优解的存在和可求解性。</p><p>应用：许多工程和机器学习问题都可以建模为凸优化问题，如支持向量机(SVM)中的最优化问题。</p><p>9) <code>深度学习中的优化算法</code></p><p>原理：在神经网络和深度学习中，常用的优化算法有：</p><p>&bull; Adam：结合了动量法和自适应学习率的方法，常用于训练神经网络。</p><p>&bull; RMSprop：改进了梯度下降法，通过对历史梯度的平方进行加权平均来动态调整学习率。</p><p>&bull; Adagrad：根据梯度的平方和调整每个参数的学习率，适用于稀疏数据。</p><p>下面对用于工作中比较多的一些优化算法做一些相关的介绍。</p><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><p>梯度下降法(英语：Gradient descent)是一个一阶最优化算法，通常也称为最陡下降法，但是不该与近似积分的最陡下降法(英语：Method of steepest descent)混淆。 要使用梯度下降法找到一个函数的局部极小值，必须向函数上当前点对应梯度(或者是近似梯度)的反方向的规定步长距离点进行迭代搜索。如果相反地向梯度正方向迭代进行搜索，则会接近函数的局部极大值点；这个过程则被称为梯度上升法。</p><p>这里简要的说明下梯度的定义：</p><p><img src="https://latex.codecogs.com/svg.image?&space;grad&space;f(x_0,x_1,\dots,x_n)=(\frac{\partial&space;f}{\partial&space;x_0},\dots,\frac{\partial&space;f}{\partial&space;x_j},\dots,\frac{\partial&space;f}{\partial&space;x_n})" title=" grad f(x_0,x_1,\dots,x_n)=(\frac{\partial f}{\partial x_0},\dots,\frac{\partial f}{\partial x_j},\dots,\frac{\partial f}{\partial x_n})" /></p><p>函数在某一点的梯度是这样一个向量，它的方向与取得最大方向导数的方向一致，而它的模为方向导数的最大值。</p><p>这里注意三点：</p><p>&bull; 梯度是一个向量，即有方向有大小；<br>&bull; 梯度的方向是最大方向导数的方向；<br>&bull; 梯度的值是最大方向导数的值。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>梯度下降方法基于以下的观察:如果实值函数F(x)在点a处可微且有定义,那么函数F(x)在a点沿着梯度相反的方向-∇F(a)下降最多。</p><p>因而，如果</p><p><img src="https://latex.codecogs.com/svg.image?\mathbf{b}=\mathbf{a}-\gamma\nabla&space;F(\mathbf{a})" title="\mathbf{b}=\mathbf{a}-\gamma\nabla F(\mathbf{a})" /></p><p>对于一个足够小数值<img src="https://latex.codecogs.com/svg.image?\gamma>0" title="\gamma>0" />时成立，那么<img src="https://latex.codecogs.com/svg.image?{\displaystyle&space;F(\mathbf{a})\geq&space;F(\mathbf{b})}" title="{\displaystyle F(\mathbf{a})\geq F(\mathbf{b})}" /></p><p>考虑到这一点，我们可以从函数 F 的局部极小值的初始估计 <img src="https://latex.codecogs.com/svg.image?\mathbf{x}_{0}" title="\mathbf{x}_{0}" /> 出发，并考虑如下序列 <img src="https://latex.codecogs.com/svg.image?{\displaystyle\mathbf{x}_{0},\mathbf{x}_{1},\mathbf{x}_{2},\dots}" title="{\displaystyle\mathbf{x}_{0},\mathbf{x}_{1},\mathbf{x}_{2},\dots}" /> 使得</p><p><img src="https://latex.codecogs.com/png.image?\dpi{110}\mathbf{x}_{n&plus;1}=\mathbf{x}_{n}-\gamma&space;_{n}\nabla&space;F(x_n),n\geq&space;0" title="\mathbf{x}_{n+1}=\mathbf{x}_{n}-\gamma _{n}\nabla F(x_n),n\geq 0" /></p><p>因此可得到</p><p><img src="https://latex.codecogs.com/png.image?\dpi{110}F(\mathbf{x}_{0})\geq&space;F(\mathbf{x}_{1})\geq&space;F(\mathbf{x}_{2})\geq\cdots" title="F(\mathbf{x}_{0})\geq F(\mathbf{x}_{1})\geq F(\mathbf{x}_{2})\geq\cdots" /></p><p>如果顺利的话序列  (<img src="https://latex.codecogs.com/png.image?\dpi{110}\mathbf{x}_{n}" title="\mathbf{x}_{n}" />)收敛到期望的局部极小值。注意每次迭代步长 <img src="https://latex.codecogs.com/png.image?\dpi{110}\gamma" title="\gamma" /> 可以改变。</p><p>下图示例了这一过程，这里假设 F 定义在平面上，并且函数图像是一个碗形。蓝色的曲线是等高线(水平集)，即函数 F 为常数的集合构成的曲线。红色的箭头指向该点梯度的反方向。(一点处的梯度方向与通过该点的等高线垂直)。沿着梯度下降方向，将最终到达碗底，即函数 F 局部极小值的点。 </p><p><img src="/img/postImg/16_Algorithm/2_常见的优化算法/1_梯度下降法/Gradient_descent.png" alt=""></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>梯度下降法处理一些复杂的非线性函数会出现问题，例如Rosenbrock函数</p><p><img src="https://latex.codecogs.com/png.image?\dpi{110}{\displaystyle&space;f(x,y)=(1-x)^{2}&plus;100(y-x^{2})^{2}.\quad}" title="{\displaystyle f(x,y)=(1-x)^{2}+100(y-x^{2})^{2}.\quad}" /></p><p>其最小值在 (x,y)=(1,1) 处，数值为 f(x,y)=0。但是此函数具有狭窄弯曲的山谷，最小值 (x,y)=(1,1) 就在这些山谷之中，并且谷底很平。优化过程是之字形的向极小值点靠近，速度非常缓慢。如下图所示</p><p><img src="/img/postImg/16_Algorithm/2_常见的优化算法/1_梯度下降法/Banana-SteepDesc.gif" alt=""></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>梯度下降法的缺点包括:</p><p>&bull; 靠近局部极小值时速度减慢。</p><p>&bull; 直线搜索可能会产生一些问题。</p><p>&bull; 可能会“之字型”地下降。</p><p>从上图可以看出，梯度下降法在接近最优解的区域收敛速度明显变慢，利用梯度下降法求解需要很多次的迭代。</p><p>在机器学习中，基于基本的梯度下降法发展了两种梯度下降方法，分别为随机梯度下降法和批量梯度下降法。</p><p>比如对一个线性回归(Linear Logistics)模型，假设下面的h(x)是要拟合的函数，J(theta)为损失函数，theta是参数，要迭代求解的值，theta求解出来了那最终要拟合的函数h(theta)就出来了。其中m是训练集的样本个数，n是特征的个数。</p><p><img src="https://latex.codecogs.com/svg.image?&space;h(\theta)=\sum_{j=0}^n\theta_jx_j" title=" h(\theta)=\sum_{j=0}^n\theta_jx_j" /></p><p><img src="https://latex.codecogs.com/svg.image?J(\theta)=\frac{1}{2m}\sum_{i=1}^m(y^i-h_\theta(x^i))^2" title="J(\theta)=\frac{1}{2m}\sum_{i=1}^m(y^i-h_\theta(x^i))^2" /></p><h2 id="批量梯度下降法"><a href="#批量梯度下降法" class="headerlink" title="批量梯度下降法"></a>批量梯度下降法</h2><p>(1)将J(theta)对theta求偏导，得到每个theta对应的的梯度：</p><p><img src="https://latex.codecogs.com/svg.image?\frac{\partial&space;J(\theta)}{\partial\theta_j}=-\frac{1}{m}\sum_{i=1}^m(y^i-h_\theta(x^i))x^i_j" title="\frac{\partial J(\theta)}{\partial\theta_j}=-\frac{1}{m}\sum_{i=1}^m(y^i-h_\theta(x^i))x^i_j" /></p><p>(2)由于是要最小化风险函数，所以按每个参数theta的梯度负方向，来更新每个theta：</p><p><img src="https://latex.codecogs.com/svg.image?{\theta_j}^{'}=\theta_j&plus;\frac{1}{m}\sum_{i=1}^m(y^i-h_\theta(x^i))x_j^i" title="{\theta_j}^{'}=\theta_j+\frac{1}{m}\sum_{i=1}^m(y^i-h_\theta(x^i))x_j^i" /></p><p>(3)从上面公式可以注意到，它得到的是一个全局最优解，但是每迭代一步，都要用到训练集所有的数据，如果m很大，那么可想而知这种方法的迭代速度会相当的慢。所以，这就引入了另外一种方法——随机梯度下降。</p><p>　　对于批量梯度下降法，样本个数m，x为n维向量，一次迭代需要把m个样本全部带入计算，迭代一次计算量为<img src="https://latex.codecogs.com/svg.image?m*n^2" title="m*n^2" />。</p><h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><p>(1)上面的风险函数可以写成如下这种形式，损失函数对应的是训练集中每个样本的粒度，而上面批量梯度下降对应的是所有的训练样本：</p><p><img src="https://latex.codecogs.com/svg.image?&space;J(\theta)=\frac{1}{m}\sum_{i=1}^m\frac{1}{2}(y^i-h\theta(x^i))^2=\frac{1}{m}\sum_{i=1}^mcost(\theta,(x^i,y^i))" title=" J(\theta)=\frac{1}{m}\sum_{i=1}^m\frac{1}{2}(y^i-h\theta(x^i))^2=\frac{1}{m}\sum_{i=1}^mcost(\theta,(x^i,y^i))" /></p><p><img src="https://latex.codecogs.com/svg.image?cost(\theta,(x^i,y^i))=\frac{1}{2}(y^i-h_\theta(x^i))^2" title="cost(\theta,(x^i,y^i))=\frac{1}{2}(y^i-h_\theta(x^i))^2" /></p><p>(2)每个样本的损失函数，对theta求偏导得到对应梯度，来更新theta：</p><p><img src="https://latex.codecogs.com/svg.image?\theta_j^{'}=\theta_j&plus;(y^i-h\theta(x^i))x_j^i" title="\theta_j^{'}=\theta_j+(y^i-h\theta(x^i))x_j^i" /></p><p>(3)随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况(例如几十万)，那么可能只用其中几万条或者几千条的样本，就已经将theta迭代到最优解了，对比上面的批量梯度下降，迭代一次需要用到十几万训练样本，一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。</p><p>　　随机梯度下降每次迭代只使用一个样本，迭代一次计算量为n2，当样本个数m很大的时候，随机梯度下降迭代一次的速度要远高于批量梯度下降方法。<strong>两者的关系可以这样理解：随机梯度下降方法以损失很小的一部分精确度和增加一定数量的迭代次数为代价，换取了总体的优化效率的提升。增加的迭代次数远远小于样本的数量。</strong></p><h1 id="牛顿法和拟牛顿法"><a href="#牛顿法和拟牛顿法" class="headerlink" title="牛顿法和拟牛顿法"></a>牛顿法和拟牛顿法</h1><h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p><strong>牛顿法</strong>(英语：Newton’s method)又称为<strong>牛顿-拉弗森方法</strong>(英语：Newton-Raphson method)，它是一种在实数域和复数域上近似求解方程的方法。方法使用函数f(x)的<a href="https://zh.wikipedia.org/wiki/泰勒级数">泰勒级数</a>的前面几项来寻找方程<code>f(x)=0</code>的根。</p><h3 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h3><p>首先,选择一个接近函数f(x)零点的x0,计算相应的f(x0)和切线斜率f’(x0)(这里f表示函数f的导数)。然后我们计算穿过点(x0,f(x0))并且斜率为f’(x0)的直线和x轴的交点的x坐标,也就是求如下方程的解:</p><p><img src="https://latex.codecogs.com/svg.image?0=(x-x_0)\cdot&space;f^{'}(x_0)&plus;f(x_0)" title="0=(x-x_0)\cdot f^{'}(x_0)+f(x_0)" /></p><p>我们将新求得的点的x坐标命名为x1,通常x1会比x0更接近方程f(x)=0的解。因此我们现在可以利用x1开始下一轮迭代。迭代公式可化简为如下所示:</p><p><img src="https://latex.codecogs.com/svg.image?x_{n&plus;1}=x_n-\frac{f(x_n)}{f^{'}(x_n)}" title="x_{n+1}=x_n-\frac{f(x_n)}{f^{'}(x_n)}" /></p><p>然而当f(x)=0在x=a处有m重根时,这时牛顿法会降为线性收敛,虽然使用牛顿法也可以继续算下去,但收敛速度会减慢。</p><p><img src="/img/postImg/16_Algorithm/2_常见的优化算法/1_梯度下降法/600px-NewtonIteration_Ani.gif" alt=""></p><p>　　</p><h3 id="牛顿法的优缺点总结："><a href="#牛顿法的优缺点总结：" class="headerlink" title="牛顿法的优缺点总结："></a>牛顿法的优缺点总结：</h3><p>&bull; 优点：二阶收敛，收敛速度快；</p><p>&bull; 缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。</p><h2 id="拟牛顿法"><a href="#拟牛顿法" class="headerlink" title="拟牛顿法"></a>拟牛顿法</h2><p>拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。如今，优化软件中包含了大量的拟牛顿算法用来解决无约束，约束，和大规模的优化问题。</p><p><strong>拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。</strong></p><h3 id="搜索极值"><a href="#搜索极值" class="headerlink" title="搜索极值"></a>搜索极值</h3><p>与牛顿法相同,拟牛顿法是用一个二次函数以近似目标函数f(x). f(x)的阶泰勒展开是</p><p><img src="https://latex.codecogs.com/svg.image?x_k{\displaystyle&space;f(x_{k}&plus;\Delta&space;x)\approx&space;f(x_{k})&plus;\nabla&space;f(x_{k})^{T}\Delta&space;x&plus;{\frac{1}{2}}\Delta&space;x^{T}B\Delta&space;x.}" title="x_k{\displaystyle f(x_{k}+\Delta x)\approx f(x_{k})+\nabla f(x_{k})^{T}\Delta x+{\frac{1}{2}}\Delta x^{T}B\Delta x.}" /></p><p>其中,  <img src="https://latex.codecogs.com/svg.image?\nabla&space;f" title="\nabla f" />表示f(x)的梯度,B表示Hessian矩阵<strong>H[f(x)]</strong>的近似.梯度<img src="https://latex.codecogs.com/svg.image?\nabla&space;f" title="\nabla f" />可进一步近似为下列形式</p><p><img src="https://latex.codecogs.com/svg.image?{\displaystyle\nabla&space;f(x_{k}&plus;\Delta&space;x)\approx\nabla&space;f(x_{k})&plus;B\Delta&space;x.}" title="{\displaystyle\nabla f(x_{k}+\Delta x)\approx\nabla f(x_{k})+B\Delta x.}" /></p><p>令上式等于0,计算出Newton步长△x,</p><p><img src="https://latex.codecogs.com/svg.image?{\displaystyle\Delta&space;x=-B^{-1}\nabla&space;f(x_{k}).}" title="{\displaystyle\Delta x=-B^{-1}\nabla f(x_{k}).}" /></p><p>然后构造<strong>H[f(x)]</strong>的近似B满足</p><p><img src="https://latex.codecogs.com/svg.image?{\displaystyle\nabla&space;f(x_{k}&plus;\Delta&space;x)=\nabla&space;f(x_{k})&plus;B\Delta&space;x.}" title="{\displaystyle\nabla f(x_{k}+\Delta x)=\nabla f(x_{k})+B\Delta x.}" /></p><p>以下方式更新B</p><p><img src="https://latex.codecogs.com/svg.image?{\displaystyle&space;B_{k&plus;1}=\arg\min&space;_{B}\|B-B_{k}\|_{V}.}" title="{\displaystyle B_{k+1}=\arg\min _{B}\|B-B_{k}\|_{V}.}" /></p><p>近似<a href="https://zh.wikipedia.org/wiki/Hessian矩阵">Hessian矩阵</a>一般以单位矩阵等作为初期值. 最优化问题的解<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6d2b88c64c76a03611549fb9b4cf4ed060b56002" alt="{\displaystyle x_{k}}">由根据近似所得的<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6a6457760e36cf45e1471e33bcc1536cb4802fb9" alt="{\displaystyle B_{k}}">计算出的Newton步长更新得出.</p><p>以下为该算法的总结:</p><p>&bull; <img src="https://latex.codecogs.com/svg.image?{\displaystyle\Delta&space;x_{k}=-\alpha&space;B_{k}^{-1}\nabla&space;f(x_{k})}" title="{\displaystyle\Delta x_{k}=-\alpha B_{k}^{-1}\nabla f(x_{k})}" /></p><p>&bull; <img src="https://latex.codecogs.com/svg.image?{\displaystyle&space;x_{k&plus;1}=x_{k}&plus;\Delta&space;x_{k}}" title="{\displaystyle x_{k+1}=x_{k}+\Delta x_{k}}" /></p><p>&bull; 计算新一个迭代点下的梯度<img src="https://latex.codecogs.com/svg.image?{\displaystyle\nabla&space;f(x_{k&plus;1})}" title="{\displaystyle\nabla f(x_{k+1})}" /></p><p>&bull; 令<img src="https://latex.codecogs.com/svg.image?{\displaystyle&space;y_{k}=\nabla&space;f(x_{k&plus;1})-\nabla&space;f(x_{k})}" title="{\displaystyle y_{k}=\nabla f(x_{k+1})-\nabla f(x_{k})}" /></p><p>&bull; 利用<img src="https://latex.codecogs.com/svg.image?{\displaystyle&space;y_{k}}" title="{\displaystyle y_{k}}" />, 直接近似Hessian矩阵的逆矩阵<img src="https://latex.codecogs.com/svg.image?{\displaystyle&space;B_{k&plus;1}^{-1}}" title="{\displaystyle B_{k+1}^{-1}}" />. 近似的方法如下表:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Method</th><th style="text-align:center"><img src="https://latex.codecogs.com/svg.image?{\displaystyle\displaystyle&space;B_{k&plus;1}=}" title="{\displaystyle\displaystyle B_{k+1}=}" /></th><th style="text-align:center"><img src="https://latex.codecogs.com/svg.image?{\displaystyle&space;H_{k&plus;1}=B_{k&plus;1}^{-1}=}" title="{\displaystyle H_{k+1}=B_{k+1}^{-1}=}" /></th></tr></thead><tbody><tr><td style="text-align:center">DFP法</td><td style="text-align:center"><img src="https://latex.codecogs.com/svg.image?{\displaystyle\left(I-{\frac{y_{k}\,\Delta&space;x_{k}^{T}}{y_{k}^{T}\,\Delta&space;x_{k}}}\right)B_{k}\left(I-{\frac{\Delta&space;x_{k}y_{k}^{T}}{y_{k}^{T}\,\Delta&space;x_{k}}}\right)&plus;{\frac{y_{k}y_{k}^{T}}{y_{k}^{T}\,\Delta&space;x_{k}}}" title="{\displaystyle\left(I-{\frac{y_{k}\,\Delta x_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}}\right)B_{k}\left(I-{\frac{\Delta x_{k}y_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}}\right)+{\frac{y_{k}y_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}}" /></td><td style="text-align:center"><img src="https://latex.codecogs.com/svg.image?{\displaystyle&space;H_{k}&plus;{\frac{\Delta&space;x_{k}\Delta&space;x_{k}^{T}}{y_{k}^{T}\,\Delta&space;x_{k}}}-{\frac{H_{k}y_{k}y_{k}^{T}H_{k}^{T}}{y_{k}^{T}H_{k}y_{k}}}" title="{\displaystyle H_{k}+{\frac{\Delta x_{k}\Delta x_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}}-{\frac{H_{k}y_{k}y_{k}^{T}H_{k}^{T}}{y_{k}^{T}H_{k}y_{k}}}" /></td></tr><tr><td style="text-align:center">BFGS法</td><td style="text-align:center"><img src="https://latex.codecogs.com/svg.image?{\displaystyle&space;B_{k}&plus;{\frac{y_{k}y_{k}^{T}}{y_{k}^{T}\Delta&space;x_{k}}}-{\frac{B_{k}\Delta&space;x_{k}(B_{k}\Delta&space;x_{k})^{T}}{\Delta&space;x_{k}^{T}B_{k}\,\Delta&space;x_{k}}}}" title="{\displaystyle B_{k}+{\frac{y_{k}y_{k}^{T}}{y_{k}^{T}\Delta x_{k}}}-{\frac{B_{k}\Delta x_{k}(B_{k}\Delta x_{k})^{T}}{\Delta x_{k}^{T}B_{k}\,\Delta x_{k}}}}" /></td><td style="text-align:center"><img src="https://latex.codecogs.com/svg.image?{\displaystyle\left(I-{\frac{y_{k}\Delta&space;x_{k}^{T}}{y_{k}^{T}\Delta&space;x_{k}}}\right)^{T}H_{k}\left(I-{\frac{y_{k}\Delta&space;x_{k}^{T}}{y_{k}^{T}\Delta&space;x_{k}}}\right)&plus;{\frac{\Delta&space;x_{k}\Delta&space;x_{k}^{T}}{y_{k}^{T}\,\Delta&space;x_{k}}}" title="{\displaystyle\left(I-{\frac{y_{k}\Delta x_{k}^{T}}{y_{k}^{T}\Delta x_{k}}}\right)^{T}H_{k}\left(I-{\frac{y_{k}\Delta x_{k}^{T}}{y_{k}^{T}\Delta x_{k}}}\right)+{\frac{\Delta x_{k}\Delta x_{k}^{T}}{y_{k}^{T}\,\Delta x_{k}}}" /></td></tr><tr><td style="text-align:center">Broyden法</td><td style="text-align:center"><img src="https://latex.codecogs.com/svg.image?{\displaystyle&space;B_{k}&plus;{\frac{y_{k}-B_{k}\Delta&space;x_{k}}{\Delta&space;x_{k}^{T}\,\Delta&space;x_{k}}}\,\Delta&space;x_{k}^{T}" title="{B_{k}+{\frac{y_{k}-B_{k}\Delta x_{k}}{\Delta x_{k}^{T}\,\Delta x_{k}}}\,\Delta x_{k}^{T}" /></td><td style="text-align:center"><img src="https://latex.codecogs.com/svg.image?{\displaystyle&space;H_{k}&plus;{\frac{(\Delta&space;x_{k}-H_{k}y_{k})\Delta&space;x_{k}^{T}H_{k}}{\Delta&space;x_{k}^{T}H_{k}\,y_{k}}}" title="{\displaystyle H_{k}+{\frac{(\Delta x_{k}-H_{k}y_{k})\Delta x_{k}^{T}H_{k}}{\Delta x_{k}^{T}H_{k}\,y_{k}}}" /></td></tr><tr><td style="text-align:center">Broyden族</td><td style="text-align:center"><img src="https://latex.codecogs.com/svg.image?{\displaystyle(1-\varphi&space;_{k})B_{k&plus;1}^{BFGS}&plus;\varphi&space;_{k}B_{k&plus;1}^{DFP},\qquad\varphi\in[0,1]}" title="{\displaystyle(1-\varphi _{k})B_{k+1}^{BFGS}+\varphi _{k}B_{k+1}^{DFP},\qquad\varphi\in[0,1]}" /></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">SR1法</td><td style="text-align:center"><img src="https://latex.codecogs.com/svg.image?{\displaystyle&space;B_{k}&plus;{\frac{(y_{k}-B_{k}\,\Delta&space;x_{k})(y_{k}-B_{k}\,\Delta&space;x_{k})^{T}}{(y_{k}-B_{k}\,\Delta&space;x_{k})^{T}\,\Delta&space;x_{k}}}}" title="{\displaystyle B_{k}+{\frac{(y_{k}-B_{k}\,\Delta x_{k})(y_{k}-B_{k}\,\Delta x_{k})^{T}}{(y_{k}-B_{k}\,\Delta x_{k})^{T}\,\Delta x_{k}}}}" /></td><td style="text-align:center"><img src="https://latex.codecogs.com/svg.image?{\displaystyle&space;H_{k}&plus;{\frac{(\Delta&space;x_{k}-H_{k}y_{k})(\Delta&space;x_{k}-H_{k}y_{k})^{T}}{(\Delta&space;x_{k}-H_{k}y_{k})^{T}y_{k}}}}" title="{\displaystyle H_{k}+{\frac{(\Delta x_{k}-H_{k}y_{k})(\Delta x_{k}-H_{k}y_{k})^{T}}{(\Delta x_{k}-H_{k}y_{k})^{T}y_{k}}}}" /></td></tr></tbody></table></div><h1 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h1><p><strong>共轭梯度法</strong>(英语：Conjugate gradient method)，是求解系数矩阵为对称正定矩阵的线性方程组的数值解的方法。共轭梯度法是一个迭代方法，它适用于系数矩阵为稀疏矩阵的线性方程组，因为使用像Cholesky分解这样的直接方法求解这些系统所需的计算量太大了。这种方程组在数值求解偏微分方程时很常见。</p><p>共轭梯度法也可以用于求解无约束的最优化问题。</p><h2 id="方法的表述"><a href="#方法的表述" class="headerlink" title="方法的表述"></a>方法的表述</h2><p>要求解下列线性系统</p><p><img src="https://latex.codecogs.com/svg.image?Ax=b&space;" title="Ax=b " /></p><p>其中 nxn 矩阵 A 是对称的，正定的，并且是实系数的。 将系统的唯一解记作 x∗</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>经过一些简化，可以得到下列求解<img src="https://latex.codecogs.com/svg.image?Ax=b&space;" title="Ax=b " />的算法，其中A是实对称正定矩阵。</p><p><img src="/img/postImg/16_Algorithm/2_常见的优化算法/1_梯度下降法/共轭梯度法.svg" alt=""></p><h1 id="序列二次规划"><a href="#序列二次规划" class="headerlink" title="序列二次规划"></a>序列二次规划</h1><p>序列二次规划(Sequential Quadratic Programming，SQP)是一类用于解决非线性优化问题的迭代方法，广泛应用于约束优化问题，尤其是在控制、机器人学和工程设计中。SQP方法通过将非线性问题转化为一系列二次规划问题来逐步逼近最优解。它的基本思想是在每次迭代中通过求解一个二次优化问题，找到一个改进方向，并在此方向上更新当前解。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于非线性约束最优化问题，<strong>SQP（Sequential Quadratic Programming）</strong> 和 <strong>内点法</strong> 是两类非常重要的算法，可解决大规模的优化问题。</p><ul><li><strong>SQP</strong>：将原始问题分解为一系列二次规划（QP）问题逐步求解。  </li><li><strong>内点法</strong>：将约束添加到目标函数中，转换为一系列无约束问题逐步求解。  </li></ul><p>两者的共同思想：<strong>将原始问题转换为可求解的问题</strong>。</p><h3 id="SQP特点与应用"><a href="#SQP特点与应用" class="headerlink" title="SQP特点与应用"></a>SQP特点与应用</h3><ul><li>能处理任何自由度的非线性约束，功能强大。</li><li>广泛应用于：<ul><li>统计学中的曲线拟合</li><li>机器学习中支持向量机（SVM）计算</li><li>机器人技术中的逆运动学问题等</li></ul></li><li>算法由剑桥大学数学家 <strong>M.J.D Powell</strong> 提出，使用 <strong>Newton-Raphson</strong> 方法求解 <strong>Kuhn-Tucker (KKT)</strong> 方程组。</li><li>为减少偏微分计算量，可改为 <strong>拟牛顿法（Quasi-Newton）</strong>。</li></ul><p><strong>核心思想</strong>：对约束优化问题的一阶最优性条件应用近似牛顿法，在每次迭代中求解一个以拉格朗日函数的二阶近似为目标函数、以原约束的线性化近似为约束条件的 QP 问题。</p><blockquote><p>1980 年的研究 [1] 表明，在测试的 20 多种非线性算法中，SQP 与 GRG 排名前列。GRG 更鲁棒但计算量稍大。</p></blockquote><hr><h2 id="Newton-Raphson-N-R-方法简述"><a href="#Newton-Raphson-N-R-方法简述" class="headerlink" title="Newton-Raphson (N-R) 方法简述"></a>Newton-Raphson (N-R) 方法简述</h2><p>当无法直接求解方程未知数时：</p><ol><li>在预测点或迭代点进行泰勒展开。</li><li>用切线（或割线）与零线的交点投影到函数上，作为新的迭代点。</li><li>不断迭代直至误差满足要求。</li></ol><p>扩展到多变量多方程（非线性）时：</p><ul><li>微分 → 偏微分</li><li>有解析导数时，可直接求雅可比矩阵；无解析导数时，可用差分法。</li></ul><p>实际问题中：</p><ul><li>常遇到 <strong>雅可比矩阵奇异</strong> 或 <strong>步长选择不当导致收敛失败</strong>，因此有变步长方法。</li><li>工程中常需连续求解非线性方程组（如参数变化对系统稳态解的影响、临界速度分析、阈值计算等），对计算速度要求很高。</li></ul><hr><h2 id="Lagrange-Newton-基于-SQP-的方法"><a href="#Lagrange-Newton-基于-SQP-的方法" class="headerlink" title="Lagrange-Newton 基于 SQP 的方法"></a>Lagrange-Newton 基于 SQP 的方法</h2><h3 id="1-Lagrangian-方程"><a href="#1-Lagrangian-方程" class="headerlink" title="1. Lagrangian 方程"></a>1. Lagrangian 方程</h3><p>Lagrange 方程整合了目标函数与约束条件：</p><ul><li>λ：等式约束乘子</li><li>μ：不等式约束乘子</li></ul><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p><img src="https://www.easyera.tech/wp-content/uploads/2020/11/L.png" alt="Lagrangian 方程"></p><h3 id="2-KKT-条件"><a href="#2-KKT-条件" class="headerlink" title="2. KKT 条件"></a>2. KKT 条件</h3><p>通过求梯度为零的临界点实现优化，这就是 <strong>KKT 条件</strong>。Newton 法可用于求解该非线性方程组。</p><h1 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h1><p><img src="https://www.easyera.tech/wp-content/uploads/2020/11/L-1.png" alt="KKT 条件"></p><h3 id="3-SQP-的二次规划近似"><a href="#3-SQP-的二次规划近似" class="headerlink" title="3. SQP 的二次规划近似"></a>3. SQP 的二次规划近似</h3><p>SQP 的迭代步骤：</p><ul><li>对目标函数与约束函数进行泰勒展开</li><li>将问题等效为二次规划问题</li></ul><p><strong>典型公式</strong>：</p><script type="math/tex; mode=display">\left\{\begin{matrix}\text{Active Set Strategy}\\\text{Lagrangian Relaxation}\\\text{Newton-Rapshon}\end{matrix}\right.</script><p>SQP 求解方程组形式：</p><script type="math/tex; mode=display">\left[\begin{array}{r|r}2\nabla^2 L & {\nabla}' g \\\hline\nabla g & 0\end{array}\right]\begin{bmatrix}\Delta x \\\hline\Delta \lambda\end{bmatrix}=\begin{bmatrix}\nabla L(x, \Lambda) \\\hlineg(\chi)\end{bmatrix}</script><hr><h2 id="SQP方法的基本步骤"><a href="#SQP方法的基本步骤" class="headerlink" title="SQP方法的基本步骤"></a>SQP方法的基本步骤</h2><h3 id="目标函数和约束的泰勒展开"><a href="#目标函数和约束的泰勒展开" class="headerlink" title="目标函数和约束的泰勒展开"></a>目标函数和约束的泰勒展开</h3><p>&bull; 对于给定的非线性目标函数和约束条件，SQP方法首先对目标函数和约束条件在当前点进行一阶(梯度)和二阶(Hessian矩阵)泰勒展开。</p><h3 id="构造二次规划子问题"><a href="#构造二次规划子问题" class="headerlink" title="构造二次规划子问题"></a>构造二次规划子问题</h3><p>&bull; 使用当前点的信息(包括目标函数的梯度和约束的雅可比矩阵、Hessian矩阵等)来构造一个近似的二次规划问题(QP)。</p><p>&bull; 该QP问题通常形如</p><p><img src="https://latex.codecogs.com/svg.image?\min\limits_{\delta&space;x}\frac{1}{2}\delta&space;x^TH_k\delta&space;x&plus;g_k^T\delta&space;x&space;" title="\min\limits_{\delta x}\frac{1}{2}\delta x^TH_k\delta x+g_k^T\delta x " /></p><p>&bull; 其中，Hk是目标函数的Hessian矩阵的近似，gk是目标函数梯度的近似，δx是当前解的改进方向。</p><h3 id="解二次规划子问题"><a href="#解二次规划子问题" class="headerlink" title="解二次规划子问题"></a>解二次规划子问题</h3><p>&bull; 通过求解上面构造的QP子问题，得到一个搜索方向(即改进方向)δx，并更新当前解： </p><p><img src="https://latex.codecogs.com/svg.image?x_{k&plus;1}=x_k&plus;\delta&space;x_k&space;" title="x_{k+1}=x_k+\delta x_k " /></p><h3 id="判断收敛性"><a href="#判断收敛性" class="headerlink" title="判断收敛性"></a>判断收敛性</h3><p>&bull; 判断算法是否满足收敛准则(例如目标函数的变化足够小、梯度足够接近零、约束条件得到满足等)。如果收敛条件满足，则终止；否则，返回步骤1继续迭代。</p><h3 id="约束处理"><a href="#约束处理" class="headerlink" title="约束处理"></a>约束处理</h3><p>&bull; SQP方法通过引入拉格朗日乘子来处理约束问题。约束可以是等式约束或不等式约束，常见的约束类型包括线性约束和非线性约束。</p><h2 id="SQP的优点"><a href="#SQP的优点" class="headerlink" title="SQP的优点"></a>SQP的优点</h2><p>&bull; 高效性: SQP在大多数优化问题中表现出较快的收敛速度，尤其适用于具有光滑目标函数和约束的非线性优化问题。</p><p>&bull; 适应性: 能够处理各种类型的约束(包括等式约束、不等式约束、边界约束等)。</p><p>&bull; 精确性: 由于每一步都通过求解一个二次规划问题，它能较精确地逼近局部最优解。</p><h2 id="SQP的缺点"><a href="#SQP的缺点" class="headerlink" title="SQP的缺点"></a>SQP的缺点</h2><p>&bull; 计算成本高: 每次迭代都需要求解一个二次规划问题，这可能需要较高的计算资源，尤其是在问题规模较大时。</p><p>&bull; 需要二阶导数信息: SQP需要目标函数和约束的Hessian矩阵(或其近似)，这在某些情况下可能难以获得，或者计算复杂。</p><p>&bull; 对初始值敏感: SQP对初始解有一定的依赖性，若初始解距离最优解较远，可能会收敛到局部最优解。</p><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><p>SQP方法在许多领域中得到了广泛应用，特别是以下几类问题：</p><p>&bull; 机器人学中的路径规划和轨迹优化:SQP常用于求解具有非线性约束的运动规划问题，如机器人路径的优化。</p><p>&bull; 控制理论: SQP用于求解最优控制问题，尤其是涉及非线性动力学和约束的控制问题。</p><p>&bull; 结构优化: 在工程设计中，SQP可用于结构优化问题，例如材料分布的优化。</p><p>&bull; 经济学和金融中的最优决策: SQP也可用于经济学和金融领域中的非线性最优化问题，如投资组合优化。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] chatGPT</p><p>[2] <a href="https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95">维基百科</a></p><p>[3] <a href="https://www.cnblogs.com/xinbaby829/p/7289431.html">几种常见的优化算法</a></p><p>[4] <a href="https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95">牛顿法</a></p>]]></content>
      
      
      <categories>
          
          <category> ALGORITHM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> algorithm </tag>
            
            <tag> optimal algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手眼标定</title>
      <link href="/2024/12/12/archived_robot_calib_%E6%9C%BA%E6%A2%B0%E8%87%82%E4%B8%8E%E7%9B%B8%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E6%A0%87%E5%AE%9A/"/>
      <url>/2024/12/12/archived_robot_calib_%E6%9C%BA%E6%A2%B0%E8%87%82%E4%B8%8E%E7%9B%B8%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E6%A0%87%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#in-hand-camera">In-Hand Camera</a></li><li><a href="#fixed-camera">Fixed Camera</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>手眼标定是将相机坐标系下的物体坐标转换到机械臂坐标系下(比如机器人基座base系，或者自定义的世界系，如人形机械臂参考的固定的世界系等)的常用技术。常见的安装方式主要有如下两种</p><p>&bull; In-Hand Camera：相机安装在机械臂的末端，随机械臂一起运动，用于获取更接近操作的视觉信息。</p><p>&bull; Fixed Camera：相机固定在某个位置，不随机械臂运动，适用于获取整个工作区域的视觉信息。</p><h1 id="In-Hand-Camera"><a href="#In-Hand-Camera" class="headerlink" title="In-Hand Camera"></a>In-Hand Camera</h1><p>In-Hand Camera的标定是为了求出相机与机械臂末端工具(TOOL)之间的变换关系，一般是一个大小为4x4的刚体变换矩阵, 在KDL可以用Frame中声明这个变量, 由于输入公式较为麻烦，这里我就用自己写代码的方式进行阐述，比如T_B_E表示机械臂末端(end-effector)或法兰在基座BASE下的表示, 这里假设工具参数已提前通过4点法或6点法标定得到，视作为一个精确的值。</p><p>标定时，将一个已知精确大小的标定板（比如棋盘格）固定放置, 然后让机械臂运动，以使相机可以从多个不同角度拍摄标定板图像，拍摄图像的时确保棋盘格图像不超出图像边界，并记录对应的机械臂末端位姿。假设相机内参已知，每一张标定板图像都可以算出相机（C）在标定板（P）下的位姿T_C_P, 这里定义 T_E_C为相机在末端工具坐标系下的表示，对于每一张图片有如下关系式成立(对消直接能看出来, 结果均为T_B_C, 即相机在BASE下的表示)</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">T_B_E * T_E_C <span class="operator">=</span> T_B_P * T_P_C</span><br></pre></td></tr></table></figure><p>做下一步变换，消除T_B_P, 由于标定版是相对BASE固定的，所以对应任一标定数据，有(下标为i为第i个数据，j类似)</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Ti_B_E * T_E_C * Ti_C_P <span class="operator">=</span> Tj_B_E * T_E_C * Tj_C_P </span><br></pre></td></tr></table></figure><p>两边左乘Tj_B_E的逆有</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">T_j_E_B * Ti_B_E * T_E_C * Ti_C_P <span class="operator">=</span> T_E_C * Tj_C_P</span><br></pre></td></tr></table></figure><p>再右乘Ti_C_P的逆有</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">T_j_E_B * Ti_B_E * T_E_C  <span class="operator">=</span> T_E_C * Tj_C_P * Ti_P_C</span><br></pre></td></tr></table></figure><p>对于T_j_E_B <em> Ti_B_E，  Tj_C_P </em> Ti_P_C， 都是已知的，方程就变为典型的<code>AX=XB</code>的形式, 这类方程有很多解法，比如Tsai方法，dual-quaternion方法以及Kronecker Product方法等, 将所需的参数输入到具体的算法中后即可标定出T_E_C的结果，也就是相机在工具系下的表示(这样物体在相机系下的表示就可以转到末端工具系下进行表示了)。比如相机识别了焊缝的点位信息后，转到工具系下就可以直接去做焊接相关的工作了。</p><h1 id="Fixed-Camera"><a href="#Fixed-Camera" class="headerlink" title="Fixed Camera"></a>Fixed Camera</h1><p>对Fixed Camera进行手眼标定时，主要关注相机（C）到Base frame（B）之间的变换, 也可以是相机到World frame(W)之间的变换，在人形机器人中一般会转到世界系下去做表示，这里简单的对从C到B之间的转换做个说明, 标定的时候有一些区别，这时候相机是在固定的位置，比如人形机器人的头部位置，手上固定着标定版，然后运动机械臂，使相机能从不同视角拍摄到标定板，每拍摄图像时，同时记录当时机械臂末端的位姿(用工具或者法兰表示都可以)。</p><p>不难发现如下关系，</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">T_B_E * T_E_P <span class="operator">=</span> T_B_C * T_C_P</span><br></pre></td></tr></table></figure><p>用上述同样的方式，有(此时末端工具，比如手与标定版T_E_P之间是不变的)</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Ti_E_B * T_B_C * Ti_C_P <span class="operator">=</span> Tj_E_B * T_B_C * Tj_C_P</span><br></pre></td></tr></table></figure><p>同样的操作，有</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Tj_B_E * Ti_E_B * T_B_C <span class="operator">=</span> T_B_C * Tj_C_P * Ti_P_C</span><br></pre></td></tr></table></figure><p>又变成了<code>AX=XB</code> 的方式，同样求解即可得到T_B_C, 即相机在BASE下的表示，如果把BASE换成World, 可以得到相机在世界系下的表示。</p><p>求解可以直接调用成熟的库如<code>open-cv</code>, 原理还是很简单的，这样对手眼标定这个常用的技术就有了更深入的认识了。若想知道更多的有关相机内外参的标定 可以看看<a href="https://blog.csdn.net/hehedadaq/article/details/105763241">张正友标定法</a>, 就明白为啥要引入棋盘格进行标定了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://blog.csdn.net/hehedadaq/article/details/105763241">【一文弄懂】张正友标定法-完整学习笔记-从原理到实战</a></p>]]></content>
      
      
      <categories>
          
          <category> ROBOTICS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> robot </tag>
            
            <tag> calibration </tag>
            
            <tag> algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程编程学习笔记（一）</title>
      <link href="/2024/12/03/archived_cpp_thread_learning1/"/>
      <url>/2024/12/03/archived_cpp_thread_learning1/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#多线程的基本概念">多线程的基本概念</a></li><li><a href="#创建线程">创建线程</a></li><li><a href="#线程同步与共享数据">线程同步与共享数据</a><ul><li><a href="#使用mutex进行同步">使用mutex进行同步</a></li></ul></li><li><a href="#线程的常见操作">线程的常见操作</a><ul><li><a href="#detach">detach</a></li><li><a href="#线程的返回值">线程的返回值</a></li></ul></li><li><a href="#总结">总结</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人想了解这块内容，文章中所提及的，来源于 chatGPT, 若后面了解的过程中发现其所表述有误的话，再做修正吧。</p><h1 id="多线程的基本概念"><a href="#多线程的基本概念" class="headerlink" title="多线程的基本概念"></a>多线程的基本概念</h1><p>在计算机中，线程是进程中的一个执行单元。一个程序可以由多个线程组成，线程间共享程序的资源（例如内存），但每个线程有自己的执行路径。通常，会创建多个线程并发执行不同的任务，从而实现并行计算。</p><p>线程的基本结构：</p><p>&bull; 进程：一个运行中的程序，每个进程有自己的地址空间、资源等。</p><p>&bull; 线程：进程中的最小执行单元，每个线程有自己的栈空间，多个线程共享进程的资源（例如内存、文件描述符等）。</p><h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>C++11引入了对多线程的支持，提供了<thread>库来方便地创建和管理线程。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的函数，将被线程执行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并启动一个线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(hello)</span></span>;  <span class="comment">// 传递hello函数给线程t</span></span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 等待线程完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><p>&bull; <code>std::thread t(hello);</code>:创建一个线程t，并让它执行hello函数。</p><p>&bull; <code>t.join();</code>: join()方法用于等待线程执行完毕。如果没有调用join()或detach()，程序可能会在主线程结束时直接退出，导致子线程未执行完毕。</p><h1 id="线程同步与共享数据"><a href="#线程同步与共享数据" class="headerlink" title="线程同步与共享数据"></a>线程同步与共享数据</h1><p>多个线程同时访问共享数据时，会发生<code>数据竞争</code>，即多个线程同时修改数据，导致不一致的结果。因此，需要使用同步机制来避免这种情况。</p><h2 id="使用mutex进行同步"><a href="#使用mutex进行同步" class="headerlink" title="使用mutex进行同步"></a>使用mutex进行同步</h2><p>C++提供了<code>std::mutex</code>来保证同一时刻只有一个线程能够访问共享资源。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;  <span class="comment">// 定义一个互斥锁</span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 自动加锁，作用域结束后自动解锁</span></span><br><span class="line">    ++shared_data;  <span class="comment">// 访问共享数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;  <span class="comment">// 应该输出 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程的常见操作"><a href="#线程的常见操作" class="headerlink" title="线程的常见操作"></a>线程的常见操作</h1><h2 id="detach"><a href="#detach" class="headerlink" title="detach"></a>detach</h2><p><code>detach():</code> 将线程与主线程分离，主线程退出时，分离线程将继续执行。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(hello)</span></span>;</span><br><span class="line">t.<span class="built_in">detach</span>();  <span class="comment">// 线程将独立执行，不需要等待</span></span><br></pre></td></tr></table></figure><h2 id="线程的返回值"><a href="#线程的返回值" class="headerlink" title="线程的返回值"></a>线程的返回值</h2><p>可以让线程返回结果，可以通过<code>std::future</code>和<code>std::promise</code>实现。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, add, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::async():</code> 异步启动一个线程来执行add函数，并返回一个<code>std::future</code>对象，稍后可以通过result.get()获取返回值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&bull; 创建线程：使用std::thread类。</p><p>&bull; 线程同步：使用std::mutex来保护共享资源。</p><p>&bull; 线程间通信：使用std::future和std::promise来实现线程之间的通信和获取返回值。</p><p>&bull; 线程生命周期管理：使用join()等待线程结束，detach()让线程与主线程分离。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] chatGPT</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 中的容器</title>
      <link href="/2024/10/28/archived_CPP_STL_%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/10/28/archived_CPP_STL_%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#什么是stl">什么是STL?</a></li><li><a href="#容器containers">容器(Containers)</a><ul><li><a href="#vector">vector</a><ul><li><a href="#特点">特点</a></li><li><a href="#适用场景">适用场景</a></li><li><a href="#例子">例子</a></li></ul></li><li><a href="#deque">deque</a><ul><li><a href="#特点-1">特点</a></li><li><a href="#适用场景-1">适用场景</a></li><li><a href="#例子-1">例子</a></li></ul></li><li><a href="#list">list</a><ul><li><a href="#特点-2">特点</a></li><li><a href="#适用场景-2">适用场景</a></li><li><a href="#例子-2">例子</a></li></ul></li><li><a href="#set">set</a><ul><li><a href="#特点-3">特点</a></li><li><a href="#适用场景-3">适用场景</a></li><li><a href="#例子-3">例子</a></li></ul></li><li><a href="#map">map</a><ul><li><a href="#特点-4">特点</a></li><li><a href="#适用场景-4">适用场景</a></li><li><a href="#例子-4">例子</a></li></ul></li><li><a href="#容器配接器">容器配接器</a></li></ul></li><li><a href="#总结">总结</a><ul><li><a href="#各容器的特点总结">各容器的特点总结</a><ul><li><a href="#各容器的时间复杂度分析">各容器的时间复杂度分析</a></li><li><a href="#各容器的共性">各容器的共性</a></li></ul></li></ul></li><li><a href="#搬运源">搬运源</a></li></ul><!-- vim-markdown-toc --><h1 id="什么是STL"><a href="#什么是STL" class="headerlink" title="什么是STL?"></a>什么是STL?</h1><p>1、STL(Standard Template Library)，即标准模板库，是一个高效的C++程序库，包含了诸多常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。</p><p>2、从逻辑层次来看，在STL中体现了泛型化程序设计的思想(generic programming)。在这种思想里，大部分基本算法被抽象，被泛化，独立于与之对应的数据结构，用于以相同或相近的方式处理各种不同情形。</p><p>3、从实现层次看，整个STL是以一种类型参数化(type parameterized)的方式实现的，基于模板(template)。</p><p>STL有六大组件，但主要包含容器、迭代器和算法三个部分。</p><p><code>容器(Containers)</code>:用来管理某类对象的集合。每一种容器都有其优点和缺点，所以为了应付程序中的不同需求，STL 准备了七种基本容器类型。</p><p><code>迭代器(Iterators)</code>:用来在一个对象集合的元素上进行遍历动作。这个对象集合或许是个容器，或许是容器的一部分。每一种容器都提供了自己的迭代器，而这些迭代器了解该种容器的内部结构。</p><p><code>算法(Algorithms)</code>:用来处理对象集合中的元素，比如 Sort，Search，Copy，Erase 那些元素。通过迭代器的协助，我们只需撰写一次算法，就可以将它应用于任意容器之上，这是因为所有容器的迭代器都提供一致的接口。</p><p>STL 的基本观念就是将数据和操作分离。数据由容器进行管理，操作则由算法进行，而迭代器在两者之间充当粘合剂，使任何算法都可以和任何容器交互运作。这一篇博客暂时只介绍容器，下一篇介绍迭代器。</p><h1 id="容器-Containers"><a href="#容器-Containers" class="headerlink" title="容器(Containers)"></a>容器(Containers)</h1><p>容器用来管理某类对象。为了应付程序中的不同需求，STL 准备了两类共七种基本容器类型:</p><p><code>序列式容器(Sequence containers)</code>，此为可序群集，其中每个元素均有固定位置—取决于插入时机和地点，和元素值无关。如果你以追加方式对一个群集插入六个元素，它们的排列次序将和插入次序一致。STL提供了三个序列式容器:向量(<code>vector</code>)、双端队列(<code>deque</code>)、列表(<code>list</code>)，此外你也可以把 <code>string</code> 和 <code>array</code> 当做一种序列式容器。</p><p><code>关联式容器(Associative containers)</code>，此为已序群集，元素位置取决于特定的排序准则以及元素值，和插入次序无关。如果你将六个元素置入这样的群集中，它们的位置取决于元素值，和插入次序无关。STL提供了四个关联式容器:集合(<code>set</code>)、多重集合(<code>multiset</code>)、映射(<code>map</code>)和多重映射(<code>multimap</code>)。</p><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector(向量): 是一种序列式容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能动态拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而 vector 正好弥补了这个缺陷，当内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>&bull; 拥有一段连续的内存空间，因此它能非常好的支持随机访问，即 [] 操作符和 .at()，随机访问快。(优点)</p><p>&bull; 当向其头部或中间插入或删除元素时，为了保持原本的相对次序，插入或删除点之后的所有元素都必须移动，所以插入或删除的效率比较低。(缺点)</p><p>&bull; 在后面插入删除元素最快，此时一般不需要移动内存。(优点)</p><p>总结:相当于可拓展的数组(动态数组)，随机访问快，在头部和中间插入或删除效率低，但在尾部插入或删除效率高。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>适用于对象简单，变化较小，并且频繁随机访问的场景。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下例子针对整型定义了一个 vector，插入 6 个元素，然后打印所有元素:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecTemp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">vecTemp.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;vecTemp.<span class="built_in">size</span>(); i++)</span><br><span class="line">cout &lt;&lt; vecTemp[i] &lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 输出:0 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque(double-ended queue)是双向开口的连续内存空间(动态将多个连续空间通过指针数组接合在一起)，随时可以增加一段新的空间。deque 的最大任务就是在这些分段的连续空间上，维护其整体连续的假象，并提供随机存取的接口。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>&bull; 一旦要在 deque 的头部和尾部增加新空间，便配置一段定量连续空间，串在整个 deque 的头部或尾部，因此不论在头部或尾部插入元素都十分迅速。 (优点)</p><p>&bull;  在中间部分安插元素则比较费时，因为必须移动其它元素。(缺点)</p><p>&bull;  deque 是 list 和 vector 的折中方案。兼有 list 的优点，也有 vector 随机访问效率高的优点。</p><p><strong>总结:</strong> 支持随机访问，但效率没有 vector 高，在头部和尾部插入或删除效率高，但在中间插入或删除效率低。</p><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>适用于既要频繁随机访问，又要关心两端数据的插入与删除的场景。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>以下例子声明了一个浮点类型的 deque，并在容器尾部插入 6 个元素，最后打印出所有元素。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">float</span>&gt; dequeTemp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">dequeTemp.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;dequeTemp.<span class="built_in">size</span>(); i++)</span><br><span class="line">cout &lt;&lt; dequeTemp[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出:0 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>List 由双向链表(doubly linked list)实现而成，元素存放在堆中，每个元素都是放在一块内存中。没有空间预留习惯，所以每分配一个元素都会从内存中分配，每删除一个元素都会释放它占用的内存。</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>&bull;  内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随机存取变得非常没有效率，因此它没有提供 [] 操作符的重载。(缺点)<br>由于链表的特点，在任意位置的插入和删除效率都较高。(优点)</p><p>&bull; 只支持首尾两个元素的直接存取，想获取其他元素(访问时间一样)，则需要遍历链表。(缺点)</p><p><strong>总结:</strong>不支持随机访问，在任意位置的插入和删除效率都较高。</p><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>适用于经常进行插入和删除操作并且不经常随机访问的场景。</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>以下例子产生一个空 list，准备放置字符，然后将 ‘a’ 至 ‘z’ 的所有字符插入其中，利用循环每次打印并移除集合的第一个元素，从而打印出所有元素:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">char</span>&gt; listTemp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; ++c)</span><br><span class="line">listTemp.<span class="built_in">push_back</span>(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!listTemp.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;listTemp.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">listTemp.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员函数empty()的返回值告诉我们容器中是否还有元素，只要这个函数返回 false，循环就继续进行。循环之内，成员函数front()会返回第一个元素，pop_front()函数会删除第一个元素。</p><p>注意:list&lt;指针&gt; 完全是性能最低的做法，还不如直接使用 list&lt;对象&gt; 或使用 vector&lt;指针&gt; 好，因为指针没有构造与析构，也不占用很大内存。</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set(集合)顾名思义，就是数学上的集合——每个元素最多只出现一次，并且 set 中的元素已经从小到大排好序。</p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>&bull; 使用红黑树实现，其内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复。</p><p>&bull; 每次插入值的时候，都需要调整红黑树，效率有一定影响。(缺点)</p><p>&bull; map 和 set 的插入或删除效率比用其他序列容器高，因为对于关联容器来说，不需要做内存拷贝和内存移动。(优点)</p><p><strong>总结:</strong>由红黑树实现，其内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复，且插入和删除效率比用其他序列容器高。</p><h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h3><p>适用于经常查找一个元素是否在某集合中且需要排序的场景。</p><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>下面的例子演示 set(集合)的两个特点:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; setTemp;</span><br><span class="line"></span><br><span class="line">setTemp.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setTemp.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setTemp.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">setTemp.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = setTemp.<span class="built_in">begin</span>(); it != setTemp.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:1 2 3。一共插入了 4 个数，但是集合中只有 3 个数并且是有序的，可见之前说过的 set 集合的两个特点，有序和不重复。</p><p>当 set 集合中的元素为结构体时，该结构体必须实现运算符 ‘&lt;’ 的重载:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> People p) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> age &lt; p.age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;People&gt; setTemp;</span><br><span class="line"></span><br><span class="line">setTemp.<span class="built_in">insert</span>(&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">14</span>&#125;);</span><br><span class="line">setTemp.<span class="built_in">insert</span>(&#123; <span class="string">&quot;李四&quot;</span>, <span class="number">16</span> &#125;);</span><br><span class="line">setTemp.<span class="built_in">insert</span>(&#123; <span class="string">&quot;隔壁老王&quot;</span>, <span class="number">10</span> &#125;);</span><br><span class="line"></span><br><span class="line">set&lt;People&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = setTemp.<span class="built_in">begin</span>(); it != setTemp.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;姓名:%s 年龄:%d\n&quot;</span>, (*it).name.<span class="built_in">c_str</span>(), (*it).age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">姓名:王二麻子 年龄:10</span></span><br><span class="line"><span class="section">姓名:张三 年龄:14</span></span><br><span class="line"><span class="section">姓名:李四 年龄:16</span></span><br></pre></td></tr></table></figure><p>可以看到结果是按照年龄由小到大的顺序排列。另外 string 要使用<code>c_str()</code>转换一下，否则打印出的是乱码。</p><p>另外 Multiset 和 set 相同，只不过它允许重复元素，也就是说 multiset 可包括多个数值相同的元素。这里不再做过多介绍。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>&bull;  map 由红黑树实现，其元素都是 “键值/实值” 所形成的一个对组(key/value pairs)。</p><p>&bull;  map 主要用于资料一对一映射的情况，map 内部自建一颗红黑树，这颗树具有对数据自动排序的功能，所以在 map 内部所有的数据都是有序的。比如一个班级中，每个学生的学号跟他的姓名就存在着一对一映射的关系。</p><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><p>&bull;  每个元素都有一个键，且只能出现一次，不允许重复。</p><p>&bull;  根据 key 值快速查找记录，查找的复杂度基本是 O(logN)，如果有 1000 个记录，二分查找最多查找 10次(1024)。(优点)</p><p>&bull;  每次插入值的时候，都需要调整红黑树，效率有一定影响。(缺点)</p><p>&bull;  增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。(优点)</p><p>&bull;  对于迭代器来说，可以修改实值，而不能修改 key。</p><p><strong>总结:</strong>元素为键值对，key 和 value 可以是任意你需要的类型，每个元素都有一个键，且只能出现一次，不允许重复，根据 key 快速查找记录。</p><h3 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h3><p>适用于需要存储一个数据字典，并要求方便地根据key找value的场景。</p><h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; mapTemp;</span><br><span class="line"></span><br><span class="line">mapTemp.<span class="built_in">insert</span>(&#123; <span class="number">5</span>,<span class="string">&quot;张三&quot;</span> &#125;);</span><br><span class="line">mapTemp.<span class="built_in">insert</span>(&#123; <span class="number">3</span>, <span class="string">&quot;李四&quot;</span>&#125;);</span><br><span class="line">mapTemp.<span class="built_in">insert</span>(&#123; <span class="number">4</span>, <span class="string">&quot;隔壁老王&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = mapTemp.<span class="built_in">begin</span>(); it != mapTemp.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;学号:%d 姓名:%s\n&quot;</span>, (*it).first, (*it).second.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">学号:3 姓名:李四</span></span><br><span class="line"><span class="section">学号:4 姓名:隔壁老王</span></span><br><span class="line"><span class="section">学号:5 姓名:张三</span></span><br></pre></td></tr></table></figure><p>multimap 和 map 相同，但允许重复元素，也就是说 multimap 可包含多个键值(key)相同的元素。这里不再做过多介绍。</p><h2 id="容器配接器"><a href="#容器配接器" class="headerlink" title="容器配接器"></a>容器配接器</h2><p>除了以上七个基本容器类别，为满足特殊需求，STL还提供了一些特别的(并且预先定义好的)容器配接器，根据基本容器类别实现而成。包括:</p><p>1、stack</p><p>名字说明了一切，stack 容器对元素采取 LIFO(后进先出)的管理策略。</p><p>2、queue</p><p>queue 容器对元素采取 FIFO(先进先出)的管理策略。也就是说，它是个普通的缓冲区(buffer)。</p><p>3、priority_queue</p><p>priority_queue 容器中的元素可以拥有不同的优先权。所谓优先权，乃是基于程序员提供的排序准则(缺省使用 operators)而定义。Priority queue 的效果相当于这样一个 buffer:“下一元素永远是queue中优先级最高的元素”。如果同时有多个元素具备最髙优先权，则其次序无明确定义。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="各容器的特点总结"><a href="#各容器的特点总结" class="headerlink" title="各容器的特点总结"></a>各容器的特点总结</h2><p>&bull;  vector 支持随机访问，在头部和中间插入或删除效率低，但在尾部插入或删除效率高。 支持随机访问，但效率没有 vector 高，在头部和尾部插入或删除效率高，但在中间插入或删除效率低。</p><p>&bull;  list 不支持随机访问，在任意位置的插入和删除效率都较高。</p><p>&bull;  set 由红黑树实现，其内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复，且插入和删除效率比用其他序列容器高。</p><p>&bull;  map 的元素为键值对，key 和 value 可以是任意你需要的类型，每个元素都有一个键，且只能出现一次，不允许重复，根据 key 快速查找记录。</p><p>在实际使用过程中，到底选择这几种容器中的哪一个，应该根据遵循以下原则:</p><p>1、如果需要高效的随机访问，不在乎插入和删除的效率，使用 vector。</p><p>2、如果需要随机访问，并且关心两端数据的插入和删除效率，使用 deque。</p><p>3、如果需要大量的插入和删除元素，不关心随机访问的效率，使用 list。</p><p>4、如果经常查找一个元素是否在某集合中且需要排序，唯一存在的情况使用 set，不唯一存在的情况使用 multiset。</p><p>5、如果打算存储数据字典，并且要求方便地根据 key 找到 value，一对一的情况使用 map，一对多的情况使用 multimap。</p><h3 id="各容器的时间复杂度分析"><a href="#各容器的时间复杂度分析" class="headerlink" title="各容器的时间复杂度分析"></a>各容器的时间复杂度分析</h3><p>&bull;  vector 在头部和中间位置插入和删除的时间复杂度为 O(N)，在尾部插入和删除的时间复杂度为 O(1)，随机访问的时间复杂度为 O(1)，查找的时间复杂度为 O(N)；</p><p>&bull;  deque 在中间位置插入和删除的时间复杂度为 O(N)，在头部和尾部插入和删除的时间复杂度为 O(1)，随机访问的时间复杂度为 O(1)，查找的时间复杂度为 O(N)；</p><p>&bull;  list 在任意位置插入和删除的时间复杂度都为 O(1)，查找的时间复杂度为 O(N)；</p><p>&bull;  set 和 map 都是通过红黑树实现，因此插入、删除和查找操作的时间复杂度都是 O(log N)。</p><h3 id="各容器的共性"><a href="#各容器的共性" class="headerlink" title="各容器的共性"></a>各容器的共性</h3><p>各容器一般来说都有下列函数:默认构造函数、复制构造函数、析构函数、empty()、max_size()、size()、operator=、operator&lt;、operator&lt;=、operator&gt;、operator&gt;=、operator==、operator!=、swap()。</p><p>顺序容器和关联容器都共有下列函数:</p><p><code>begin()</code>: 返回容器第一个元素的迭代器指针；</p><p><code>end()</code>: 返回容器最后一个元素后面一位的迭代器指针；</p><p><code>rbegin()</code>: 返回一个逆向迭代器指针，指向容器最后一个元素；</p><p><code>rend()</code>: 返回一个逆向迭代器指针，指向容器首个元素前面一位；</p><p><code>clear()</code>: 删除容器中的所有的元素；</p><p><code>erase(it)</code>: 删除迭代器指针it处元素。</p><h1 id="搬运源"><a href="#搬运源" class="headerlink" title="搬运源"></a>搬运源</h1><p>[1] <a href="https://www.cnblogs.com/linuxAndMcu/p/10254542.html">C++ STL 各容器简单介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> stl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ros topic</title>
      <link href="/2024/10/12/archived_ros_topic/"/>
      <url>/2024/10/12/archived_ros_topic/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#ros-topic概念">ROS Topic概念</a><ul><li><a href="#publisher">Publisher</a></li><li><a href="#subscriber">Subscriber</a></li><li><a href="#topic通信过程">Topic通信过程</a></li></ul></li><li><a href="#发布一个topic">发布一个topic</a></li><li><a href="#发布自定义数据">发布自定义数据</a><ul><li><a href="#定义自定义消息">定义自定义消息</a></li><li><a href="#修改-packagexml-和-cmakeliststxt">修改 package.xml 和 CMakeLists.txt</a></li><li><a href="#示例">示例</a></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="ROS-Topic概念"><a href="#ROS-Topic概念" class="headerlink" title="ROS Topic概念"></a>ROS Topic概念</h1><p>ROS Node之间进行通信所利用的最重要的机制就是消息传递，在ROS中，消息有组织的放到Topic里进行传递。</p><h2 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h2><p>&bull; 生成信息，通过ROS Topic与其它Node进行通信。</p><p>&bull; 通常用于处理原始的传感器信息，如相机、编码器等。</p><h2 id="Subscriber"><a href="#Subscriber" class="headerlink" title="Subscriber"></a>Subscriber</h2><p>&bull; 接收信息，通过ROS Topic接收来自其它Node的信息，并通过回调函数处理</p><p>&bull; 通常用于监测系统状态，如当机器人关节到达限位位置时触发运动中断</p><h2 id="Topic通信过程"><a href="#Topic通信过程" class="headerlink" title="Topic通信过程"></a>Topic通信过程</h2><p>1, Publisher节点和Subscriber节点分别在Master进行注册<br>2, Publisher发布Topic<br>3, Subscriber在Master指挥下订阅Topic，从而建立起Pub-Sub之间的通信</p><p><strong>注意：消息是直接从发布节点传递到订阅节点，并不经过Master。</strong></p><p>下图是ROS Node和ROS Topic概念的图形化表示，可以看到两个Node（圆形）通过Topic（长方形）实现通信。</p><p><img src="/img/postImg/1_ros/6_ros_topic/1_ROS_Node_Topic通信示意图.webp" alt=""></p><h1 id="发布一个topic"><a href="#发布一个topic" class="headerlink" title="发布一个topic"></a>发布一个topic</h1><p>发布一个 ROS topic 的步骤如下：</p><p>&bull; 确定消息类型：首先，需要知道要发布的消息类型。例如，使用标准消息类型 std_msgs/String。</p><p>&bull; 创建发布节点：需要一个 ROS 节点来发布消息。可以使用 Python 或 C++ 编写这个节点。</p><p>以下是 C++ 示例，创建一个发布节点并每秒发布一条字符串消息：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;talker&quot;</span>);</span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    ros::Publisher pub = n.<span class="built_in">advertise</span>&lt;std_msgs::<span class="type">String</span>&gt;(<span class="string">&quot;chatter&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">1</span>)</span></span>;  <span class="comment">// 1 Hz</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std_msgs::<span class="type">String</span> msg;</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;Hello, ROS! &quot;</span> &lt;&lt; ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        msg.data = ss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;%s&quot;</span>, msg.data.<span class="built_in">c_str</span>());  <span class="comment">// 打印消息到日志</span></span><br><span class="line">        pub.<span class="built_in">publish</span>(msg);  <span class="comment">// 发布消息</span></span><br><span class="line"></span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();  <span class="comment">// 处理回调</span></span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();  <span class="comment">// 按照设定频率休眠</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="发布自定义数据"><a href="#发布自定义数据" class="headerlink" title="发布自定义数据"></a>发布自定义数据</h1><p>如果想同时发布字符和数组，可以使用自定义消息类型或者使用现有的消息类型，比如 std_msgs/String 和 std_msgs/Float64MultiArray，并将它们封装在一个自定义消息中。</p><h2 id="定义自定义消息"><a href="#定义自定义消息" class="headerlink" title="定义自定义消息"></a>定义自定义消息</h2><p>在 ROS 包中创建一个 msg 文件夹，并定义一个新的消息类型，例如 CombinedMsg.msg，内容如下：</p><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="literal">text</span></span><br><span class="line">std_msgs/Float64MultiArray <span class="keyword">array</span></span><br></pre></td></tr></table></figure><h2 id="修改-package-xml-和-CMakeLists-txt"><a href="#修改-package-xml-和-CMakeLists-txt" class="headerlink" title="修改 package.xml 和 CMakeLists.txt"></a>修改 package.xml 和 CMakeLists.txt</h2><p>确保在 <code>package.xml</code> 中添加 <code>std_msgs</code> 的依赖，并在 <code>CMakeLists.txt</code> 中添加消息生成的相关配置。</p><p>在 CMakeLists.txt 中添加以下内容：</p><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span>(<span class="variable">catkin</span> <span class="variable">REQUIRED</span> <span class="variable">COMPONENTS</span></span></span><br><span class="line"><span class="function">  <span class="variable">roscpp</span></span></span><br><span class="line"><span class="function">  <span class="variable">std_msgs</span></span></span><br><span class="line"><span class="function">  <span class="variable">message_generation</span></span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">add_message_files</span>(</span></span><br><span class="line"><span class="function">  <span class="variable">FILES</span></span></span><br><span class="line"><span class="function">  <span class="variable">CombinedMsg.msg</span></span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">generate_messages</span>(</span></span><br><span class="line"><span class="function">  <span class="variable">DEPENDENCIES</span></span></span><br><span class="line"><span class="function">  <span class="variable">std_msgs</span></span></span><br><span class="line"><span class="function">)</span></span><br></pre></td></tr></table></figure><p>到工作空间后<code>catkin_make</code>编译一下包</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>发布包含字符和数组的自定义消息：</p><figure class="highlight stan"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &quot;<span class="string">ros</span>/<span class="string">ros.h</span>&quot;</span></span><br><span class="line"><span class="meta">#include &quot;<span class="string">your_package_name</span>/C<span class="string">ombined</span>M<span class="string">sg.h</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, char **argv) &#123;</span><br><span class="line">    ros::init(argc, argv, <span class="string">&quot;combined_talker&quot;</span>);</span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    ros::Publisher pub = n.advertise&lt;your_package_name::CombinedMsg&gt;(<span class="string">&quot;combined_topic&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    ros::Rate loop_rate(<span class="number">1</span>);  <span class="comment">// 1 Hz</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ros::ok()) &#123;</span><br><span class="line">        your_package_name::CombinedMsg combined_msg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充字符和数组数据</span></span><br><span class="line">        combined_msg.text = <span class="string">&quot;Hello, ROS!&quot;</span>;</span><br><span class="line">        combined_msg.<span class="type">array</span>.<span class="title">data</span> = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ROS_INFO(<span class="string">&quot;Text: %s&quot;</span>, combined_msg.text.c_str());</span><br><span class="line">        ROS_INFO(<span class="string">&quot;Array: %f %f %f %f %f&quot;</span>, combined_msg.<span class="type">array</span>.<span class="title">data</span>[<span class="number">0</span>], combined_msg.<span class="type">array</span>.<span class="title">data</span>[<span class="number">1</span>], combined_msg.<span class="type">array</span>.<span class="title">data</span>[<span class="number">2</span>], combined_msg.<span class="type">array</span>.<span class="title">data</span>[<span class="number">3</span>], combined_msg.<span class="type">array</span>.<span class="title">data</span>[<span class="number">4</span>]);</span><br><span class="line">        pub.publish(combined_msg);  <span class="comment">// 发布消息</span></span><br><span class="line"></span><br><span class="line">        ros::spinOnce();  <span class="comment">// 处理回调</span></span><br><span class="line">        loop_rate.sleep();  <span class="comment">// 按照设定频率休眠</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行发布节点：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rosrun your_package_name your_executable_name</span></span><br></pre></td></tr></table></figure><p>可以使用 <code>rostopic echo /combined_topic</code> 来查看发布的字符和数组数据。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://tr-ros-tutorial.readthedocs.io/zh-cn/latest/_source/basics/1.4_ROS_Topic.html">ROS Topic</a><br>[2] chatGPT</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KDL 基本数据结构与设计思想</title>
      <link href="/2024/08/16/archived_KDL%E7%9B%B8%E5%85%B3/"/>
      <url>/2024/08/16/archived_KDL%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#基本数据结构及解释">基本数据结构及解释</a><ul><li><a href="#kdlvector">KDL::Vector</a></li><li><a href="#kdlrotation">KDL::Rotation</a></li><li><a href="#kdlframe">KDL::Frame</a></li><li><a href="#kdltwist">KDL::Twist</a></li><li><a href="#kdlwrench">KDL::Wrench</a></li></ul></li><li><a href="#运动学类">运动学类</a><ul><li><a href="#kdlchain">KDL::Chain</a></li><li><a href="#kdlchainfksolveracc">KDL::ChainFkSolverAcc</a></li><li><a href="#kdlchainfksolverpos">KDL::ChainFkSolverPos</a></li><li><a href="#kdlchainfksolverpos_recursive">KDL::ChainFkSolverPos_recursive</a></li><li><a href="#kdlchainfksolvervel">KDL::ChainFkSolverVel</a></li><li><a href="#kdlchainfksolvervel_recursive">KDL::ChainFkSolverVel_recursive</a></li><li><a href="#kdlchainiksolveracc">KDL::ChainIkSolverAcc</a></li><li><a href="#kdlchainiksolverpos">KDL::ChainIkSolverPos</a></li><li><a href="#kdlchainiksolverpos_lma">KDL::ChainIkSolverPos_LMA</a></li><li><a href="#kdlchainiksolverpos_nr">KDL::ChainIkSolverPos_NR</a></li><li><a href="#kdlchainiksolverpos_nr_jl">KDL::ChainIkSolverPos_NR_JL</a></li><li><a href="#kdlchainiksolvervel">KDL::ChainIkSolverVel</a></li><li><a href="#kdlchainiksolvervel_pinv">KDL::ChainIkSolverVel_pinv</a></li><li><a href="#kdlchainiksolvervel_pinv_givens">KDL::ChainIkSolverVel_pinv_givens</a></li><li><a href="#kdlchainiksolvervel_pinv_nso">KDL::ChainIkSolverVel_pinv_nso</a></li><li><a href="#kdlchainiksolvervel_wdls">KDL::ChainIkSolverVel_wdls</a></li><li><a href="#kdljoint">KDL::Joint</a></li><li><a href="#kdlsegment">KDL::Segment</a></li><li><a href="#kdltree">KDL::Tree</a></li><li><a href="#kdltreefksolverpos">KDL::TreeFkSolverPos</a></li><li><a href="#kdltreefksolverpos_recursive">KDL::TreeFkSolverPos_recursive</a></li><li><a href="#kdltreeiksolverpos">KDL::TreeIkSolverPos</a></li><li><a href="#kdltreeiksolverpos_nr_jl">KDL::TreeIkSolverPos_NR_JL</a></li><li><a href="#kdltreeiksolverpos_online">KDL::TreeIkSolverPos_Online</a></li><li><a href="#kdltreeiksolvervel">KDL::TreeIkSolverVel</a></li></ul></li><li><a href="#轨迹规划类">轨迹规划类</a><ul><li><a href="#kdlpath_circle">KDL::Path_Circle</a></li><li><a href="#kdlpath_composite">KDL::Path_Composite</a></li><li><a href="#kdlpath_cyclic_closed">KDL::Path_Cyclic_Closed</a></li><li><a href="#kdlpath_line">KDL::Path_Line</a></li><li><a href="#kdlpath_point">KDL::Path_Point</a></li><li><a href="#kdlpath_roundedcomposite">KDL::Path_RoundedComposite</a></li><li><a href="#kdlrotationalinterpolation_singleaxis">KDL::RotationalInterpolation_SingleAxis</a></li><li><a href="#kdltrajectory">KDL::Trajectory</a></li><li><a href="#kdltrajectory_composite">KDL::Trajectory_Composite</a></li><li><a href="#kdltrajectory_segment">KDL::Trajectory_Segment</a></li><li><a href="#kdltrajectory_stationary">KDL::Trajectory_Stationary</a></li><li><a href="#kdlvelocityprofile_dirac">KDL::VelocityProfile_Dirac</a></li><li><a href="#kdlvelocityprofile_rectangular">KDL::VelocityProfile_Rectangular</a></li><li><a href="#kdlvelocityprofile_spline">KDL::VelocityProfile_Spline</a></li><li><a href="#kdlvelocityprofile_trap">KDL::VelocityProfile_Trap</a></li><li><a href="#kdlvelocityprofile_traphalf">KDL::VelocityProfile_TrapHalf</a></li></ul></li><li><a href="#kdl中的oop思想">KDL中的OOP思想</a></li><li><a href="#参考--出处">参考 &amp; 出处</a></li></ul><!-- vim-markdown-toc --><h1 id="基本数据结构及解释"><a href="#基本数据结构及解释" class="headerlink" title="基本数据结构及解释"></a>基本数据结构及解释</h1><h2 id="KDL-Vector"><a href="#KDL-Vector" class="headerlink" title="KDL::Vector"></a>KDL::Vector</h2><p>表示一个三维的向量，可以用来表示空间中的一个点或一个方向。它有三个分量，分别是 x，y 和 z，可以用下标或括号访问。它提供了一些常用的操作，如加法，减法，数乘，点乘，叉乘，取模，归一化，旋转等。它还可以和 KDL::Rotation，KDL::Frame，KDL::Twist，KDL::Wrench 等类进行转换或运算。</p><h2 id="KDL-Rotation"><a href="#KDL-Rotation" class="headerlink" title="KDL::Rotation"></a>KDL::Rotation</h2><p>表示一个三维的旋转，可以用来表示空间中的一个坐标系或一个姿态。它是一个 3x3 的矩阵，每一列对应一个坐标轴的方向。它提供了一些常用的操作，如乘法，逆，转置，求迹，求行列式，求特征值，求特征向量等。它还提供了一些常用的构造方法，如从欧拉角，四元数，轴角，RPY 角等创建旋转，或者从两个向量之间的旋转，或者从三个向量之间的旋转创建旋转。它还可以和 KDL::Vector，KDL::Frame，KDL::Twist，KDL::Wrench 等类进行转换或运算。</p><h2 id="KDL-Frame"><a href="#KDL-Frame" class="headerlink" title="KDL::Frame"></a>KDL::Frame</h2><p>表示一个三维的坐标系，可以用来表示空间中的一个物体或一个参考系。它由一个 KDL::Rotation 和一个 KDL::Vector 组成，分别表示坐标系的旋转和平移。它提供了一些常用的操作，如乘法，逆，求逆运动，求相对运动，求相对速度，求相对加速度等。它还可以和 KDL::Vector，KDL::Rotation，KDL::Twist，KDL::Wrench 等类进行转换或运算。</p><h2 id="KDL-Twist"><a href="#KDL-Twist" class="headerlink" title="KDL::Twist"></a>KDL::Twist</h2><p>表示一个三维的扭转，可以用来表示空间中的一个刚体的速度或加速度。它由一个 KDL::Vector 和一个 KDL::Vector 组成，分别表示刚体的线速度和角速度。它提供了一些常用的操作，如加法，减法，数乘，点乘，叉乘，取反，取模，归一化，旋转等。它还可以和 KDL::Vector，KDL::Rotation，KDL::Frame，KDL::Wrench 等类进行转换或运算。</p><h2 id="KDL-Wrench"><a href="#KDL-Wrench" class="headerlink" title="KDL::Wrench"></a>KDL::Wrench</h2><p>表示一个三维的力矩，可以用来表示空间中的一个刚体的力或力矩。它由一个 KDL::Vector 和一个 KDL::Vector 组成，分别表示刚体的力和力矩。它提供了一些常用的操作，如加法，减法，数乘，点乘，叉乘，取反，取模，归一化，旋转等。它还可以和 KDL::Vector，KDL::Rotation，KDL::Frame，KDL::Twist 等类进行转换或运算。</p><h1 id="运动学类"><a href="#运动学类" class="headerlink" title="运动学类"></a>运动学类</h1><h2 id="KDL-Chain"><a href="#KDL-Chain" class="headerlink" title="KDL::Chain"></a>KDL::Chain</h2><p>封装了一个串联的运动学连接结构，由多个段组成。每个段包含一个关节和一个偏移坐标系，表示前一个段的关节和当前段的关节之间的几何姿态。这个类可以用来表示机器人的运动学模型，如机械臂，机器人腿等。</p><h2 id="KDL-ChainFkSolverAcc"><a href="#KDL-ChainFkSolverAcc" class="headerlink" title="KDL::ChainFkSolverAcc"></a>KDL::ChainFkSolverAcc</h2><p>正向加速度运动学求解器，可以计算 KDL::Chain 的末端执行器的加速度，给定关节的位置，速度和加速度。这个类是一个抽象类，需要由具体的子类实现具体的求解算法。</p><h2 id="KDL-ChainFkSolverPos"><a href="#KDL-ChainFkSolverPos" class="headerlink" title="KDL::ChainFkSolverPos"></a>KDL::ChainFkSolverPos</h2><p>正向位置运动学求解器，可以计算 KDL::Chain 的末端执行器的位置，给定关节的位置。这个类是一个抽象类，需要由具体的子类实现具体的求解算法。</p><h2 id="KDL-ChainFkSolverPos-recursive"><a href="#KDL-ChainFkSolverPos-recursive" class="headerlink" title="KDL::ChainFkSolverPos_recursive"></a>KDL::ChainFkSolverPos_recursive</h2><p>另一个版本的正向位置运动学求解器，使用递归算法，从根坐标系开始，依次乘以每个段的偏移坐标系和关节变换，得到末端执行器的位置。</p><h2 id="KDL-ChainFkSolverVel"><a href="#KDL-ChainFkSolverVel" class="headerlink" title="KDL::ChainFkSolverVel"></a>KDL::ChainFkSolverVel</h2><p>正向速度运动学求解器，可以计算 KDL::Chain 的末端执行器的速度，给定关节的位置和速度。这个类是一个抽象类，需要由具体的子类实现具体的求解算法。</p><h2 id="KDL-ChainFkSolverVel-recursive"><a href="#KDL-ChainFkSolverVel-recursive" class="headerlink" title="KDL::ChainFkSolverVel_recursive"></a>KDL::ChainFkSolverVel_recursive</h2><p>另一个版本的正向速度运动学求解器，使用递归算法，从根坐标系开始，依次乘以每个段的偏移坐标系和关节变换，以及每个段的刚体速度，得到末端执行器的速度。</p><h2 id="KDL-ChainIkSolverAcc"><a href="#KDL-ChainIkSolverAcc" class="headerlink" title="KDL::ChainIkSolverAcc"></a>KDL::ChainIkSolverAcc</h2><p>逆向加速度运动学求解器，可以计算 KDL::Chain 的关节加速度，给定末端执行器的加速度，关节的位置和速度。这个类是一个抽象类，需要由具体的子类实现具体的求解算法。</p><h2 id="KDL-ChainIkSolverPos"><a href="#KDL-ChainIkSolverPos" class="headerlink" title="KDL::ChainIkSolverPos"></a>KDL::ChainIkSolverPos</h2><p>逆向位置运动学求解器，可以计算 KDL::Chain 的关节位置，给定末端执行器的位置。这个类是一个抽象类，需要由具体的子类实现具体的求解算法。</p><h2 id="KDL-ChainIkSolverPos-LMA"><a href="#KDL-ChainIkSolverPos-LMA" class="headerlink" title="KDL::ChainIkSolverPos_LMA"></a>KDL::ChainIkSolverPos_LMA</h2><p>使用 Levenberg-Marquardt 方法的逆向位置运动学求解器，可以求解 KDL::Chain 的关节位置，给定末端执行器的位置。这个方法是一种迭代的数值优化方法，可以处理非线性的问题，也可以考虑关节的限制。</p><h2 id="KDL-ChainIkSolverPos-NR"><a href="#KDL-ChainIkSolverPos-NR" class="headerlink" title="KDL::ChainIkSolverPos_NR"></a>KDL::ChainIkSolverPos_NR</h2><p>使用牛顿-拉夫逊方法的逆向位置运动学求解器，可以求解 KDL::Chain 的关节位置，给定末端执行器的位置。这个方法是一种迭代的数值优化方法，可以处理非线性的问题，但不能考虑关节的限制。</p><h2 id="KDL-ChainIkSolverPos-NR-JL"><a href="#KDL-ChainIkSolverPos-NR-JL" class="headerlink" title="KDL::ChainIkSolverPos_NR_JL"></a>KDL::ChainIkSolverPos_NR_JL</h2><p>使用牛顿-拉夫逊方法，并考虑关节限制的逆向位置运动学求解器，可以求解 KDL::Chain 的关节位置，给定末端执行器的位置。这个方法在每次迭代时，检查关节是否超出限制，如果超出，就将其设置为最大或最小值，然后继续迭代。</p><h2 id="KDL-ChainIkSolverVel"><a href="#KDL-ChainIkSolverVel" class="headerlink" title="KDL::ChainIkSolverVel"></a>KDL::ChainIkSolverVel</h2><p>逆向速度运动学求解器，可以计算 KDL::Chain 的关节速度，给定末端执行器的速度，关节的位置。这个类是一个抽象类，需要由具体的子类实现具体的求解算法。</p><h2 id="KDL-ChainIkSolverVel-pinv"><a href="#KDL-ChainIkSolverVel-pinv" class="headerlink" title="KDL::ChainIkSolverVel_pinv"></a>KDL::ChainIkSolverVel_pinv</h2><p>使用伪逆方法的逆向速度运动学求解器，可以计算 KDL::Chain 的关节速度，给定末端执行器的速度，关节的位置。这个方法是一种线性的最小二乘法，可以处理冗余或欠驱动的情况，但不能考虑关节的限制。</p><h2 id="KDL-ChainIkSolverVel-pinv-givens"><a href="#KDL-ChainIkSolverVel-pinv-givens" class="headerlink" title="KDL::ChainIkSolverVel_pinv_givens"></a>KDL::ChainIkSolverVel_pinv_givens</h2><p>使用伪逆和 Givens 旋转的逆向速度运动学求解器，可以计算 KDL::Chain 的关节速度，给定末端执行器的速度，关节的位置。这个方法是一种线性的最小二乘法，使用 Givens 旋转来加速计算，可以处理冗余或欠驱动的情况，但不能考虑关节的限制。</p><h2 id="KDL-ChainIkSolverVel-pinv-nso"><a href="#KDL-ChainIkSolverVel-pinv-nso" class="headerlink" title="KDL::ChainIkSolverVel_pinv_nso"></a>KDL::ChainIkSolverVel_pinv_nso</h2><p>使用伪逆和空间优化的逆向速度运动学求解器，可以计算 KDL::Chain 的关节速度，给定末端执行器的速度，关节的位置。这个方法是一种线性的最小二乘法，使用空间优化来减少关节的运动范围，可以处理冗余或欠驱动的情况，但不能考虑关节的限制。</p><h2 id="KDL-ChainIkSolverVel-wdls"><a href="#KDL-ChainIkSolverVel-wdls" class="headerlink" title="KDL::ChainIkSolverVel_wdls"></a>KDL::ChainIkSolverVel_wdls</h2><p>使用加权的最小二乘法的逆向速度运动学求解器，可以计算 KDL::Chain 的关节速度，给定末端执行器的速度，关节的位置。这个方法是一种非线性的最小二乘法，使用加权矩阵来平衡关节的运动和末端执行器的误差，可以处理冗余或欠驱动的情况，也可以考虑关节的限制。</p><h2 id="KDL-Joint"><a href="#KDL-Joint" class="headerlink" title="KDL::Joint"></a>KDL::Joint</h2><p>表示一个简单的关节，有一个参数化的自由度和一个标量的动力学属性。关节的类型可以是旋转，平移，固定或无效。关节的变换可以由关节的位置和类型决定。</p><h2 id="KDL-Segment"><a href="#KDL-Segment" class="headerlink" title="KDL::Segment"></a>KDL::Segment</h2><p>表示一个简单的段，是一个“刚体”（即一个坐标系和一个刚体惯性），包含一个关节和一些“手柄”，根和尖，用来连接其他的段。段的刚体速度可以由关节的速度和类型决定。</p><h2 id="KDL-Tree"><a href="#KDL-Tree" class="headerlink" title="KDL::Tree"></a>KDL::Tree</h2><p>封装了一个树形的运动学连接结构，由多个段组成。每个段有一个唯一的名字，可以连接到其他段的根或尖。这个类可以用来表示机器人的运动学模型，如人形机器人，多足机器人等。</p><h2 id="KDL-TreeFkSolverPos"><a href="#KDL-TreeFkSolverPos" class="headerlink" title="KDL::TreeFkSolverPos"></a>KDL::TreeFkSolverPos</h2><p>正向位置运动学求解器，可以计算 KDL::Tree 的任意末端执行器的位置，给定关节的位置。这个类是一个抽象类，需要由具体的子类实现具体的求解算法。</p><h2 id="KDL-TreeFkSolverPos-recursive"><a href="#KDL-TreeFkSolverPos-recursive" class="headerlink" title="KDL::TreeFkSolverPos_recursive"></a>KDL::TreeFkSolverPos_recursive</h2><p>另一个版本的正向位置运动学求解器，使用递归算法，从根坐标系开始，依次乘以每个段的偏移坐标系和关节变换，得到任意末端执行器的位置。</p><h2 id="KDL-TreeIkSolverPos"><a href="#KDL-TreeIkSolverPos" class="headerlink" title="KDL::TreeIkSolverPos"></a>KDL::TreeIkSolverPos</h2><p>逆向位置运动学求解器，可以计算 KDL::Tree 的关节位置，给定任意末端执行器的位置。这个类是一个抽象类，需要由具体的子类实现具体的求解算法。</p><h2 id="KDL-TreeIkSolverPos-NR-JL"><a href="#KDL-TreeIkSolverPos-NR-JL" class="headerlink" title="KDL::TreeIkSolverPos_NR_JL"></a>KDL::TreeIkSolverPos_NR_JL</h2><p>使用牛顿-拉夫逊方法，并考虑关节限制的逆向位置运动学求解器，可以求解 KDL::Tree 的关节位置，给定任意末端执行器的位置。这个方法在每次迭代时，检查关节是否超出限制，如果超出，就将其设置为最大或最小值，然后继续迭代。</p><h2 id="KDL-TreeIkSolverPos-Online"><a href="#KDL-TreeIkSolverPos-Online" class="headerlink" title="KDL::TreeIkSolverPos_Online"></a>KDL::TreeIkSolverPos_Online</h2><p>使用在线的逆向位置运动学求解器，可以求解 KDL::Tree 的关节位置，给定任意末端执行器的位置。这个方法不需要预先构建整个运动学树，而是根据需要动态地添加或删除段，可以适应运动学结构的变化。</p><h2 id="KDL-TreeIkSolverVel"><a href="#KDL-TreeIkSolverVel" class="headerlink" title="KDL::TreeIkSolverVel"></a>KDL::TreeIkSolverVel</h2><p>逆向速度运动学求解器，可以计算 KDL::Tree 的关节速度，给定任意末端执行器的速度，关节的位置。这个类是一个抽象类，需要由具体的子类实现具体的求解算法。</p><h1 id="轨迹规划类"><a href="#轨迹规划类" class="headerlink" title="轨迹规划类"></a>轨迹规划类</h1><h2 id="KDL-Path-Circle"><a href="#KDL-Path-Circle" class="headerlink" title="KDL::Path_Circle"></a>KDL::Path_Circle</h2><p>处理圆形的路径，可以指定圆心，半径，起始角度，终止角度和旋转方向。</p><h2 id="KDL-Path-Composite"><a href="#KDL-Path-Composite" class="headerlink" title="KDL::Path_Composite"></a>KDL::Path_Composite</h2><p>管理复合的路径，可以将不同类型的路径组合在一起，如直线，圆弧，点等。</p><h2 id="KDL-Path-Cyclic-Closed"><a href="#KDL-Path-Cyclic-Closed" class="headerlink" title="KDL::Path_Cyclic_Closed"></a>KDL::Path_Cyclic_Closed</h2><p>处理闭合的循环路径，可以指定一个路径列表，使得最后一个路径的终点和第一个路径的起点重合。</p><h2 id="KDL-Path-Line"><a href="#KDL-Path-Line" class="headerlink" title="KDL::Path_Line"></a>KDL::Path_Line</h2><p>处理线性的路径，可以指定起点，终点和插值方法。</p><h2 id="KDL-Path-Point"><a href="#KDL-Path-Point" class="headerlink" title="KDL::Path_Point"></a>KDL::Path_Point</h2><p>管理点到点的路径，可以指定一个点的列表，按顺序连接。</p><h2 id="KDL-Path-RoundedComposite"><a href="#KDL-Path-RoundedComposite" class="headerlink" title="KDL::Path_RoundedComposite"></a>KDL::Path_RoundedComposite</h2><p>可能处理具有圆角或圆边的复合路径，可以指定一个路径列表和一个圆角半径。</p><h2 id="KDL-RotationalInterpolation-SingleAxis"><a href="#KDL-RotationalInterpolation-SingleAxis" class="headerlink" title="KDL::RotationalInterpolation_SingleAxis"></a>KDL::RotationalInterpolation_SingleAxis</h2><p>沿着单个轴插值旋转，可以指定旋转轴和旋转角度。</p><h2 id="KDL-Trajectory"><a href="#KDL-Trajectory" class="headerlink" title="KDL::Trajectory"></a>KDL::Trajectory</h2><p>不同类型轨迹的基类，可以指定一个路径和一个速度曲线。</p><h2 id="KDL-Trajectory-Composite"><a href="#KDL-Trajectory-Composite" class="headerlink" title="KDL::Trajectory_Composite"></a>KDL::Trajectory_Composite</h2><p>管理复合的轨迹，可以将不同的轨迹段或类型组合在一起。</p><h2 id="KDL-Trajectory-Segment"><a href="#KDL-Trajectory-Segment" class="headerlink" title="KDL::Trajectory_Segment"></a>KDL::Trajectory_Segment</h2><p>处理单个的轨迹段，可以指定一个轨迹和一个起始时间。</p><h2 id="KDL-Trajectory-Stationary"><a href="#KDL-Trajectory-Stationary" class="headerlink" title="KDL::Trajectory_Stationary"></a>KDL::Trajectory_Stationary</h2><p>可能表示静止或不动的轨迹，没有任何运动。</p><h2 id="KDL-VelocityProfile-Dirac"><a href="#KDL-VelocityProfile-Dirac" class="headerlink" title="KDL::VelocityProfile_Dirac"></a>KDL::VelocityProfile_Dirac</h2><p>表示瞬时或未定义的速度曲线，类似于 Dirac delta 函数的行为，可以指定一个峰值速度。</p><h2 id="KDL-VelocityProfile-Rectangular"><a href="#KDL-VelocityProfile-Rectangular" class="headerlink" title="KDL::VelocityProfile_Rectangular"></a>KDL::VelocityProfile_Rectangular</h2><p>表示一个矩形的速度曲线，即速度在一段时间内保持恒定，然后突然变为零。可以指定一个最大速度和一个总时间。</p><h2 id="KDL-VelocityProfile-Spline"><a href="#KDL-VelocityProfile-Spline" class="headerlink" title="KDL::VelocityProfile_Spline"></a>KDL::VelocityProfile_Spline</h2><p>表示一个样条的速度曲线，即速度由一系列的三次多项式拼接而成，保证连续性和光滑性。可以指定一个速度点的列表，以及每个点的时间。</p><h2 id="KDL-VelocityProfile-Trap"><a href="#KDL-VelocityProfile-Trap" class="headerlink" title="KDL::VelocityProfile_Trap"></a>KDL::VelocityProfile_Trap</h2><p>表示一个梯形的速度曲线，即速度先以恒定的加速度增加，然后保持最大速度一段时间，再以恒定的减速度减小。可以指定一个最大速度，一个最大加速度和一个总距离。</p><h2 id="KDL-VelocityProfile-TrapHalf"><a href="#KDL-VelocityProfile-TrapHalf" class="headerlink" title="KDL::VelocityProfile_TrapHalf"></a>KDL::VelocityProfile_TrapHalf</h2><p>表示一个半梯形的速度曲线，即速度只有加速或减速的阶段，没有匀速的阶段。可以指定一个最大速度，一个最大加速度和一个总距离。</p><h1 id="KDL中的OOP思想"><a href="#KDL中的OOP思想" class="headerlink" title="KDL中的OOP思想"></a>KDL中的OOP思想</h1><p>C++语言的一个重要特征是可以进行面向对象的设计（OOP），而OOP的核心思想之一便是使用继承，可以定义相似的类型并对其相似关系进行建模。通过继承联系在一起的类构成一种层次关系，层次关系的根部有一个基类（base class），其它类则直接或间接地从基类继承而来，这些继承得到的类称为派生类（derived class）。</p><p>机器人轨迹规划算法中，一个很重要的问题是路径的计算，但是机器人的路径有多种，包含直线路径，圆弧路径，复合路径等等。所以在KDL中就定义了一个基类: 路径（class path），和其它6个派生类: 开口圆路径（Path_Circle）、组合路径（Path_Composite）、封闭圆路径（Path_Cyclic_Closed）、直线路径（Path_Line）、仅含点的路径（Path_Point）、含圆弧过渡的路径（Path_RoundedComposite）。</p><p>需注意一下基类（path）中的虚函数（virtual）很多是纯虚函数，这些是派生类中必须给出自己的定义，例如Path_Line中相应的虚函数，可看出每种路径的都需要定义并重新定义:LengthToS，PathLength，Pos，Vel，Acc，Write。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Path</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">LengthToS</span><span class="params">(<span class="type">double</span> length)</span>  </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">PathLength</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Frame <span class="title">Pos</span><span class="params">(<span class="type">double</span> s)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Twist <span class="title">Vel</span><span class="params">(<span class="type">double</span> s,<span class="type">double</span> sd)</span> <span class="type">const</span>  </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Twist <span class="title">Acc</span><span class="params">(<span class="type">double</span> s,<span class="type">double</span> sd,<span class="type">double</span> sdd)</span> <span class="type">const</span>  </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(std::ostream&amp; os)</span>  </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> Path* <span class="title">Read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Path* <span class="title">Clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> IdentifierType <span class="title">getIdentifier</span><span class="params">()</span> <span class="type">const</span></span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Path</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Path_Line</span> : <span class="keyword">public</span> Path</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Path_Line</span>(<span class="type">const</span> Frame&amp; F_base_start,<span class="type">const</span> Frame&amp; F_base_end,RotationalInterpolation* orient,<span class="type">double</span> eqradius,<span class="type">bool</span> _aggregate=<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">Path_Line</span>(<span class="type">const</span> Frame&amp; F_base_start,<span class="type">const</span> Twist&amp; twist_in_base,RotationalInterpolation* orient,<span class="type">double</span> eqradius,<span class="type">bool</span> _aggregate=<span class="literal">true</span>);</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">LengthToS</span><span class="params">(<span class="type">double</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">PathLength</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Frame <span class="title">Pos</span><span class="params">(<span class="type">double</span> s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Twist <span class="title">Vel</span><span class="params">(<span class="type">double</span> s,<span class="type">double</span> sd)</span> <span class="type">const</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Twist <span class="title">Acc</span><span class="params">(<span class="type">double</span> s,<span class="type">double</span> sd,<span class="type">double</span> sdd)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(std::ostream&amp; os)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Path* <span class="title">Clone</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> IdentifierType <span class="title">getIdentifier</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> ID_LINE;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Path_Line</span>();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考-amp-出处"><a href="#参考-amp-出处" class="headerlink" title="参考 &amp; 出处"></a>参考 &amp; 出处</h1><p>[1] <a href="https://blog.csdn.net/gpeng832/article/details/114504578">机器人开源项目KDL源码学习:（10）KDL中的OOP思想—-继承</a></p><p>[2] <a href="https://blog.csdn.net/cxyhjl/article/details/136575764">KDL API 使用参考</a> </p>]]></content>
      
      
      <categories>
          
          <category> robotics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ros2 </tag>
            
            <tag> KDL </tag>
            
            <tag> robot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类成员变量为类的带参构造函数</title>
      <link href="/2024/08/15/archived_cpp_C++%E7%B1%BB%E6%88%90%E5%91%98%E4%B8%BA%E5%B8%A6%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2024/08/15/archived_cpp_C++%E7%B1%BB%E6%88%90%E5%91%98%E4%B8%BA%E5%B8%A6%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>此结果为chatGPT回答，且通过了自己的验证，故此记录一下；</p><p><code>如何用c++中在一个类中定义另一个只有带参数构造函数的类的对象</code>?</p><p>在C++中，如果你在一个类中定义了另一个只有带参数的构造函数的类的对象，你需要在外层类的构造函数的初始化列表中对该对象进行初始化。这样可以确保在创建外层类的对象时，内部类的对象也能够正确初始化。</p><p>假设我们有两个类，<code>InnerClass</code> 和 <code>OuterClass</code>，其中 <code>InnerClass</code> 只有一个带参数的构造函数。以下是一个示例代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="built_in">InnerClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;InnerClass initialized with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    InnerClass innerObject;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外层类的构造函数，使用初始化列表初始化innerObject</span></span><br><span class="line">    <span class="built_in">OuterClass</span>(<span class="type">int</span> v) : <span class="built_in">innerObject</span>(v) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OuterClass initialized&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建OuterClass对象时，同时初始化InnerClass对象</span></span><br><span class="line">    <span class="function">OuterClass <span class="title">outer</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><code>InnerClass</code> 只有一个带参数的构造函数 <code>InnerClass(int v)</code>。</li><li><code>OuterClass</code> 定义了一个 <code>InnerClass</code> 类型的成员变量 <code>innerObject</code>。</li><li><code>OuterClass</code> 的构造函数使用初始化列表来初始化 <code>innerObject</code>，将参数 <code>v</code> 传递给 <code>InnerClass</code> 的构造函数。</li></ul><p>输出结果将是：</p><figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">Inner<span class="keyword">Class</span> <span class="title class_">initialized</span> with value: <span class="number">42</span></span><br><span class="line">Outer<span class="keyword">Class</span> <span class="title class_">initialized</span></span><br></pre></td></tr></table></figure><p>这种方法确保了当 <code>OuterClass</code> 对象被创建时，<code>InnerClass</code> 对象也会被正确初始化。</p><p>问： 如果我早已确定好了innerClass里面带参构造的值了，而不需要在main函数里提前声明，我应该怎么做</p><p>回答结果如下：</p><p>如果你在编写程序时已经确定了 <code>InnerClass</code> 的构造函数参数值，而不需要在 <code>main</code> 函数或外层类的构造函数中传递该值，可以直接在外层类的初始化列表中硬编码这个值。这样，在创建 <code>OuterClass</code> 对象时，<code>InnerClass</code> 的对象会使用你指定的固定值进行初始化。</p><p>以下是如何实现的示例代码：</p><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="regexp">//</span> 带参数的构造函数</span><br><span class="line">    InnerClass(<span class="keyword">int</span> v) : value(v) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;InnerClass initialized with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">public:</span><br><span class="line">    InnerClass innerObject;</span><br><span class="line">    </span><br><span class="line">    <span class="regexp">//</span> 外层类的构造函数，使用固定值初始化innerObject</span><br><span class="line">    OuterClass() : innerObject(<span class="number">100</span>) &#123; <span class="regexp">//</span> 这里使用了固定值<span class="number">100</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OuterClass initialized&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    <span class="regexp">//</span> 创建OuterClass对象时，InnerClass对象将被初始化为固定值<span class="number">100</span></span><br><span class="line">    OuterClass outer;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中：</p><p>&bull; <code>InnerClass</code> 的构造函数依旧接受一个参数。</p><p>&bull; <code>OuterClass</code> 的构造函数在初始化列表中硬编码了一个值 <code>100</code>，用来初始化 <code>innerObject</code>。</p><p>&bull; <code>main</code> 函数创建 <code>OuterClass</code> 对象时，不需要传递任何参数，<code>InnerClass</code> 的对象会自动使用固定值 <code>100</code> 进行初始化。</p><p>输出结果将是：</p><figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">Inner<span class="keyword">Class</span> <span class="title class_">initialized</span> with value: <span class="number">100</span></span><br><span class="line">Outer<span class="keyword">Class</span> <span class="title class_">initialized</span></span><br></pre></td></tr></table></figure><p>这样，你就不需要在 <code>main</code> 函数中显式地传递参数值，而是在类的内部确定 <code>InnerClass</code> 的初始化值。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb 调试</title>
      <link href="/2024/08/13/archived_gdb%E8%B0%83%E8%AF%95/"/>
      <url>/2024/08/13/archived_gdb%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#编译时启用调试信息">编译时启用调试信息</a></li><li><a href="#使用断点breakpoints">使用断点（Breakpoints）</a></li><li><a href="#运行和继续执行程序">运行和继续执行程序</a></li><li><a href="#检查变量值和内存">检查变量值和内存</a></li><li><a href="#逐行调试">逐行调试</a></li><li><a href="#查看调用栈">查看调用栈</a></li><li><a href="#导航调用栈">导航调用栈</a></li><li><a href="#修改变量值">修改变量值</a></li><li><a href="#使用-watchpoints">使用 Watchpoints</a></li><li><a href="#记录与回放reverse-debugging">记录与回放（Reverse Debugging）</a></li><li><a href="#自动化脚本gdb-脚本">自动化脚本（GDB 脚本）</a></li><li><a href="#使用-tui-模式">使用 TUI 模式</a></li><li><a href="#记录调试日志">记录调试日志</a></li><li><a href="#使用-gdb-gui-前端">使用 GDB GUI 前端</a></li><li><a href="#gdb-与-valgrind-联合使用">GDB 与 Valgrind 联合使用</a></li></ul><!-- vim-markdown-toc --><p>使用 GDB（GNU 调试器）来调试 C/C++ 程序时，有许多有效的方法和技巧可以帮助你快速定位问题。以下是一些有助于提高 GDB 调试效率的方法和技巧(chatGPT回答)：</p><h3 id="编译时启用调试信息"><a href="#编译时启用调试信息" class="headerlink" title="编译时启用调试信息"></a>编译时启用调试信息</h3><p>在编译程序时，使用 <code>-g</code> 选项来启用调试信息，这样 GDB 可以获得源代码级别的信息：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">g</span>++ -<span class="selector-tag">g</span> -o my_program my_program<span class="selector-class">.cpp</span></span><br></pre></td></tr></table></figure><h3 id="使用断点（Breakpoints）"><a href="#使用断点（Breakpoints）" class="headerlink" title="使用断点（Breakpoints）"></a>使用断点（Breakpoints）</h3><p>断点是调试中最基本但也是最有力的工具。通过设置断点，你可以在程序执行到特定位置时暂停。</p><ul><li><p>设置断点：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="keyword">break</span> main  <span class="comment"># 在 main 函数入口设置断点</span></span><br><span class="line">(gdb) <span class="keyword">break</span> <span class="title class_">MyClass</span><span class="symbol">:</span><span class="symbol">:myFunction</span>  <span class="comment"># 在特定类的方法上设置断点</span></span><br><span class="line">(gdb) <span class="keyword">break</span> my_program.<span class="symbol">cpp:</span><span class="number">25</span>  <span class="comment"># 在指定文件的第 25 行设置断点</span></span><br></pre></td></tr></table></figure></li><li><p>条件断点：可以在某个条件为真时才触发断点，有助于避免不必要的暂停。</p><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="keyword">break</span> my_function <span class="keyword">if</span> <span class="variable language_">x</span> &gt; <span class="number">5</span>  # 当变量 <span class="variable language_">x</span> 大于 <span class="number">5</span> 时触发断点</span><br></pre></td></tr></table></figure></li></ul><h3 id="运行和继续执行程序"><a href="#运行和继续执行程序" class="headerlink" title="运行和继续执行程序"></a>运行和继续执行程序</h3><ul><li><p>启动程序：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">run</span></span><br></pre></td></tr></table></figure></li><li><p>继续执行到下一个断点：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="keyword">continue</span>  <span class="comment"># 或简写为 (gdb) c</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="检查变量值和内存"><a href="#检查变量值和内存" class="headerlink" title="检查变量值和内存"></a>检查变量值和内存</h3><ul><li><p>打印变量值：</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">print</span> my_object-&gt;member_variable  <span class="comment"># 打印对象成员变量的值</span></span><br></pre></td></tr></table></figure></li><li><p>检查内存地址内容：</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">(gdb) x/<span class="number">4</span>xw <span class="variable">&amp;variable_name</span>  <span class="meta"># 打印 variable_name 开始的 4 个字的内存内容，以十六进制显示</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="逐行调试"><a href="#逐行调试" class="headerlink" title="逐行调试"></a>逐行调试</h3><ul><li><p>单步执行一行（会进入函数内部）：</p><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="keyword">step</span>  <span class="meta"># 或简写为 (gdb) s</span></span><br></pre></td></tr></table></figure></li><li><p>单步执行一行（不会进入函数内部）：</p><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="keyword">next</span>  <span class="meta"># 或简写为 (gdb) n</span></span><br></pre></td></tr></table></figure></li><li><p>执行直到函数返回：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">(gdb)</span> fi<span class="symbol">nish</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="查看调用栈"><a href="#查看调用栈" class="headerlink" title="查看调用栈"></a>查看调用栈</h3><ul><li><p>打印当前调用栈：</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="keyword">backtrace </span> <span class="comment"># 或简写为 (gdb) bt</span></span><br></pre></td></tr></table></figure></li><li><p>打印完整的调用栈信息（包括参数值）：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">(gdb)</span> backtrace full</span><br></pre></td></tr></table></figure></li></ul><h3 id="导航调用栈"><a href="#导航调用栈" class="headerlink" title="导航调用栈"></a>导航调用栈</h3><ul><li><p>查看特定帧的信息：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">(gdb)</span> frame <span class="number">2</span>  <span class="attr"># 切换到第 2</span> 帧</span><br></pre></td></tr></table></figure></li><li><p>查看当前帧的局部变量：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">info</span> locals</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改变量值"><a href="#修改变量值" class="headerlink" title="修改变量值"></a>修改变量值</h3><ul><li><p>修改变量值（用于测试修复问题）：</p><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">(gdb) set <span class="keyword">variable</span><span class="number">_n</span>ame = <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用-Watchpoints"><a href="#使用-Watchpoints" class="headerlink" title="使用 Watchpoints"></a>使用 Watchpoints</h3><ul><li><p>Watchpoints 允许你在变量值发生变化时暂停执行，非常适合调试内存写入错误或状态改变的问题。</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">(</span>gdb<span class="punctuation">)</span> rwatch variable_name  <span class="meta"># 当 variable_name 被读取时暂停</span></span><br><span class="line"><span class="punctuation">(</span>gdb<span class="punctuation">)</span> awatch variable_name  <span class="meta"># 当 variable_name 被访问（读或写）时暂停</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="记录与回放（Reverse-Debugging）"><a href="#记录与回放（Reverse-Debugging）" class="headerlink" title="记录与回放（Reverse Debugging）"></a>记录与回放（Reverse Debugging）</h3><ul><li><p>在某些版本的 GDB 中，可以使用记录与回放功能来跟踪程序执行路径并回溯错误的来源。</p></li><li><p>开始记录：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="keyword">record</span></span><br></pre></td></tr></table></figure></li><li><p>回到前一步：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="keyword">reverse</span>-<span class="keyword">step</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="自动化脚本（GDB-脚本）"><a href="#自动化脚本（GDB-脚本）" class="headerlink" title="自动化脚本（GDB 脚本）"></a>自动化脚本（GDB 脚本）</h3><ul><li><p>如果调试任务重复性强，可以编写 GDB 脚本来自动化调试过程。在调试会话中自动执行一系列命令。</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">(gdb) source <span class="keyword">script</span>.gdb</span><br></pre></td></tr></table></figure></li><li><p>脚本示例 <code>script.gdb</code>：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="built_in">run</span></span><br><span class="line"><span class="built_in">print</span> variable_name</span><br><span class="line">continue</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用-TUI-模式"><a href="#使用-TUI-模式" class="headerlink" title="使用 TUI 模式"></a>使用 TUI 模式</h3><ul><li><p>GDB 提供了 TUI（Text User Interface）模式，可以直观地查看源代码和寄存器值。</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">(gdb) layout <span class="keyword">asm</span>  <span class="comment"># 显示汇编代码视图</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="记录调试日志"><a href="#记录调试日志" class="headerlink" title="记录调试日志"></a>记录调试日志</h3><ul><li><p>使用日志记录来跟踪 GDB 调试过程中发生的事件和命令输出。</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="keyword">set</span> logging <span class="built_in">file</span> gdb_log.txt  <span class="comment"># 指定日志文件</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用-GDB-GUI-前端"><a href="#使用-GDB-GUI-前端" class="headerlink" title="使用 GDB GUI 前端"></a>使用 GDB GUI 前端</h3><ul><li>借助于图形用户界面（如 <code>gdbgui</code>、<code>ddd</code>、<code>kdbg</code>）可以提供更直观的调试体验。GUI 前端通常支持鼠标点击设置断点、查看变量等功能，简化了调试操作。</li></ul><h3 id="GDB-与-Valgrind-联合使用"><a href="#GDB-与-Valgrind-联合使用" class="headerlink" title="GDB 与 Valgrind 联合使用"></a>GDB 与 Valgrind 联合使用</h3><ul><li><p>当怀疑程序存在内存泄漏或非法内存访问问题时，可以使用 Valgrind 来检测，再结合 GDB 定位和分析问题。</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">valgrind <span class="params">--vgdb-error=0</span> <span class="string">./my_program</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> cpp </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在wsl上配置VcXsrv</title>
      <link href="/2024/08/13/archived_wsl_config_VcXsrv/"/>
      <url>/2024/08/13/archived_wsl_config_VcXsrv/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#目的">目的</a></li><li><a href="#安装-wsl-和-ubuntu">安装 WSL 和 Ubuntu</a><ul><li><a href="#安装并配置-vcxsrv">安装并配置 VcXsrv</a></li><li><a href="#在-wsl-ubuntu-中配置-x-server">在 WSL Ubuntu 中配置 X Server</a></li><li><a href="#测试图形界面">测试图形界面</a></li><li><a href="#通过控制面板设置防火墙">通过控制面板设置防火墙</a></li><li><a href="#使用高级防火墙设置">使用高级防火墙设置</a></li><li><a href="#检查设置">检查设置</a></li></ul></li></ul><!-- vim-markdown-toc --><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>在windows的虚拟机上跑ros， 问了chatGPT后搞通了，记录一下这个过程；</p><h1 id="安装-WSL-和-Ubuntu"><a href="#安装-WSL-和-Ubuntu" class="headerlink" title="安装 WSL 和 Ubuntu"></a>安装 WSL 和 Ubuntu</h1><p>1, 在 Windows 上启用 WSL：</p><p>&bull; 打开 PowerShell 以管理员身份运行，并执行以下命令：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">wsl <span class="comment">--install</span></span><br></pre></td></tr></table></figure><p>&bull; 这会安装 WSL 和 Ubuntu。如果你已经安装了 WSL，可以跳过这一步。</p><p>2, 从 Microsoft Store 安装 Ubuntu：</p><p>  &bull; 打开 Microsoft Store，搜索并安装你需要的 Ubuntu 版本（如 Ubuntu 20.04 或 22.04）。</p><h2 id="安装并配置-VcXsrv"><a href="#安装并配置-VcXsrv" class="headerlink" title="安装并配置 VcXsrv"></a>安装并配置 VcXsrv</h2><p>1, 下载并安装 VcXsrv：<br>  &bull; 从 VcXsrv 官方网站下载并安装 VcXsrv。<br>2, 配置 VcXsrv：<br>  &bull; 打开 VcXsrv，选择 “Multiple windows” 模式。<br>  &bull; 勾选 “Disable access control” 选项以允许所有连接。<br>  &bull; 点击 “Next” 并完成配置。</p><h2 id="在-WSL-Ubuntu-中配置-X-Server"><a href="#在-WSL-Ubuntu-中配置-X-Server" class="headerlink" title="在 WSL Ubuntu 中配置 X Server"></a>在 WSL Ubuntu 中配置 X Server</h2><p>1, <strong>安装必要的图形界面组件：</strong></p><p>  &bull; 打开 WSL 终端并执行以下命令安装 </p><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">x</span><span class="number">11</span>-apps</span><br></pre></td></tr></table></figure><p>用于测试 X11 转发：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install x11-apps</span><br></pre></td></tr></table></figure><p>2, <strong>配置 DISPLAY 环境变量：</strong></p><p>  &bull; 你需要设置 </p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">DISPLAY</span></span><br></pre></td></tr></table></figure><p>环境变量，让 WSL 能够找到运行中的 VcXsrv。执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export DISPLAY=<span class="subst">$(grep nameserver /etc/resolv.conf | awk &#x27;&#123;print $2&#125;&#x27;)</span>:0&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>&bull; 如果你使用的是 WSL2，可能需要使用 </p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">localhost</span></span><br></pre></td></tr></table></figure><p>替代 </p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">grep</span></span><br></pre></td></tr></table></figure><p>语句：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export DISPLAY=localhost:0&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line">  <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="测试图形界面"><a href="#测试图形界面" class="headerlink" title="测试图形界面"></a>测试图形界面</h2><p>1, <strong>测试 X11 转发：</strong></p><p>  &bull; 在 WSL 终端中执行以下命令：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">xclock</span></span><br></pre></td></tr></table></figure><p>  &bull; 如果一切正常，你应该会看到一个时钟窗口弹出。</p><p>2, <strong>运行其他图形界面应用：</strong></p><p>  &bull; 你可以安装并运行其他 GUI 应用，比如 <code>gedit</code> 或 <code>firefox</code>，来确认图形界面的功能。</p><p>完成这些步骤后，你应该能够在 WSL 中使用 Ubuntu，并通过 VcXsrv 连接和使用图形界面应用。如果遇到问题，可以检查防火墙设置，确保 VcXsrv 的端口未被阻止。</p><p><code>但是我通过上述步骤并没能实现小时钟的出现，根据提示信息，设置防火墙等相关事项，回答如下：</code></p><p>在 Windows 上，你可以通过以下步骤来配置防火墙，确保 VcXsrv 的端口未被阻止：</p><h2 id="通过控制面板设置防火墙"><a href="#通过控制面板设置防火墙" class="headerlink" title="通过控制面板设置防火墙"></a>通过控制面板设置防火墙</h2><p>1, <strong>打开 Windows 防火墙设置：</strong></p><p>  &bull; 按 <code>Windows + R</code> 打开运行对话框，输入 <code>control</code> 并按回车，打开控制面板。</p><p>  &bull; 在控制面板中，选择 “系统和安全 (System and Security)”，然后点击 “Windows Defender 防火墙 (Windows Defender Firewall)”。</p><p>2, <strong>允许应用通过防火墙：</strong></p><p>  &bull; 在左侧菜单中，点击 “允许应用或功能通过 Windows Defender 防火墙 (Allow an app or feature through Windows Defender Firewall)”。</p><p>3, <strong>查找并添加 VcXsrv：</strong></p><p>  &bull; 在列表中查找 “VcXsrv” 或 “X Server” 应用程序。如果没有列出，你需要手动添加：</p><p>  &bull; 点击 “更改设置 (Change settings)”，然后点击 “允许其他应用 (Allow another app) ”。</p><p>  &bull; 点击 “浏览 (Browse)”，导航到 VcXsrv 的安装目录（通常在 <code>C:\Program Files\VcXsrv\</code>），选择 <code>vcxsrv.exe</code>。</p><p>  &bull; 点击 “添加 (Add)” 然后确保为 “专用 (Private)” 和 “公用 (Public)” 网络勾选。</p><p>4, <strong>确认并保存设置：</strong></p><p>  &bull; 点击 “确定 (OK)” 以保存更改。</p><h2 id="使用高级防火墙设置"><a href="#使用高级防火墙设置" class="headerlink" title="使用高级防火墙设置"></a>使用高级防火墙设置</h2><p>如果你需要手动开放端口，可以使用高级防火墙设置：</p><p>1, <strong>打开高级安全 Windows Defender 防火墙：</strong></p><p>  &bull; 在防火墙主界面中，点击左侧的 “高级设置 (Advanced settings)”。</p><p>2, <strong>创建入站规则：</strong></p><p>  &bull; 在左侧的 “入站规则 (Inbound Rules)” 上点击右键，选择 “新建规则 (New Rule)”。</p><p>  &bull; 选择 “端口 (Port)” 然后点击 “下一步 (Next)”。</p><p>  &bull; 在特定本地端口中输入 <code>6000</code>（这是 X11 默认使用的端口），然后点击 “下一步 (Next)”。</p><p>  &bull; 选择 “允许连接 (Allow the connection)” 并点击 “下一步 (Next)”。</p><p>  &bull; 选择适用的网络类型（专用、域和公用），然后点击 “下一步 (Next)”。</p><p>  &bull; 为此规则命名（例如 “VcXsrv X11 Port”），然后点击 “完成 (Finish)”。</p><h2 id="检查设置"><a href="#检查设置" class="headerlink" title="检查设置"></a>检查设置</h2><p>配置完成后，确保 VcXsrv 运行时不被防火墙阻止。可以通过运行 X11 应用如 <code>xclock</code> 来确认防火墙配置是否正确。</p><p>这些步骤应该能帮助你正确配置防火墙，确保 VcXsrv 的正常运行。如果你仍然遇到问题，可以考虑暂时关闭防火墙以进行测试，但通常不建议长期关闭防火墙。</p><p>看看配置的ros2是否起来了</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ros2 <span class="built_in">run</span> turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/46_config/1_wsl/1_install/1_config_wsl_and_run_ros.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CONFIG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ros2 </tag>
            
            <tag> wsl </tag>
            
            <tag> VcXsrv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ros1 中的重要概念</title>
      <link href="/2024/07/12/archived_ros_important_concept/"/>
      <url>/2024/07/12/archived_ros_important_concept/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#ros的重要概念">ROS的重要概念</a><ul><li><a href="#主节点">主节点</a></li><li><a href="#节点">节点</a></li><li><a href="#功能包">功能包</a></li><li><a href="#元功能包">元功能包</a></li><li><a href="#消息">消息</a></li><li><a href="#话题">话题</a></li><li><a href="#发布与发布者">发布与发布者</a></li><li><a href="#订阅与订阅者">订阅与订阅者</a></li><li><a href="#动作">动作</a></li><li><a href="#参数">参数</a></li><li><a href="#参数服务器">参数服务器</a></li><li><a href="#catkin">catkin</a></li><li><a href="#roscore">roscore</a></li><li><a href="#rosrun">rosrun</a></li><li><a href="#roslaunch">roslaunch</a></li><li><a href="#bag">bag</a></li><li><a href="#状态图">状态图</a></li><li><a href="#uri">URI</a></li><li><a href="#cmakeliststxt">CMakeLists.txt</a></li><li><a href="#packagexml">package.xml</a></li></ul></li><li><a href="#其他">其他</a></li></ul><!-- vim-markdown-toc --><h1 id="ROS的重要概念"><a href="#ROS的重要概念" class="headerlink" title="ROS的重要概念"></a>ROS的重要概念</h1><p>ROS的重要概念：消息通信、消息文件、名称(Name)、坐标变换(TF)、客户端库、不同设备之间的通信、文件系统和构建系统。</p><h2 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h2><p>主节点(master)负责节点到节点的连接和消息通信，类似于名称服务器(Name Server)。roscore是它的运行命令，当运行主节点时，可以注册每个节点的名字，并根据需要获取信息。没有主节点，就不能在节点之间建立访问和消息交流(如话题和服务)。</p><p>当启动ROS时，主节点将获取用户设置的ROS_MASTER_URI变量中列出的URI地址和端口。除非另外设置，默认情况下，URI地址使用当前的本地IP，端口使用11311。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>节点(node)是指在ROS中运行的最小处理器单元。可以把它看作一个可执行程序。在ROS中，建议为一个目的创建一个节点，建议设计时注重可重用性。例如，在移动机器人的情况下，为了驱动机器人，将每个程序细分化。也就是说，使用传感器驱动、传感器数据转换、障碍物判断、电机驱动、编码器输入和导航等多个细分节点。</p><p>节点在运行的同时，向主节点注册节点的名称，并且还注册发布者(publisher)、订阅者(subscriber)、服务服务器(service server)、服务客户端(service client )的名称，且注册消息形式、URI地址和端口。基于这些信息，每个节点可以使用话题和服务与其他节点交换消息。</p><p>节点使用XMLRPC与主站进行通信，并使用TCP/IP通信系列的XMLRPC或TCPROS5进行节点之间的通信。节点之间的连接请求和响应使用XMLRPC，而消息通信使用TCPROS，因为它是节点和节点之间的直接通信，与主节点无关。URI地址和端口则使用存储于运行当前节点的计算机上的名为ROS_HOSTNAME的环境变量作为URI地址，并将端口设置为任意的固有值。</p><h2 id="功能包"><a href="#功能包" class="headerlink" title="功能包"></a>功能包</h2><p>功能包(package)是构成ROS的基本单元。ROS应用程序是以功能包为单位开发的。功能包包括至少一个以上的节点或拥有用于运行其他功能包的节点的配置文件。</p><h2 id="元功能包"><a href="#元功能包" class="headerlink" title="元功能包"></a>元功能包</h2><p>元功能包(metapackage)是一个具有共同目的的功能包的集合。例如，导航元功能包包含AMCL、DWA、EKF和map_server等10余个功能包。</p><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>节点之间通过消息(message)来发送和接收数据。消息是诸如integer、floating point和boolean等类型的变量。用户还可以使用诸如消息里包括消息的简单数据结构或列举消息的消息数组的结构。使用消息的通信方法包括TCPROS，UDPROS等，根据情况使用单向消息发送/接收方式的话题(topic)和双向消息请求(request)/响应(response)方式的服务(service)。</p><h2 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h2><p>话题(topic)就是“故事”。在发布者(publisher)节点关于故事向主节点注册之后，它以消息形式发布关于该故事的广告。希望接收该故事的订阅者(subscriber)节点获得在主节点中以这个话题注册的那个发布者节点的信息。基于这个信息，订阅者节点直接连接到发布者节点，用话题发送和接收消息。</p><h2 id="发布与发布者"><a href="#发布与发布者" class="headerlink" title="发布与发布者"></a>发布与发布者</h2><p>发布(publish)是指以与话题的内容对应的消息的形式发送数据。为了执行发布，发布者(publisher)节点在主节点上注册自己的话题等多种信息，并向希望订阅的订阅者节点发送消息。发布者在节点中声明自己是执行发布的个体。单个节点可以成为多个发布者。</p><h2 id="订阅与订阅者"><a href="#订阅与订阅者" class="headerlink" title="订阅与订阅者"></a>订阅与订阅者</h2><p>订阅是指以与话题内容对应的消息的形式接收数据。为了执行订阅，订阅者节点在主节点上注册自己的话题等多种信息，并从主节点接收那些发布此节点要订阅的话题的发布者节点的信息。基于这个信息，订阅者节点直接联系发布者节点来接收消息。订阅者在节点中声明自己执行订阅的个体。单个节点可以成为多个订阅者。</p><p>发布和订阅概念中的话题是异步的，这是一种根据需要发送和接收数据的好方法。另外，由于它通过一次的连接，发送和接收连续的消息，所以它经常被用于必须连续发送消息的传感器数据。然而，在某些情况下，需要一种共同使用请求和响应的同步消息交换方案。因此，ROS提供叫做服务(service)的消息同步方法。服务分为响应请求的服务服务器和请求后接收响应的服务客户端。与话题不同，服务是一次性的消息通信。当服务的请求和响应完成时，两个节点的连接被断开。</p><h2 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h2><p>动作(action)是在需要像服务那样的双向请求的情况下使用的消息通信方式，不同点是在处理请求之后需要很长的响应，并且需要中途反馈值。动作文件也非常类似于服务，目标(goal)和结果(result)对应于请求和响应。此外，还添加了对应于中途的反馈(feedback)。它由一个设置动作目标(goal)的动作客户端(action client)和一个动作服务器(action server)，动作服务器根据目标执行动作，并发送反馈和结果。</p><p>动作客户端和动作服务器之间进行异步双向消息通信。话题、服务和动作之间的差异如下表所示</p><div class="table-container"><table><thead><tr><th>种类 &emsp;</th><th>区别 &emsp;</th><th>&emsp;</th><th></th></tr></thead><tbody><tr><td>话题 &emsp;</td><td>异步 &emsp;</td><td>单向 &emsp;</td><td>连续单向地发送/接收数据的情况</td></tr><tr><td>服务 &emsp;</td><td>同步 &emsp;</td><td>双向 &emsp;</td><td>需要对请求给出即时响应的情况</td></tr><tr><td>动作 &emsp;</td><td>异步 &emsp;</td><td>双向 &emsp;</td><td>请求与响应之间需要太长的时间，所以难以使用服务的情况，或需要中途反馈值的情况</td></tr></tbody></table></div><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>ROS中的参数(parameter)是指节点中使用的参数。可以把它想象成一个Windows程序中的*.ini配置文件。这些参数是默认(default)设置的，可以根据需要从外部读取或写入。尤其是，它可以通过使用外部的写入功能实时更改设置值，因此非常有用。例如，您可以指定与外部设备连接的PC的USB端口、相机校准值、电机速度或命令的最大值和最小值等设置值。</p><h2 id="参数服务器"><a href="#参数服务器" class="headerlink" title="参数服务器"></a>参数服务器</h2><p>参数服务器(parameter server)是指在功能包中使用参数时，注册各参数的服务器。参数服务器也是主节点的一个功能。</p><h2 id="catkin"><a href="#catkin" class="headerlink" title="catkin"></a>catkin</h2><p>catkin是指ROS的构建系统。ROS的构建系统基本上使用CMake(Cross Platform Make)，并在功能包目录中的CMakeLists.txt文件中描述构建环境。在ROS中，我们将CMake修改成专为ROS定制的catkin构建系统。catkin从ROS Fuerte版本开始进行alpha测试，并从Groovy版本开始核心功能包转换为catkin，且从Hydro版本开始应用于大部分功能包。catkin构建系统让用户方便使用与ROS相关的构建、功能包管理以及功能包之间的依赖关系等。现在使用ROS的话，需要使用catkin而不是rosbuild。</p><h2 id="roscore"><a href="#roscore" class="headerlink" title="roscore"></a>roscore</h2><p>roscore是运行ROS主节点的命令。也可以在另一台位于同一个网络内的计算机上运行它。但是，除了支持多roscore的某些特殊情况，roscore在一个网络中只能运行一个。运行ROS时，将使用您在ROS_MASTER_URI变量中列出的URI地址和端口。如果用户没有设置，会使用当前本地IP作为URI地址并使用端口11311。</p><h2 id="rosrun"><a href="#rosrun" class="headerlink" title="rosrun"></a>rosrun</h2><p>rosrun是ROS的基本运行命令。它用于在功能包中运行一个节点。节点使用的URI地址将存储在当前运行节点的计算机上的ROS_HOSTNAME环境变量作为URI地址，端口被设置为任意的固有值。</p><h2 id="roslaunch"><a href="#roslaunch" class="headerlink" title="roslaunch"></a>roslaunch</h2><p>如果rosrun是执行一个节点的命令，那么roslaunch是运行多个节点的概念。该命令允许运行多个确定的节点。其他功能还包括一些专为执行具有诸多选项的节点的ROS命令，比如包括更改功能包参数或节点名称、配置节点命名空间、设置ROS_ROOT和ROS_PACKAGE_PATH以及更改环境变量等。</p><p>roslaunch使用<code>*.launch</code>文件来设置可执行节点，它基于可扩展标记语言(XML)，并提供XML标记形式的多种选项。</p><h2 id="bag"><a href="#bag" class="headerlink" title="bag"></a>bag</h2><p>用户可以保存ROS中发送和接收的消息的数据，这时用于保存的文件格式称为bag，是以*.bag作为扩展名。在ROS中，这个功能包可以用来存储信息并在需要时可以回放以前的情况。例如，当使用传感器执行机器人实验时，使用bag将传感器值以消息形式保存。有了这些保存的信息，即使不重复执行之前的实验，也能通过回放保存的bag文件来反复利用当时的传感器值。特别的，如果利用rosbag的记录和回放功能，在开发那些需要反复修改程序的算法的时候会非常有用。</p><h2 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h2><p>上面描述的节点、话题、发布者和订阅者之间关系可以通过状态图(graph)直观地表示。它是当前正在运行的消息通信的图形表示。但不能为一次性服务创建状态图。执行它是通过运行rqt_graph功能包的rqt_graph节点完成的。有两种执行命令：rqt_graph和rosrun rqt_graph rqt_graph。</p><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p>统一资源标识符(URI，Uniform Resource Identifier)是代表Internet上资源的唯一地址。该URI被用作Internet协议中的标识符，是在Internet上所需的基本条件。</p><h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">()</span></span>                                     #指定catkin最低版本</span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">()</span></span>                                                    #指定软件包的名称</span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">()</span></span>                                               #指定编译时需要的依赖项</span><br><span class="line"><span class="function"><span class="title">add_message_files</span><span class="params">()</span></span>/<span class="built_in">add_service_files</span>()/<span class="built_in">add_action_files</span>()   #添加消息文件/服务文件/动作文件</span><br><span class="line"><span class="function"><span class="title">generate_messages</span><span class="params">()</span></span>                                          #生成消息、服务、动作</span><br><span class="line"><span class="function"><span class="title">catkin_package</span><span class="params">()</span></span>                                             #指定 catkin 信息给编译系统生成 Cmake 文件</span><br><span class="line"><span class="function"><span class="title">add_library</span><span class="params">()</span></span>/<span class="built_in">add_executable</span>()                               #指定生成库文件、可执行文件</span><br><span class="line"><span class="function"><span class="title">target_link_libraries</span><span class="params">()</span></span>                                      #指定可执行文件去链接哪些库</span><br><span class="line"><span class="function"><span class="title">catkin_add_gtest</span><span class="params">()</span></span>                                           #添加测试单元</span><br><span class="line"><span class="function"><span class="title">install</span><span class="params">()</span></span>                                                    #生成可安装目标</span><br></pre></td></tr></table></figure><h2 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span>&gt;</span>  &lt;! --根标签--&gt;</span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>  <span class="comment">&lt;!--包名-&gt; </span></span><br><span class="line"><span class="comment">   &lt;version&gt;  &lt;!--版本号--&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>  <span class="comment">&lt;!--包描述--&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">maintainer</span>&gt;</span>  <span class="comment">&lt;!--维护者--&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">license</span>&gt;</span> <span class="comment">&lt;!--软件许可--&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span> <span class="comment">&lt;!--编译工具--&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span> <span class="comment">&lt;!--编译时的依赖, 一般修改依赖部分的内容--&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span> <span class="comment">&lt;!--运行时的依赖--&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">package</span>&gt;</span>  <span class="comment">&lt;!--根标签--&gt;</span></span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>1, 当执行roscore时，将用户设置的ROS_MASTER_URI作为主URI，并且驱动主节点。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作的第四个年头</title>
      <link href="/2024/05/19/archived_Efort_something_change/"/>
      <url>/2024/05/19/archived_Efort_something_change/</url>
      
        <content type="html"><![CDATA[<p><p id="div-border-left-blue">是非成败转头空，青山依旧在，几度夕阳红。</p><br>​      </p><h1 id="随想"><a href="#随想" class="headerlink" title="随想"></a>随想</h1><p>由于公司对组织架构的调整，或者更直接的说，希望能够带来工作效率的提升，减少不同组之间的内耗，算法组与运控组合并在了一起，于是乎，直接领导换人了。</p><p>从个人入职以来，由核心算法组更名为核心算法部，再到算法组，最后与运控组合并在一起，公司似乎是想减少部门与部门，组与组之间的沟通带来的损失，从站在公司的角度来说，这确实是很好的一种方式减少了内耗。 但是对于我个人而言呢，换了直属领导后，总感觉少了一些东西。</p><p>在这个公司继续发展下去的提升空间还有多少? 似乎已经不是当初来的那个公司，有一点偏向于互联网的企业了，似乎没那么看重技术，更看重话术，未来该何去何从呢，是一个需要慎重考虑的事情。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>2024.9.9号后记；</p><p>如今已更换到新公司，希望能够带来自己的快速成长，不必为中层的管理而感受到不适，发挥自己的特长，努力工作与生活，感谢储工，感谢算法组的小伙伴们，感谢埃夫特。</p>]]></content>
      
      
      <categories>
          
          <category> LIFE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gazebo 学习</title>
      <link href="/2024/04/29/archived_continue_gazebo/"/>
      <url>/2024/04/29/archived_continue_gazebo/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#ros_control-使用">ros_control 使用</a><ul><li><a href="#controller-manager">Controller manager</a><ul><li><a href="#命令行工具">命令行工具：</a></li><li><a href="#launch-工具">Launch 工具：</a></li><li><a href="#可视化工具">可视化工具：</a></li></ul></li></ul></li><li><a href="#自己仿真过程纪录">自己仿真过程纪录</a><ul><li><a href="#没有配置好ros_gazebo_control">没有配置好ros_gazebo_control</a></li><li><a href="#调整pid参数">调整PID参数</a></li><li><a href="#机器人被方块砸">机器人被方块砸</a></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ros_control是一个实现和管理机器人控制器的框架，它致力于提供一种具有实时性能的，与机器人无关的控制器设计方法。</p><h1 id="ros-control-使用"><a href="#ros-control-使用" class="headerlink" title="ros_control 使用"></a>ros_control 使用</h1><p>1, 添加插件gazebo_ros_control</p><p>根据我们的需要，在添加插件的时候可以指定为<robot>，<link>或者<joint>，只要将它写到<gazebo>中就可以了。<br>gazebo_ros_control是Gazebo的一个插件用来根据设定装载合适的硬件接口和控制器。这个实现非常简单，由于Gazebo的插件系统具有很强的扩展性， 使得一些高级玩家可以在ros_control和Gazebo之间创建自己的机器人硬件接口。我们通过在URDF文件中写入如下的XML文本就可以添加gazebo_ros_control插件了，十分简单方便。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;gazebo_ros_control&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_control.so&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">robotNamespace</span>&gt;</span>/MYROBOT<span class="tag">&lt;/<span class="name">robotNamespace</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里没有为标签<gazebo>添加属性reference，这样它就是对整个机器人<robot>的描述。gazebo_ros_control的<plugin>标签还可以通过如下的子标签指定一些参数:</p><p>1) robotNamespace: 用来告知插件其对象的ROS命名空间，默认是URDF或者SDF对应的机器人名称。</p><p>2) contolPeriod:控制器的更新周期，单位为秒，默认使用Gazebo的周期。</p><p>3) robotParam:在ROS的参数服务器上的机器人描述(URDF)路径，默认是’/robot_description’。</p><p>4) robotSimType:机器人仿真接口所使用的插件库名称，默认是’DefaultRobotHWSim’。</p><p>robotNamespace, contolPeriod, robotParam 这几个标签都比较好理解。robotSimType 描述了仿真接口的插件库名称。实际上gazebo_ros_control虽然是一个Gazebo的插件， 它还是提供了一个插件接口用来配置Gazebo与ros_control之间个性化定制的接口。可以理解为一个插件的插件。借助这个接口，我们可以实现自己的控制器，只是需要继承自gazebo_ros_control::RobotHWSim。 默认的插件库是’DefaultRobotHWSim’，提供了如下的ros_control接口：</p><p>2, 添加<transmission>标签</p><p><transmission>是URDF中用来描述执行器和关节之间关系的扩展标签。通过它我们可以描述类似齿轮减速比以及并联结构的属性。 通过它我们可以指定机器人的控制器接口，方便使用ros_control控制机器人。我们为左臂的肘关节添加如下的<transmission>标签：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;tran_left_upper_arm_to_left_elbow_y&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;left_upper_arm_to_left_elbow_y&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;act_left_upper_arm_to_left_elbow_y&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>对于每一个transmission标签都有一个”name”的属性，用来唯一的标识transmission，这里根据自己的习惯以需要关联的joint的名称加上”tran<em>“前缀命名。它有三个子标签， 分别描述了transmission的类型，以及关联的joint和执行器。 type描述了transmission的类型，对于Gazebo而言目前只实现了”transmission_interface/SimpleTransmission”这一个类型。 joint标签描述了关联的joint，它的name的属性用来指示需要关联的joint，它有一个hardwareinterface的子标签， 用来描述硬件接口，因为我们将在Gazebo环境中使用，所以这里必须是”EffortJointInterface”。 actuator标签则声明了与之关联的执行器，同样需要以属性”name”给它一个唯一的名字，一般我们以joint名称加上”act</em>“前缀命名。它还有一个mechanicalReduction的标签， 用来描述执行器到joint的齿轮减速比。</p><h2 id="Controller-manager"><a href="#Controller-manager" class="headerlink" title="Controller manager"></a>Controller manager</h2><p>Controller_manager用于实现对控制器的加载、运行、停止等操作，根据你是从启动文件、命令行还是从ROS节点运行控制器，控制器管理器提供了以下三种方式来运行控制器: <a href="http://wiki.ros.org/controller_manager">http://wiki.ros.org/controller_manager</a>.</p><h3 id="命令行工具："><a href="#命令行工具：" class="headerlink" title="命令行工具："></a>命令行工具：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager controller_manager <span class="tag">&lt;<span class="name">command</span>&gt;</span> <span class="tag">&lt;<span class="name">controller_name</span>&gt;</span></span><br></pre></td></tr></table></figure><p>command 包括：</p><p>1) load: 加载控制器（构造和初始化）</p><p>2) unload: 卸载控制器（销毁）</p><p>3) start:启动控制器</p><p>4) stop: 停止控制器</p><p>5) spawn: 加载和启动控制器</p><p>6) kill: 停止并卸载控制器</p><p>  查看 controller 的状态：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rosrun controller_manager controller_manager &lt;<span class="built_in">command</span>&gt;</span></span><br></pre></td></tr></table></figure><p>command 包括：</p><p>1) list ：按执行顺序列出所有控制器，并给出每个控制器的状态<br>2) list-types ：列出控制器管理器知道的所有控制器类型。<br>3) reload-libraries ：重新加载所有可作为插件使用的控制器库。<br>4) reload-libraries —restore ：重新加载所有可作为插件使用的控制器库，并将所有控制器恢复为原始状态。<br>5) spawner工具：很多时候我们需要控制的controller有很多，比如六轴机器人，至少有六个controller，这时也可以使用“spawner ”这个命令来一次控制多个controller：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ rosrun controller_manager spawner [<span class="comment">--stopped] name1 name2 name3</span></span><br></pre></td></tr></table></figure><p>边的命令可以自动加载、启动controller，如果加上–stopped参数，那么contrller则只会被加载，但是并不会开始运行。 如果想要停止一系列controller，但是不需要卸载，还需要运行的话，可以使用下边的命令：</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>rosrun controller_manager unspawner name1 name2 name3</span><br></pre></td></tr></table></figure><h3 id="Launch-工具："><a href="#Launch-工具：" class="headerlink" title="Launch 工具："></a>Launch 工具：</h3><p>在launch文件中，同样可以通过运行controller_manager包的命令，来加载和启动一系列controller：</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">&lt;node pkg<span class="operator">=</span><span class="string">&quot;controller_manager&quot;</span></span><br><span class="line">   type<span class="operator">=</span><span class="string">&quot;spawner&quot;</span></span><br><span class="line">     args<span class="operator">=</span><span class="string">&quot;controller_name1 controller_name2&quot;</span> /&gt; </span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><p>上边的launch文件会加载并启动controllers，如果只需要加载：</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">   &lt;node pkg<span class="operator">=</span><span class="string">&quot;controller_manager&quot;</span></span><br><span class="line">         type<span class="operator">=</span><span class="string">&quot;spawner&quot;</span></span><br><span class="line">         args<span class="operator">=</span><span class="string">&quot;--stopped controller_name1 controller_name2&quot;</span> /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><h3 id="可视化工具："><a href="#可视化工具：" class="headerlink" title="可视化工具："></a>可视化工具：</h3><p>rqt_controller_manager是一个rqt插件，允许以图形方式加载，卸载，启动和停止控制器，以及显示有关已加载控制器的信息。<br>它可以从rqt的“插件”菜单启动，也可以作为具有以下内容的独立可执行文件启动：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rosrun rqt_controller_manager rqt_controller_manager</span></span><br></pre></td></tr></table></figure><h1 id="自己仿真过程纪录"><a href="#自己仿真过程纪录" class="headerlink" title="自己仿真过程纪录"></a>自己仿真过程纪录</h1><h2 id="没有配置好ros-gazebo-control"><a href="#没有配置好ros-gazebo-control" class="headerlink" title="没有配置好ros_gazebo_control"></a>没有配置好ros_gazebo_control</h2><video src="/img/postImg/1_ros/2_gazebo/1_gazebo仿真没有起来.mp4" position= "absolute" width="100%" height="100%" controls="controls"></video><h2 id="调整PID参数"><a href="#调整PID参数" class="headerlink" title="调整PID参数"></a>调整PID参数</h2><video src="/img/postImg/1_ros/2_gazebo/2_gazeboPID调整参数.mp4" position= "absolute" width="100%" height="100%" controls="controls"></video><h2 id="机器人被方块砸"><a href="#机器人被方块砸" class="headerlink" title="机器人被方块砸"></a>机器人被方块砸</h2><video src="/img/postImg/1_ros/2_gazebo/3_被掉落的小方块砸.mp4" position= "absolute" width="100%" height="100%" controls="controls"></video><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://gaoyichao.com/Xiaotu/?book=ros&amp;title=Gazebo_ros_control">Gazebo + ros_control</a></p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> Gazebo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2024/01/26/archived_linkList/"/>
      <url>/2024/01/26/archived_linkList/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#线性表">线性表</a><ul><li><a href="#链表">链表</a></li></ul></li><li><a href="#链表典型应用">链表典型应用</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>与数组不同的是,组成链表的格子不是连续的。它们可以分布在内存的各个地方。这种不相邻的格子,就叫作结点。每个结点除了保存数据,它还保存着链表里的下一结点的内存地址。如下图所示：</p><p><img src="/img/postImg/19_dataStructure/linkedList/链表的结构示意图.png" alt=""></p><p>若想使用链表,只需知道<code>第一个结点</code>在内存的什么位置。因为每个结点都有指向下一结点的链,所以只要有给定的第一个结点,就可以用结点1的链找到结点2再用结点2的链找到结点3……如此遍历链表的剩余部分。下面这张图感觉更能形象的表述出这份意思</p><p><img src="/img/postImg/19_dataStructure/linkedList/linkedlist_common_types.png" alt=""></p><p>下面给出链表结构的C++代码实现部分</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    int <span class="keyword">data</span>;</span><br><span class="line">    Node* next;</span><br><span class="line">    </span><br><span class="line">    Node(int <span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* head;</span><br><span class="line">    </span><br><span class="line">    LinkedList() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在链表末尾添加节点</span></span><br><span class="line">    void append(int <span class="keyword">data</span>) &#123;</span><br><span class="line">        Node* new_node = new Node(<span class="keyword">data</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;head == NULL) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;head = new_node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node* current = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">            <span class="keyword">while</span> (current-&gt;next != NULL) &#123;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            current-&gt;next = new_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在链表指定位置插入节点</span></span><br><span class="line">    void insert(int <span class="keyword">data</span>, int index) &#123;</span><br><span class="line">        Node* new_node = new Node(<span class="keyword">data</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            new_node-&gt;next = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">            <span class="keyword">this</span>-&gt;head = new_node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node* current = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; index-<span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current == NULL) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;Error: Index out of range.&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            new_node-&gt;next = current-&gt;next;</span><br><span class="line">            current-&gt;next = new_node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在链表指定位置删除节点</span></span><br><span class="line">    void remove(int index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;head == NULL) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error: List is empty.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            Node* temp = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">            <span class="keyword">this</span>-&gt;head = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line">            delete temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node* current = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; index-<span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current == NULL) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;Error: Index out of range.&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;next == NULL) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Error: Index out of range.&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Node* temp = current-&gt;next;</span><br><span class="line">            current-&gt;next = temp-&gt;next;</span><br><span class="line">            delete temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示链表中的所有节点</span></span><br><span class="line">    void display() &#123;</span><br><span class="line">        Node* current = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (current != NULL) &#123;</span><br><span class="line">            cout &lt;&lt; current-&gt;<span class="keyword">data</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">int main() &#123;</span><br><span class="line">    LinkedList list;</span><br><span class="line">    </span><br><span class="line">    list.append(<span class="number">1</span>);</span><br><span class="line">    list.append(<span class="number">2</span>);</span><br><span class="line">    list.append(<span class="number">3</span>);</span><br><span class="line">    list.display(); <span class="comment">// 输出：1 2 3</span></span><br><span class="line">    </span><br><span class="line">    list.insert(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">    list.display(); <span class="comment">// 输出：1 4 2 3</span></span><br><span class="line">    </span><br><span class="line">    list.remove(<span class="number">2</span>);</span><br><span class="line">    list.display(); <span class="comment">// 输出：1 4 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表典型应用"><a href="#链表典型应用" class="headerlink" title="链表典型应用"></a>链表典型应用</h1><p>单向链表通常用于实现栈、队列、哈希表和图等数据结构。</p><p><strong>栈与队列</strong>：当插入和删除操作都在链表的一端进行时，它表现出先进后出的特性，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应队列。</p><p><strong>哈希表</strong>：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。</p><p><strong>图</strong>：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。</p><p>双向链表常用于需要快速查找前一个和后一个元素的场景。</p><p><strong>高级数据结构</strong>：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。</p><p><strong>浏览器历史</strong>：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。</p><p><strong>LRU 算法</strong>：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。</p><p>环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。</p><p><strong>时间片轮转调度算法</strong>：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。</p><p><strong>数据缓冲区</strong>：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1, 《数据结构与算法图解》 — 杰伊 温格罗著, 袁志鹏译<br>2, 《数据结构(C++语言版)》 — 邓俊辉 编著<br>3, <a href="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list/#423">Hello 算法</a></p>]]></content>
      
      
      <categories>
          
          <category> dataStruct </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> data_struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim 2024年学习笔记</title>
      <link href="/2024/01/20/archive_vim2024/"/>
      <url>/2024/01/20/archive_vim2024/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#每行超过80个的字符用下划线标示">每行超过80个的字符用下划线标示</a></li><li><a href="#寄存器">寄存器</a></li><li><a href="#技巧">技巧</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="每行超过80个的字符用下划线标示"><a href="#每行超过80个的字符用下划线标示" class="headerlink" title="每行超过80个的字符用下划线标示"></a>每行超过80个的字符用下划线标示</h1><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">au BufRead,BufNewFile *<span class="string">.asm</span>,*<span class="string">.c</span>,*<span class="string">.cpp</span>,*<span class="string">.java</span>,*<span class="string">.cs</span>,*<span class="string">.sh</span>,*<span class="string">.lua</span>,*<span class="string">.pl</span>,*<span class="string">.pm</span>,*<span class="string">.py</span>,*<span class="string">.rb</span>,*<span class="string">.hs</span>,*<span class="string">.vim</span> 2match Underlined <span class="string">/.</span>\%81v/</span><br></pre></td></tr></table></figure><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>寄存器就是存储文本的地方。常用的「复制」操作就是把文本存储到寄存器，「 粘贴」 操作就是把文本从寄存器中读出来。顺便，在 Vim 中复制的快捷键是 y，粘贴的快捷键是 p。</p><p>Vim 为我们提供了如下的寄存器：</p><div class="table-container"><table><thead><tr><th>类型</th><th>标识</th><th>读写者</th><th>是否为只读</th><th>包含的字符来源</th></tr></thead><tbody><tr><td>Unnamed</td><td><code>&quot;</code></td><td>vim</td><td>否</td><td>最近一次的复制或删除操作 (<code>d</code>, <code>c</code>, <code>s</code>, <code>x</code>, <code>y</code>)</td></tr><tr><td>Numbered</td><td><code>0</code>至<code>9</code></td><td>vim</td><td>否</td><td>寄存器 <code>0</code>: 最近一次复制。寄存器 <code>1</code>: 最近一次删除。寄存器 <code>2</code>: 倒数第二次删除，以此类推。对于寄存器 <code>1</code> 至 <code>9</code>，他们其实是只读的最多包含 9 个元素的队列。这里的队列即为数据类型 <a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type">queue</a>&gt;)</td></tr><tr><td>Small delete</td><td><code>-</code></td><td>vim</td><td>否</td><td>最近一次行内删除</td></tr><tr><td>Named</td><td><code>a</code>至<code>z</code>, <code>A</code>至<code>Z</code></td><td>用户</td><td>否</td><td>如果你通过复制操作存储文本至寄存器 <code>a</code>，那么 <code>a</code> 中的文本就会被完全覆盖。如果你存储至 <code>A</code>，那么会将文本添加给寄存器 <code>a</code>，不会覆盖之前已有的文本</td></tr><tr><td>Read-only</td><td><code>:</code>与<code>.</code>和<code>%</code></td><td>vim</td><td>是</td><td><code>:</code>: 最近一次使用的命令，<code>.</code>: 最近一次添加的文本，<code>%</code>: 当前的文件名</td></tr><tr><td>Alternate buffer</td><td><code>#</code></td><td>vim</td><td>否</td><td>大部分情况下，这个寄存器是当前窗口中，上一次访问的缓冲区。请参阅 <code>:h alternate-file</code> 来获取更多帮助</td></tr><tr><td>Expression</td><td><code>=</code></td><td>用户</td><td>否</td><td>复制 VimL 代码时，这个寄存器用于存储代码片段的执行结果。比如，在插入模式下复制 <code>&lt;c-r&gt;=5+5&lt;cr&gt;</code>，那么这个寄存器就会存入 10</td></tr><tr><td>Selection</td><td><code>+</code>和<code>*</code></td><td>vim</td><td>否</td><td><code>*</code> 和 <code>+</code> 是 <a href="#剪贴板">剪贴板</a> 寄存器</td></tr><tr><td>Drop</td><td><code>~</code></td><td>vim</td><td>是</td><td>最后一次拖拽添加至 Vim 的文本（需要 “+dnd” 支持，暂时只支持 GTK GUI。请参阅 <code>:help dnd</code> 及 <code>:help quote~</code>）</td></tr><tr><td>Black hole</td><td><code>_</code></td><td>vim</td><td>否</td><td>一般称为黑洞寄存器。对于当前操作，如果你不希望在其他寄存器中保留文本，那就在命令前加上 <code>_</code>。比如，<code>&quot;_dd</code> 命令不会将文本放到寄存器 <code>&quot;</code>、<code>1</code>、<code>+</code> 或 <code>*</code> 中</td></tr><tr><td>Last search pattern</td><td><code>/</code></td><td>vim</td><td>否</td><td>最近一次通过 <code>/</code>、<code>?</code> 或 <code>:global</code> 等命令调用的匹配条件</td></tr></tbody></table></div><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>1，<code>:%normal A;</code>可以让所有行后都加入分号， 类似的， 可借用这个模式， 输入行后都是<code>.</code>, 如<code>:%normal A.</code><br>2, 在使用 v 或者 V 选择某段文字后，可以用 o 或者 O 按键跳至选择区域的开头或者结尾。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://github.com/wsdjeg/vim-galore-zh_cn">vim 从入门到精通</a></p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tools </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年总结与展望</title>
      <link href="/2024/01/08/archived_2023_summary_2024_plan/"/>
      <url>/2024/01/08/archived_2023_summary_2024_plan/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2023年, 这一年其实做了蛮多的事情的，对机器人理论部分有了进一步的了解，对ROS部分有个初步的认识，学习了些旋量理论的建模，乒乓球技术的稳定性提高了不少， 手感也上来了， 与媳妇解锁了好几座城市，如金华，青岛，苏州，扬州，南京，芜湖等等；</p><p>但是最大的挑战可能在今年，也就是2024年了，也许今年是订婚买房的一年，想想压力都好大，也不知道能准备好多少东西，全部都准备好，感觉目前至少今年还做不到，一点点的推进吧，急不得；</p><h1 id="2023-年目标"><a href="#2023-年目标" class="headerlink" title="2023 年目标"></a>2023 年目标</h1><p><del>1, 会用吉他弹一些小曲, 如《天空之城》。</del></p><p><del>2, 会用电子钢琴弹一些简单的曲,如《遇见》。</del></p><p>3, 有至少三篇博客的输出。</p><p>4, 见媳妇她弟。</p><p>5, 与媳妇一起见高中老师。</p><p><del>6, 学习数据结构,对简单的数据结构做到非常熟悉。</del></p><p><del>7, 会用Mathematica分析控制系统。</del></p><p>8,提高乒乓球技术,参加相关比赛。</p><p>~~9, 减肥至120斤以内。 ~~</p><p>10, 见小沈一面(于2023.1.2 完成)。</p><h1 id="2024-年目标"><a href="#2024-年目标" class="headerlink" title="2024 年目标"></a>2024 年目标</h1><p>看了下2023年的目标，截止写下这部分内容的时候，完成率还可以嘛～，至少比2022年完成率要高出很多；对于2024年的憧憬其实还是蛮多的，希望能够在2024年完成的目标如下：</p><p>1, 会用吉他弹一些小曲, 如《天空之城》。</p><p>2, 会用电子钢琴弹一些简单的曲,如《遇见》。</p><p>3, 学习数据结构,对简单的数据结构做到非常熟悉。</p><p>4, 会用Mathematica分析控制系统。</p><p>5, 减肥至120斤以内。 </p><p>6, 见媳妇对方父母。</p><p>7，使用ROS对复杂构型建立运动学/动力学建模并实现仿真绘制， 并将整个过程输出到博客记录中；</p><p>8, 与媳妇解锁至少两座没有去过的城市, 想解锁厦门和云南，还有聊城，去看看小强；</p><p>9，工作上能够将柔度补偿算法给落地了，毕竟折腾了这么久了；</p><p>10, 订婚，订婚，订婚！！！</p>]]></content>
      
      
      <categories>
          
          <category> LIFE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> dots </tag>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代机器人学：刚体运动与运动旋量</title>
      <link href="/2023/10/14/archived_Modern_Robotics_%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8%E4%B8%8E%E8%BF%90%E5%8A%A8%E6%97%8B%E9%87%8F/"/>
      <url>/2023/10/14/archived_Modern_Robotics_%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8%E4%B8%8E%E8%BF%90%E5%8A%A8%E6%97%8B%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#齐次变换矩阵">齐次变换矩阵</a><ul><li><a href="#齐次变换矩阵的用途">齐次变换矩阵的用途</a></li><li><a href="#运动旋量">运动旋量</a></li><li><a href="#twist-的坐标系变换">Twist 的坐标系变换</a></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="齐次变换矩阵"><a href="#齐次变换矩阵" class="headerlink" title="齐次变换矩阵"></a>齐次变换矩阵</h1><p>同时考虑刚体的位置和姿态。一种自然的选择就是用旋转矩阵R∈SO(3)表示物体坐标系{b}相对固定坐标系{s}的姿态，用向量p∈<img src="/img/postImg/mathSym/R_3.png" width="1.7%" height="1.7%"> 表示{b}的坐标原点相对{s}的坐标。所采用的方法不是将它们两者分离，而是集成在一个矩阵中。</p><blockquote><p>特殊欧氏群（special Euclidean group) SE(3)</p></blockquote><p>特殊欧氏群(special Euclidean group)SE(3)亦称刚体运动(rigid-body motion）群或齐次变换矩阵（homogeneous transformation matrice）群，是所有4×4实矩阵T的集合，可以写成</p><p><img src="/img/postImg/32_robotics/刚体运动与运动旋量/齐次变换矩阵.png" alt=""></p><p>式中，R∈SO(3),p∈<img src="/img/postImg/mathSym/R_3.png" width="1.7%" height="1.7%">为列向量。</p><h2 id="齐次变换矩阵的用途"><a href="#齐次变换矩阵的用途" class="headerlink" title="齐次变换矩阵的用途"></a>齐次变换矩阵的用途</h2><p>如旋转矩阵一样，齐次变换矩阵T也有3种主要用途： </p><p>① 表示刚体的位形（位置和姿态）；</p><p>② 变换参考坐标系（用向量或坐标系来表示)：</p><p>③ 表示向量或坐标系的位移。</p><p>熟悉DH参数法建立运动学模型的对这块是非常熟悉了，所以就不介绍具体的示例了</p><h2 id="运动旋量"><a href="#运动旋量" class="headerlink" title="运动旋量"></a>运动旋量</h2><p>运动旋量twist与旋量本身是两个东西，需要做一下区分，将运动旋量twist和时间系数的乘积定义为旋量，直观理解就是关于这个旋轴旋转了多少角度。旋量的矩阵形式通过指数运算就得到对应的位置变换矩阵；</p><p>用{s}和{b}分别代表固定（空间）坐标系和移动（物体）坐标系。不难得到有</p><p><img src="/img/postImg/32_robotics/刚体运动与运动旋量/s_b坐标变换矩阵.png" alt=""></p><p>同时两边进行求导，有</p><p><img src="/img/postImg/32_robotics/刚体运动与运动旋量/推导运动旋量1.png" width="27%" height="j7%"> </p><p>由于 <img src="/img/postImg/32_robotics/刚体运动与运动旋量/p_b.png" width="1.7%" height="1.7%"> 是固连{b}坐标系下的，所以其导数为0，不难得到有</p><p><img src="/img/postImg/32_robotics/刚体运动与运动旋量/推导运动旋量2.png" alt=""></p><p>从上面式子可以知道， <img src="/img/postImg/32_robotics/刚体运动与运动旋量/dotT_T_1.png" width="3.7%" height="3.7%"> 可以将空间点变成空间速度，由此定义运动旋量</p><p><img src="/img/postImg/32_robotics/刚体运动与运动旋量/运动旋量的李括号表示.png" alt=""></p><p>定义 twist V 为</p><p><img src="/img/postImg/32_robotics/刚体运动与运动旋量/运动旋量的一般表示.png" alt=""></p><p>在 twist 中，v 是作为角速度的一个补充，通过矩阵乘法来得到线速度，它与角速度是互相独立的，它本身并不是刚体的线速度。v的几何解释是刚体上位于原点处的一个点的线速度。刚体本身是围绕<img src="/img/postImg/mathSym/omega.png" width="1%" height="1%"> 以单位角速度旋转的。</p><h2 id="Twist-的坐标系变换"><a href="#Twist-的坐标系变换" class="headerlink" title="Twist 的坐标系变换"></a>Twist 的坐标系变换</h2><p>因为有：</p><p><img src="/img/postImg/32_robotics/1_Twist的坐标系变换/1.png" alt=""></p><p>所以：</p><p><img src="/img/postImg/32_robotics/1_Twist的坐标系变换/2.png" alt=""></p><p>刚体坐标系下的 twist 矩阵为</p><p><img src="/img/postImg/32_robotics/1_Twist的坐标系变换/3.png" alt=""></p><p>所以</p><p><img src="/img/postImg/32_robotics/1_Twist的坐标系变换/4.png" alt=""></p><p>定义 T（{b} 在 {s} 里的位姿表示）的伴随表示：</p><p><img src="/img/postImg/32_robotics/1_Twist的坐标系变换/5.png" alt=""></p><p>则</p><p><img src="/img/postImg/32_robotics/1_Twist的坐标系变换/6.png" alt=""></p><p><img src="/img/postImg/32_robotics/1_Twist的坐标系变换/7.png" alt=""></p><p>因为 screw axis 是单位 twist，所以变换公式也适用于 screw axis</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] &lt;&lt;机器人学笔记&gt;&gt; 许中兴, RISE 团队</p>]]></content>
      
      
      <categories>
          
          <category> ROBOTICS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> twist </tag>
            
            <tag> robotics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代机器人学：轴角表示法与刚体转动的指数坐标</title>
      <link href="/2023/10/07/archived_Modern_Robotics_%E8%BD%B4%E8%A7%92%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
      <url>/2023/10/07/archived_Modern_Robotics_%E8%BD%B4%E8%A7%92%E8%A1%A8%E7%A4%BA%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#转动的指数坐标表示">转动的指数坐标表示</a><ul><li><a href="#轴角解释">轴角解释</a></li><li><a href="#刚体转动的指数坐标">刚体转动的指数坐标</a><ul><li><a href="#rodriguess-formula">Rodrigues’s formula</a></li></ul></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="转动的指数坐标表示"><a href="#转动的指数坐标表示" class="headerlink" title="转动的指数坐标表示"></a>转动的指数坐标表示</h1><h2 id="轴角解释"><a href="#轴角解释" class="headerlink" title="轴角解释"></a>轴角解释</h2><p>下面我们来介绍<strong>转动的三参数指数坐标</strong>表示。引人指数坐标，可以将旋转矩阵写成关于转轴（用单位向量<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%">表示）和转角<img src="/img/postImg/mathSym/theta.png" width="0.7%" height="0.7%">的参数化形式，向量<img src="/img/postImg/mathSym/hat_omega_theta_in_R_3.png" width="5%" height="5%"> 就是该转动的三参数指数坐标表示形式。单独来写<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%"> 和<img src="/img/postImg/mathSym/theta.png" width="0.7%" height="0.7%">就是转动的轴-角(axis-angle)表示法。</p><p>旋转矩阵R的指数坐标表示<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%"><img src="/img/postImg/mathSym/theta.png" width="0.7%" height="0.7%"> 可以等效地解释如下。</p><p>&bull; 单位转轴<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%"> 和转角<img src="/img/postImg/mathSym/theta.png" width="0.7%" height="0.7%">。坐标系最初与{s}重合，然后绕单位转轴<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%">旋转一定角度<img src="/img/postImg/mathSym/theta.png" width="0.7%" height="0.7%">,最终相对{s}的姿态表示成R。</p><p>&bull; {s}中表示的<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%"><img src="/img/postImg/mathSym/theta.png" width="0.7%" height="0.7%">。坐标系最初与{s}重合，然后在单位时间内运动<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%"><img src="/img/postImg/mathSym/theta.png" width="0.7%" height="0.7%">（即<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%"><img src="/img/postImg/mathSym/theta.png" width="0.7%" height="0.7%">  在这一时间段的积分)，最终姿态表示成R。</p><p>&bull; {s}中表示的<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%">。坐标系最初与{s}重合，然后在单位时间内运动<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%">（即<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%"> 在这一时间段的积分)，最终姿态表示成R。</p><h2 id="刚体转动的指数坐标"><a href="#刚体转动的指数坐标" class="headerlink" title="刚体转动的指数坐标"></a>刚体转动的指数坐标</h2><p>刚体转动的指数坐标可以等效成:</p><p>1, 单位转轴<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%">与绕该轴线的转角;<br>2, 通过连乘得到的三维向量。</p><h3 id="Rodrigues’s-formula"><a href="#Rodrigues’s-formula" class="headerlink" title="Rodrigues’s formula"></a>Rodrigues’s formula</h3><p>给定向量<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%"><img src="/img/postImg/mathSym/theta.png" width="0.7%" height="0.7%"> <img src="/img/postImg/mathSym/in.png" width="1%" height="1%"> <img src="/img/postImg/mathSym/R_3.png" width="1.7%" height="1.7%">, <img src="/img/postImg/mathSym/theta.png" width="0.7%" height="0.7%">为任一标量， 而 <img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%"> <img src="/img/postImg/mathSym/in.png" width="1%" height="1%"> <img src="/img/postImg/mathSym/R_3.png" width="1.7%" height="1.7%">为一单位向量，[<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%">]<img src="/img/postImg/mathSym/theta.png" width="0.7%" height="0.7%">=[<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%"><img src="/img/postImg/mathSym/theta.png" width="0.7%" height="0.7%">] <img src="/img/postImg/mathSym/in.png" width="1%" height="1%"> so(3) 的矩阵指数为</p><p><img src="/img/postImg/32_robotics/指数积/罗德里格斯.png" width="50%" height="50%"></p><p>通常也被称为罗德里格斯公式(Rodrigues’s formula)。</p><p>以上给出了当给定转轴<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%"> 和转角<img src="/img/postImg/mathSym/theta.png" width="0.7%" height="0.7%"> 时，如何通过矩阵指数构造旋转矩阵。进而, 物理量 <img src="/img/postImg/mathSym/e_omega_theta.png" width="2%" height="2%">p 可看成对向量p <img src="/img/postImg/mathSym/in.png" width="1%" height="1%"><img src="/img/postImg/mathSym/R_3.png" width="1.7%" height="1.7%"> 绕转轴<img src="/img/postImg/mathSym/hat_omega.png" width="1%" height="1%">旋转角度<img src="/img/postImg/mathSym/theta.png" width="0.7%" height="0.7%">后的结果。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] May 2017 preprint of Modern Robotics, Lynch and Park, Cambridge U. Press, 2017. <a href="http://modernrobotics.org">http://modernrobotics.org</a></p>]]></content>
      
      
      <categories>
          
          <category> ROBOTICS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> robotics </tag>
            
            <tag> axis-angle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 多维数据有效可视化的艺术</title>
      <link href="/2023/09/25/archived_python_%E5%A4%9A%E7%BB%B4%E6%95%B0%E6%8D%AE%E6%9C%89%E6%95%88%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
      <url>/2023/09/25/archived_python_%E5%A4%9A%E7%BB%B4%E6%95%B0%E6%8D%AE%E6%9C%89%E6%95%88%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#介绍">介绍</a></li><li><a href="#动机">动机</a></li><li><a href="#快速回顾一下可视化">快速回顾一下可视化</a></li><li><a href="#空谈是廉价的向我展示可视化和代码">空谈是廉价的，向我展示可视化（和代码）！</a></li><li><a href="#单变量分析">单变量分析</a><ul><li><a href="#一维-1-d-可视化数据">一维 (1-D) 可视化数据</a></li></ul></li><li><a href="#多元分析">多元分析</a><ul><li><a href="#二维2-d数据可视化">二维（2-D）数据可视化</a></li><li><a href="#三维-3-d-可视化数据">三维 (3-D) 可视化数据</a></li><li><a href="#在四个维度-4-d-中可视化数据">在四个维度 (4-D) 中可视化数据</a></li><li><a href="#五维-5-d-可视化数据">五维 (5-D) 可视化数据</a></li><li><a href="#六维-6-d-可视化数据">六维 (6-D) 可视化数据</a></li></ul></li><li><a href="#结论">结论</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>整整一篇文章直接搬运而来的，强烈建议直接查看<a href="https://towardsdatascience.com/the-art-of-effective-visualization-of-multi-dimensional-data-6c7202990c57">原文</a>，对于多维数据的展示技巧和方法，说的相当的透彻，这篇文章收藏于2020年初，绘图技术的艺术品；下面就直接给出原文的内容，经过谷歌翻译后抄录如下。 另外数据集合可点击<a href="https://github.com/dipanjanS/practical-machine-learning-with-python/tree/master/bonus%20content/effective%20data%20visualization">链接</a>下载；</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>描述性分析是与数据科学项目甚至特定研究相关的任何分析生命周期的核心组成部分之一。数据聚合、汇总和可视化是支持该数据分析领域的一些主要支柱。从传统商业智能时代到人工智能、数据可视化时代它是一种强大的工具，由于它能够有效地提取正确的信息、清晰、轻松地理解和解释结果，因此已被各组织广泛采用。然而，处理通常具有两个以上属性的多维数据集开始引起问题，因为数据分析和通信媒介通常仅限于二维。在本文中，将探索一些在多个维度（从一维到六维）可视化数据的有效策略。</p><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><blockquote><p>“一图胜千言” </p></blockquote><p>这是我们都熟悉的非常流行的英语习语，应该为我们理解和利用数据可视化作为分析中的有效工具提供足够的灵感和动力。永远记住“有效的数据可视化既是一门艺术，也是一门科学”。开始之前，我还想提一下下面的引言，它确实相关，并且强调了数据可视化的必要性。</p><blockquote><p>“一幅画的最大价值在于它迫使我们注意到我们从未想到过的东西。” — 约翰·图基</p></blockquote><h1 id="快速回顾一下可视化"><a href="#快速回顾一下可视化" class="headerlink" title="快速回顾一下可视化"></a>快速回顾一下可视化</h1><p>我假设普通读者了解用于绘制和可视化数据的基本图形和图表，因此我不会进行详细解释，但我们将在此处的实践实验中涵盖其中的大部分内容。正如著名可视化先驱和统计学家Edward Tufte所提到的，数据可视化应该在数据之上利用，以“清晰、精确和高效”的方式传达模式和见解。</p><p>结构化数据通常由行表示的数据观察和列表示的特征或数据属性组成。每一列也可以称为数据集的一个特定维度。最常见的数据类型包括连续数值数据和离散分类数据。因此，任何数据可视化基本上都会以一种易于理解的视觉效果（如散点图、直方图、箱线图等）来描述一个或多个数据属性。我将介绍单变量（一维）和多变量（多维）数据可视化策略。我们将在这里使用 Python 机器学习生态系统，我们建议您查看数据分析和可视化框架，包括<code>pandas、matplotlib、seaborn</code>和<code>plotlybokeh</code>。除此之外，如果您有兴趣用数据制作美观且有意义的可视化，那么了解<a href="https://d3js.org/">D3.js</a>也是必须的。有兴趣的读者建议阅读爱德华·塔夫特（Edward Tufte）的《定量信息的视觉显示》。</p><h1 id="空谈是廉价的，向我展示可视化（和代码）！"><a href="#空谈是廉价的，向我展示可视化（和代码）！" class="headerlink" title="空谈是廉价的，向我展示可视化（和代码）！"></a>空谈是廉价的，向我展示可视化（和代码）！</h1><p>让我们开始吧，而不是我喋喋不休地谈论理论和概念。我们将使用UCI 机器学习存储库中提供的葡萄酒质量数据集。该数据实际上由两个数据集组成，描述了葡萄牙“Vinho Verde”葡萄酒的红色和白色变体的各种属性。本文中的所有分析都可以在我的GitHub 存储库中作为Jupyter Notebook获取，供那些渴望亲自尝试的人使用！</p><p>我们将首先加载以下必要的依赖项以进行分析。</p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="title">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><p>我们将主要使用matplotlib 和seaborn 作为我们的可视化框架，但您可以自由地检查并尝试与您选择的任何其他框架进行相同的操作。我们来看看经过一些基本数据预处理步骤后的数据。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">white_wine = pd.read_csv(<span class="string">&#x27;winequality-white.csv&#x27;</span>, <span class="attribute">sep</span>=<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">red_wine = pd.read_csv(<span class="string">&#x27;winequality-red.csv&#x27;</span>, <span class="attribute">sep</span>=<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># store wine type as an attribute</span></span><br><span class="line">red_wine[<span class="string">&#x27;wine_type&#x27;</span>] = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">white_wine[<span class="string">&#x27;wine_type&#x27;</span>] = <span class="string">&#x27;white&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bucket wine quality scores into qualitative quality labels</span></span><br><span class="line">red_wine[<span class="string">&#x27;quality_label&#x27;</span>] = red_wine[<span class="string">&#x27;quality&#x27;</span>].apply(lambda value: <span class="string">&#x27;low&#x27;</span></span><br><span class="line">                                                          <span class="keyword">if</span> value &lt;= 5 <span class="keyword">else</span> <span class="string">&#x27;medium&#x27;</span></span><br><span class="line">                                                              <span class="keyword">if</span> value &lt;= 7 <span class="keyword">else</span> <span class="string">&#x27;high&#x27;</span>)</span><br><span class="line">red_wine[<span class="string">&#x27;quality_label&#x27;</span>] = pd.Categorical(red_wine[<span class="string">&#x27;quality_label&#x27;</span>],</span><br><span class="line">                                           categories=[<span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;medium&#x27;</span>, <span class="string">&#x27;high&#x27;</span>])</span><br><span class="line">white_wine[<span class="string">&#x27;quality_label&#x27;</span>] = white_wine[<span class="string">&#x27;quality&#x27;</span>].apply(lambda value: <span class="string">&#x27;low&#x27;</span></span><br><span class="line">                                                              <span class="keyword">if</span> value &lt;= 5 <span class="keyword">else</span> <span class="string">&#x27;medium&#x27;</span></span><br><span class="line">                                                                  <span class="keyword">if</span> value &lt;= 7 <span class="keyword">else</span> <span class="string">&#x27;high&#x27;</span>)</span><br><span class="line">white_wine[<span class="string">&#x27;quality_label&#x27;</span>] = pd.Categorical(white_wine[<span class="string">&#x27;quality_label&#x27;</span>],</span><br><span class="line">                                             categories=[<span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;medium&#x27;</span>, <span class="string">&#x27;high&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge red and white wine datasets</span></span><br><span class="line">wines = pd.concat([red_wine, white_wine])</span><br><span class="line"></span><br><span class="line"><span class="comment"># re-shuffle records just to randomize data points</span></span><br><span class="line">wines = wines.sample(<span class="attribute">frac</span>=1, <span class="attribute">random_state</span>=42).reset_index(drop=True)</span><br></pre></td></tr></table></figure><p>我们通过合并与红葡萄酒和白葡萄酒样品相关的数据集来创建单个数据框葡萄酒。我们还<code>quality_label</code> 根据<code>quality</code>葡萄酒样品的属性创建了一个新的分类变量。现在让我们看一下数据。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">wines<span class="selector-class">.head</span>()</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/葡萄酒品质数据集.webp" alt=""></p><p>很明显，我们有葡萄酒样品的几个数字和分类属性。每个观察结果都属于红葡萄酒或白葡萄酒样品，属性是通过物理化学测试测量和获得的特定属性或特性。如果你想了解每个属性的详细解释，你可以查看Jupyter Notebook ，但名称非常不言自明。让我们对其中一些感兴趣的属性进行快速的基本描述性汇总统计。</p><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">subset_attributes = [<span class="string">&#x27;residual sugar&#x27;</span>, <span class="string">&#x27;total sulfur dioxide&#x27;</span>, <span class="string">&#x27;sulphates&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;alcohol&#x27;</span>, <span class="string">&#x27;volatile acidity&#x27;</span>, <span class="string">&#x27;quality&#x27;</span>]</span><br><span class="line">rs = round(red_wine[subset_attributes].describe(),<span class="number">2</span>)</span><br><span class="line">ws = round(white_wine[subset_attributes].describe(),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">pd.concat([rs, ws], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;Red Wine Statistics&#x27;</span>, <span class="string">&#x27;White Wine Statistics&#x27;</span>])</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/按葡萄酒类型划分的基本描述统计.webp" alt=""></p><p>对比和比较不同类型葡萄酒样品的这些统计测量值非常容易。请注意某些属性的明显差异。稍后我们将在一些可视化中强调这些内容。</p><h1 id="单变量分析"><a href="#单变量分析" class="headerlink" title="单变量分析"></a>单变量分析</h1><p>单变量分析基本上是数据分析或可视化的最简单形式，我们只关心分析一个数据属性或变量并将其可视化（一维）。</p><h2 id="一维-1-D-可视化数据"><a href="#一维-1-D-可视化数据" class="headerlink" title="一维 (1-D) 可视化数据"></a>一维 (1-D) 可视化数据</h2><p>可视化所有数值数据及其分布的最快、最有效的方法之一是利用直方图 <code>pandas</code></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">wines.hist(<span class="attribute">bins</span>=15, <span class="attribute">color</span>=<span class="string">&#x27;steelblue&#x27;</span>, <span class="attribute">edgecolor</span>=<span class="string">&#x27;black&#x27;</span>, <span class="attribute">linewidth</span>=1.0,</span><br><span class="line">           <span class="attribute">xlabelsize</span>=8, <span class="attribute">ylabelsize</span>=8, <span class="attribute">grid</span>=<span class="literal">False</span>)</span><br><span class="line">plt.tight_layout(rect=(0, 0, 1.2, 1.2))</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/将属性可视化为一维数据.webp" alt=""></p><p>上图很好地了解任何属性的基本数据分布。 让我们深入了解连续数字属性之一的可视化。本质上，直方图或密度图可以很好地理解该属性的数据分布情况。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Histogram</span></span><br><span class="line">fig = plt.figure(figsize = (6,4))</span><br><span class="line">title = fig.suptitle(<span class="string">&quot;Sulphates Content in Wine&quot;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line">fig.subplots_adjust(<span class="attribute">top</span>=0.85, <span class="attribute">wspace</span>=0.3)</span><br><span class="line"></span><br><span class="line">ax = fig.add_subplot(1,1, 1)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Sulphates&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Frequency&quot;</span>)</span><br><span class="line">ax.text(1.2, 800, r<span class="string">&#x27;$\mu$=&#x27;</span>+str(round(wines[<span class="string">&#x27;sulphates&#x27;</span>].mean(),2)),</span><br><span class="line">         <span class="attribute">fontsize</span>=12)</span><br><span class="line">freq, bins, patches = ax.hist(wines[<span class="string">&#x27;sulphates&#x27;</span>], <span class="attribute">color</span>=<span class="string">&#x27;steelblue&#x27;</span>, <span class="attribute">bins</span>=15,</span><br><span class="line">                                    <span class="attribute">edgecolor</span>=<span class="string">&#x27;black&#x27;</span>, <span class="attribute">linewidth</span>=1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Density Plot</span></span><br><span class="line">fig = plt.figure(figsize = (6, 4))</span><br><span class="line">title = fig.suptitle(<span class="string">&quot;Sulphates Content in Wine&quot;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line">fig.subplots_adjust(<span class="attribute">top</span>=0.85, <span class="attribute">wspace</span>=0.3)</span><br><span class="line"></span><br><span class="line">ax1 = fig.add_subplot(1,1, 1)</span><br><span class="line">ax1.set_xlabel(<span class="string">&quot;Sulphates&quot;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&quot;Frequency&quot;</span>)</span><br><span class="line">sns.kdeplot(wines[<span class="string">&#x27;sulphates&#x27;</span>], <span class="attribute">ax</span>=ax1, <span class="attribute">shade</span>=<span class="literal">True</span>, <span class="attribute">color</span>=<span class="string">&#x27;steelblue&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/可视化一维连续数值数据.webp" alt=""></p><p>从上图可以明显看出，葡萄酒的分布存在明显的右偏<code>sulphates</code>。可视化离散的分类数据属性略有不同，条形图 是实现这一点的最有效方法之一。您也可以使用饼图，但一般来说尽量避免使用它们，特别是当不同类别的数量超过三个时。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bar Plot</span></span><br><span class="line">fig = plt.figure(figsize = (6, 4))</span><br><span class="line">title = fig.suptitle(<span class="string">&quot;Wine Quality Frequency&quot;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line">fig.subplots_adjust(<span class="attribute">top</span>=0.85, <span class="attribute">wspace</span>=0.3)</span><br><span class="line"></span><br><span class="line">ax = fig.add_subplot(1,1, 1)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Quality&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Frequency&quot;</span>)</span><br><span class="line">w_q = wines[<span class="string">&#x27;quality&#x27;</span>].value_counts()</span><br><span class="line">w_q = (list(w_q.index), list(w_q.values))</span><br><span class="line">ax.tick_params(<span class="attribute">axis</span>=<span class="string">&#x27;both&#x27;</span>, <span class="attribute">which</span>=<span class="string">&#x27;major&#x27;</span>, <span class="attribute">labelsize</span>=8.5)</span><br><span class="line">bar = ax.bar(w_q[0], w_q[1], <span class="attribute">color</span>=<span class="string">&#x27;steelblue&#x27;</span>,</span><br><span class="line">        <span class="attribute">edgecolor</span>=<span class="string">&#x27;black&#x27;</span>, <span class="attribute">linewidth</span>=1)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/可视化一维离散、分类数据.webp" alt=""></p><p>现在让我们继续研究更高维的数据。</p><h1 id="多元分析"><a href="#多元分析" class="headerlink" title="多元分析"></a>多元分析</h1><p>多变量分析是乐趣和复杂性的开始。在这里，我们分析多个数据维度或属性（2个或更多）。多变量分析不仅涉及检查分布，还涉及这些属性之间的潜在关系、模式和相关性。如有必要，您还可以根据要解决的问题利用推论统计和假设检验来检查不同属性、组等的统计显着性。</p><h2 id="二维（2-D）数据可视化"><a href="#二维（2-D）数据可视化" class="headerlink" title="二维（2-D）数据可视化"></a>二维（2-D）数据可视化</h2><p>检查不同数据属性之间的潜在关系或相关性的最佳方法之一是利用成对相关矩阵 并将其描述为热图。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Correlation Matrix Heatmap</span></span><br><span class="line">f, ax = plt.subplots(figsize=(10, 6))</span><br><span class="line">corr = wines.corr()</span><br><span class="line">hm = sns.heatmap(round(corr,2), <span class="attribute">annot</span>=<span class="literal">True</span>, <span class="attribute">ax</span>=ax, <span class="attribute">cmap</span>=<span class="string">&quot;coolwarm&quot;</span>,fmt=&#x27;.2f&#x27;,</span><br><span class="line">                 <span class="attribute">linewidths</span>=.05)</span><br><span class="line">f.subplots_adjust(<span class="attribute">top</span>=0.93)</span><br><span class="line">t= f.suptitle(<span class="string">&#x27;Wine Attributes Correlation Heatmap&#x27;</span>, <span class="attribute">fontsize</span>=14)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/使用相关热图可视化二维数据.webp" alt=""></p><p>热图中的梯度根据相关性的强度而变化，您可以清楚地看到很容易发现彼此之间具有强相关性的潜在属性。另一种可视化的方法是在感兴趣的属性之间使用成对散点图。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pair-wise Scatter Plots</span></span><br><span class="line">cols = [<span class="string">&#x27;density&#x27;</span>, <span class="string">&#x27;residual sugar&#x27;</span>, <span class="string">&#x27;total sulfur dioxide&#x27;</span>, <span class="string">&#x27;fixed acidity&#x27;</span>]</span><br><span class="line">pp = sns.pairplot(wines[cols], <span class="attribute">size</span>=1.8, <span class="attribute">aspect</span>=1.8,</span><br><span class="line">                  <span class="attribute">plot_kws</span>=dict(edgecolor=&quot;k&quot;, <span class="attribute">linewidth</span>=0.5),</span><br><span class="line">                  <span class="attribute">diag_kind</span>=<span class="string">&quot;kde&quot;</span>, <span class="attribute">diag_kws</span>=dict(shade=True))</span><br><span class="line"></span><br><span class="line">fig = pp.fig</span><br><span class="line">fig.subplots_adjust(<span class="attribute">top</span>=0.93, <span class="attribute">wspace</span>=0.3)</span><br><span class="line">t = fig.suptitle(<span class="string">&#x27;Wine Attributes Pairwise Plots&#x27;</span>, <span class="attribute">fontsize</span>=14)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/使用成对散点图可视化二维数据.webp" alt=""></p><p>根据上图，您可以看到散点图也是观察数据属性的二维潜在关系或模式的好方法。</p><blockquote><p>关于成对散点图需要注意的重要一点是这些图实际上是对称的。任何一对属性的散点图(X, Y)看起来与相同属性不同只是(Y, X)因为垂直和水平尺度不同。它不包含任何新信息。</p></blockquote><p>将多个属性的多元数据一起可视化的另一种方法是使用平行坐标。</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># Scaling <span class="keyword">attribute</span> <span class="keyword">values</span> <span class="keyword">to</span> avoid few outiers</span><br><span class="line">cols = [<span class="string">&#x27;density&#x27;</span>, <span class="string">&#x27;residual sugar&#x27;</span>, <span class="string">&#x27;total sulfur dioxide&#x27;</span>, <span class="string">&#x27;fixed acidity&#x27;</span>]</span><br><span class="line">subset_df = wines[cols]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">ss = StandardScaler()</span><br><span class="line"></span><br><span class="line">scaled_df = ss.fit_transform(subset_df)</span><br><span class="line">scaled_df = pd.DataFrame(scaled_df, <span class="keyword">columns</span>=cols)</span><br><span class="line">final_df = pd.concat([scaled_df, wines[<span class="string">&#x27;wine_type&#x27;</span>]], axis=<span class="number">1</span>)</span><br><span class="line">final_df.head()</span><br><span class="line"></span><br><span class="line"># plot parallel coordinates</span><br><span class="line"><span class="keyword">from</span> pandas.plotting <span class="keyword">import</span> parallel_coordinates</span><br><span class="line">pc = parallel_coordinates(final_df, <span class="string">&#x27;wine_type&#x27;</span>, color=(<span class="string">&#x27;#FFE888&#x27;</span>, <span class="string">&#x27;#FF9999&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/平行坐标可视化多维数据.webp" alt=""></p><p>基本上，在如上所述的可视化中，点表示为连接的线段。每条垂直线代表一个数据属性。跨越所有属性的一组完整的连接线段代表一个数据点。因此，倾向于聚集的点会显得更靠近。只要看一下，我们就可以清楚地看到红葡萄酒比白葡萄酒密度略多一些。此外，白葡萄酒的和值高于红葡萄酒，红葡萄酒的值高于。查看我们之前导出的统计表中的统计数据来验证这个假设！</p><p>让我们看一下可视化两个连续的数字属性的一些方法。散点图和联合图尤其是检查模式和关系的好方法，而且还可以查看属性的单独分布。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Scatter Plot</span></span><br><span class="line">plt.scatter(wines[<span class="string">&#x27;sulphates&#x27;</span>], wines[<span class="string">&#x27;alcohol&#x27;</span>],</span><br><span class="line">            <span class="attribute">alpha</span>=0.4, <span class="attribute">edgecolors</span>=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Sulphates&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Alcohol&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Wine Sulphates - Alcohol Content&#x27;</span>,<span class="attribute">y</span>=1.05)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Joint Plot</span></span><br><span class="line">jp = sns.jointplot(<span class="attribute">x</span>=<span class="string">&#x27;sulphates&#x27;</span>, <span class="attribute">y</span>=<span class="string">&#x27;alcohol&#x27;</span>, <span class="attribute">data</span>=wines,</span><br><span class="line">                   <span class="attribute">kind</span>=<span class="string">&#x27;reg&#x27;</span>, <span class="attribute">space</span>=0, <span class="attribute">size</span>=5, <span class="attribute">ratio</span>=4)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/使用散点图和联合图可视化二维连续数值数据.webp" alt=""></p><p>上图中左侧为散点图，右侧为联合图。正如我们提到的，您可以检查联合图中的相关性、关系以及个体分布。可视化两个离散的分类属性怎么样？一种方法是利用单独的图（子图）或方面作为分类维度之一。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Using subplots or facets along with Bar Plots</span></span><br><span class="line">fig = plt.figure(figsize = (10, 4))</span><br><span class="line">title = fig.suptitle(<span class="string">&quot;Wine Type - Quality&quot;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line">fig.subplots_adjust(<span class="attribute">top</span>=0.85, <span class="attribute">wspace</span>=0.3)</span><br><span class="line"><span class="comment"># red wine - wine quality</span></span><br><span class="line">ax1 = fig.add_subplot(1,2, 1)</span><br><span class="line">ax1.set_title(<span class="string">&quot;Red Wine&quot;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&quot;Quality&quot;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&quot;Frequency&quot;</span>)</span><br><span class="line">rw_q = red_wine[<span class="string">&#x27;quality&#x27;</span>].value_counts()</span><br><span class="line">rw_q = (list(rw_q.index), list(rw_q.values))</span><br><span class="line">ax1.set_ylim([0, 2500])</span><br><span class="line">ax1.tick_params(<span class="attribute">axis</span>=<span class="string">&#x27;both&#x27;</span>, <span class="attribute">which</span>=<span class="string">&#x27;major&#x27;</span>, <span class="attribute">labelsize</span>=8.5)</span><br><span class="line">bar1 = ax1.bar(rw_q[0], rw_q[1], <span class="attribute">color</span>=<span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">               <span class="attribute">edgecolor</span>=<span class="string">&#x27;black&#x27;</span>, <span class="attribute">linewidth</span>=1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># white wine - wine quality</span></span><br><span class="line">ax2 = fig.add_subplot(1,2, 2)</span><br><span class="line">ax2.set_title(<span class="string">&quot;White Wine&quot;</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&quot;Quality&quot;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&quot;Frequency&quot;</span>)</span><br><span class="line">ww_q = white_wine[<span class="string">&#x27;quality&#x27;</span>].value_counts()</span><br><span class="line">ww_q = (list(ww_q.index), list(ww_q.values))</span><br><span class="line">ax2.set_ylim([0, 2500])</span><br><span class="line">ax2.tick_params(<span class="attribute">axis</span>=<span class="string">&#x27;both&#x27;</span>, <span class="attribute">which</span>=<span class="string">&#x27;major&#x27;</span>, <span class="attribute">labelsize</span>=8.5)</span><br><span class="line">bar2 = ax2.bar(ww_q[0], ww_q[1], <span class="attribute">color</span>=<span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">               <span class="attribute">edgecolor</span>=<span class="string">&#x27;black&#x27;</span>, <span class="attribute">linewidth</span>=1)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/使用条形图和子图（方面）可视化二维离散分类数据.webp" alt=""></p><p>正如您所看到的，虽然这是可视化分类数据的好方法，但利用它<code>matplotlib</code> 会导致编写大量代码。另一个好方法是对单个图中的不同属性使用堆叠条形图或多个条形图。我们可以 <code>seaborn</code> 轻松地利用这一点。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Multi-bar Plot</span></span><br><span class="line">cp = sns.countplot(<span class="attribute">x</span>=<span class="string">&quot;quality&quot;</span>, <span class="attribute">hue</span>=<span class="string">&quot;wine_type&quot;</span>, <span class="attribute">data</span>=wines,</span><br><span class="line">                   palette=&#123;<span class="string">&quot;red&quot;</span>: <span class="string">&quot;#FF9999&quot;</span>, <span class="string">&quot;white&quot;</span>: <span class="string">&quot;#FFE888&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/在单个条形图中可视化二维离散、分类数据.webp" alt=""></p><p>这绝对看起来更干净，您还可以从这个单一图中轻松有效地比较不同的类别。 让我们看一下二维混合属性的可视化（本质上是数字属性和分类属性）。一种方法是使用分面/子图以及通用直方图或密度图。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># facets with histograms</span></span><br><span class="line">fig = plt.figure(figsize = (10,4))</span><br><span class="line">title = fig.suptitle(<span class="string">&quot;Sulphates Content in Wine&quot;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line">fig.subplots_adjust(<span class="attribute">top</span>=0.85, <span class="attribute">wspace</span>=0.3)</span><br><span class="line"></span><br><span class="line">ax1 = fig.add_subplot(1,2, 1)</span><br><span class="line">ax1.set_title(<span class="string">&quot;Red Wine&quot;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&quot;Sulphates&quot;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&quot;Frequency&quot;</span>)</span><br><span class="line">ax1.set_ylim([0, 1200])</span><br><span class="line">ax1.text(1.2, 800, r<span class="string">&#x27;$\mu$=&#x27;</span>+str(round(red_wine[<span class="string">&#x27;sulphates&#x27;</span>].mean(),2)),</span><br><span class="line">         <span class="attribute">fontsize</span>=12)</span><br><span class="line">r_freq, r_bins, r_patches = ax1.hist(red_wine[<span class="string">&#x27;sulphates&#x27;</span>], <span class="attribute">color</span>=<span class="string">&#x27;red&#x27;</span>, <span class="attribute">bins</span>=15,</span><br><span class="line">                                     <span class="attribute">edgecolor</span>=<span class="string">&#x27;black&#x27;</span>, <span class="attribute">linewidth</span>=1)</span><br><span class="line"></span><br><span class="line">ax2 = fig.add_subplot(1,2, 2)</span><br><span class="line">ax2.set_title(<span class="string">&quot;White Wine&quot;</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&quot;Sulphates&quot;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&quot;Frequency&quot;</span>)</span><br><span class="line">ax2.set_ylim([0, 1200])</span><br><span class="line">ax2.text(0.8, 800, r<span class="string">&#x27;$\mu$=&#x27;</span>+str(round(white_wine[<span class="string">&#x27;sulphates&#x27;</span>].mean(),2)),</span><br><span class="line">         <span class="attribute">fontsize</span>=12)</span><br><span class="line">w_freq, w_bins, w_patches = ax2.hist(white_wine[<span class="string">&#x27;sulphates&#x27;</span>], <span class="attribute">color</span>=<span class="string">&#x27;white&#x27;</span>, <span class="attribute">bins</span>=15,</span><br><span class="line">                                     <span class="attribute">edgecolor</span>=<span class="string">&#x27;black&#x27;</span>, <span class="attribute">linewidth</span>=1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># facets with density plots</span></span><br><span class="line">fig = plt.figure(figsize = (10, 4))</span><br><span class="line">title = fig.suptitle(<span class="string">&quot;Sulphates Content in Wine&quot;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line">fig.subplots_adjust(<span class="attribute">top</span>=0.85, <span class="attribute">wspace</span>=0.3)</span><br><span class="line"></span><br><span class="line">ax1 = fig.add_subplot(1,2, 1)</span><br><span class="line">ax1.set_title(<span class="string">&quot;Red Wine&quot;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&quot;Sulphates&quot;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&quot;Density&quot;</span>)</span><br><span class="line">sns.kdeplot(red_wine[<span class="string">&#x27;sulphates&#x27;</span>], <span class="attribute">ax</span>=ax1, <span class="attribute">shade</span>=<span class="literal">True</span>, <span class="attribute">color</span>=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2 = fig.add_subplot(1,2, 2)</span><br><span class="line">ax2.set_title(<span class="string">&quot;White Wine&quot;</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&quot;Sulphates&quot;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&quot;Density&quot;</span>)</span><br><span class="line">sns.kdeplot(white_wine[<span class="string">&#x27;sulphates&#x27;</span>], <span class="attribute">ax</span>=ax2, <span class="attribute">shade</span>=<span class="literal">True</span>, <span class="attribute">color</span>=<span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/利用面和直方图_密度图在二维中可视化混合属性.webp" alt=""></p><p>虽然这很好，但我们再次拥有大量样板代码，我们可以通过利用这些样板代码来避免这些代码 <code>seaborn</code> ，甚至可以在一张图表中绘制图表。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Using multiple Histograms</span></span><br><span class="line">fig = plt.figure(figsize = (6, 4))</span><br><span class="line">title = fig.suptitle(<span class="string">&quot;Sulphates Content in Wine&quot;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line">fig.subplots_adjust(<span class="attribute">top</span>=0.85, <span class="attribute">wspace</span>=0.3)</span><br><span class="line">ax = fig.add_subplot(1,1, 1)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Sulphates&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Frequency&quot;</span>)</span><br><span class="line"></span><br><span class="line">g = sns.FacetGrid(wines, <span class="attribute">hue</span>=<span class="string">&#x27;wine_type&#x27;</span>, palette=&#123;<span class="string">&quot;red&quot;</span>: <span class="string">&quot;r&quot;</span>, <span class="string">&quot;white&quot;</span>: <span class="string">&quot;y&quot;</span>&#125;)</span><br><span class="line">g.map(sns.distplot, <span class="string">&#x27;sulphates&#x27;</span>, <span class="attribute">kde</span>=<span class="literal">False</span>, <span class="attribute">bins</span>=15, <span class="attribute">ax</span>=ax)</span><br><span class="line">ax.legend(<span class="attribute">title</span>=<span class="string">&#x27;Wine Type&#x27;</span>)</span><br><span class="line">plt.close(2)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/利用多个直方图获取二维混合属性.webp" alt=""></p><p>您可以看到上面生成的图清晰简洁，我们可以轻松地比较各个分布。除此之外，箱线图是根据分类属性中的不同值有效描述数值数据组的另一种方法。箱线图是了解数据中的四分位值以及潜在异常值的好方法。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Box Plots</span></span><br><span class="line">f, (ax) = plt.subplots(1, 1, figsize=(12, 4))</span><br><span class="line">f.suptitle(<span class="string">&#x27;Wine Quality - Alcohol Content&#x27;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line"></span><br><span class="line">sns.boxplot(<span class="attribute">x</span>=<span class="string">&quot;quality&quot;</span>, <span class="attribute">y</span>=<span class="string">&quot;alcohol&quot;</span>, <span class="attribute">data</span>=wines,  <span class="attribute">ax</span>=ax)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Wine Quality&quot;</span>,size = 12,<span class="attribute">alpha</span>=0.8)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Wine Alcohol %&quot;</span>,size = 12,<span class="attribute">alpha</span>=0.8)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/箱线图作为二维混合属性的有效表示.webp" alt=""></p><p>另一种类似的可视化是小提琴图，这是使用核密度图（描绘不同值下数据的概率密度）可视化分组数值数据的另一种有效方法。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Violin Plots</span></span><br><span class="line">f, (ax) = plt.subplots(1, 1, figsize=(12, 4))</span><br><span class="line">f.suptitle(<span class="string">&#x27;Wine Quality - Sulphates Content&#x27;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line"></span><br><span class="line">sns.violinplot(<span class="attribute">x</span>=<span class="string">&quot;quality&quot;</span>, <span class="attribute">y</span>=<span class="string">&quot;sulphates&quot;</span>, <span class="attribute">data</span>=wines,  <span class="attribute">ax</span>=ax)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Wine Quality&quot;</span>,size = 12,<span class="attribute">alpha</span>=0.8)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Wine Sulphates&quot;</span>,size = 12,<span class="attribute">alpha</span>=0.8)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/小提琴图作为二维混合属性的有效表示.webp" alt=""></p><p><code>quality</code>您可以清楚地看到上面不同葡萄酒类别的葡萄酒密度图<code>sulphate</code>。</p><blockquote><p>将数据可视化到二维非常简单，但随着维度（属性）数量开始增加，变得越来越复杂。原因是我们受到显示媒介和环境的二维约束。</p><p>对于三维数据，我们可以通过在图表中采用z 轴或利用子图和面来引入虚假的深度概念。</p><p>然而，对于高于三维的数据，将其可视化变得更加困难。超越三维的最佳方法是使用绘图面、颜色、形状、大小、深度等。您还可以通过为其他属性随时间变化绘制动画图来使用时间作为维度（考虑时间是数据中的维度）。看看Hans Roslin 的精彩演讲，了解同样的想法！</p></blockquote><h2 id="三维-3-D-可视化数据"><a href="#三维-3-D-可视化数据" class="headerlink" title="三维 (3-D) 可视化数据"></a>三维 (3-D) 可视化数据</h2><p>考虑数据中的三个属性或维度，我们可以通过考虑成对散点图并引入颜色 或色调的概念来分离分类维度中的值，从而将它们可视化。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Scatter Plot with Hue for visualizing data in 3-D</span></span><br><span class="line">cols = [<span class="string">&#x27;density&#x27;</span>, <span class="string">&#x27;residual sugar&#x27;</span>, <span class="string">&#x27;total sulfur dioxide&#x27;</span>, <span class="string">&#x27;fixed acidity&#x27;</span>, <span class="string">&#x27;wine_type&#x27;</span>]</span><br><span class="line">pp = sns.pairplot(wines[cols], <span class="attribute">hue</span>=<span class="string">&#x27;wine_type&#x27;</span>, <span class="attribute">size</span>=1.8, <span class="attribute">aspect</span>=1.8,</span><br><span class="line">                  palette=&#123;<span class="string">&quot;red&quot;</span>: <span class="string">&quot;#FF9999&quot;</span>, <span class="string">&quot;white&quot;</span>: <span class="string">&quot;#FFE888&quot;</span>&#125;,</span><br><span class="line">                  <span class="attribute">plot_kws</span>=dict(edgecolor=&quot;black&quot;, <span class="attribute">linewidth</span>=0.5))</span><br><span class="line">fig = pp.fig</span><br><span class="line">fig.subplots_adjust(<span class="attribute">top</span>=0.93, <span class="attribute">wspace</span>=0.3)</span><br><span class="line">t = fig.suptitle(<span class="string">&#x27;Wine Attributes Pairwise Plots&#x27;</span>, <span class="attribute">fontsize</span>=14)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/使用散点图和色调（颜色）可视化三维数据.webp" alt=""></p><p>上图使您能够检查相关性和模式，并对葡萄酒组进行比较。我们可以清楚地看到<code>total sulfur dioxide</code>，与红葡萄酒相比，白葡萄酒<code>residual sugar</code>的含量更高。</p><p>让我们看看可视化三个连续数字属性的策略。一种方法是将两个维度表示为常规长度 （x轴）和宽度（y轴），并采用深度（z轴）的概念作为第三个维度。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualizing 3-D numeric data with Scatter Plots</span></span><br><span class="line"><span class="comment"># length, breadth and depth</span></span><br><span class="line">fig = plt.figure(figsize=(8, 6))</span><br><span class="line">ax = fig.add_subplot(111, <span class="attribute">projection</span>=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">xs = wines[<span class="string">&#x27;residual sugar&#x27;</span>]</span><br><span class="line">ys = wines[<span class="string">&#x27;fixed acidity&#x27;</span>]</span><br><span class="line">zs = wines[<span class="string">&#x27;alcohol&#x27;</span>]</span><br><span class="line">ax.scatter(xs, ys, zs, <span class="attribute">s</span>=50, <span class="attribute">alpha</span>=0.6, <span class="attribute">edgecolors</span>=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Residual Sugar&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Fixed Acidity&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;Alcohol&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/通过引入深度概念可视化三维数值数据.webp" alt=""></p><p>我们仍然可以利用常规的二维轴，并引入尺寸的概念作为第三维（本质上是气泡图），其中点的大小表示第三维的数量。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualizing 3-D numeric data with a bubble chart</span></span><br><span class="line"><span class="comment"># length, breadth and size</span></span><br><span class="line">plt.scatter(wines[<span class="string">&#x27;fixed acidity&#x27;</span>], wines[<span class="string">&#x27;alcohol&#x27;</span>], <span class="attribute">s</span>=wines[<span class="string">&#x27;residual sugar&#x27;</span>]<span class="number">*25</span>,</span><br><span class="line">            <span class="attribute">alpha</span>=0.4, <span class="attribute">edgecolors</span>=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Fixed Acidity&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Alcohol&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Wine Alcohol Content - Fixed Acidity - Residual Sugar&#x27;</span>,<span class="attribute">y</span>=1.05)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/通过引入大小概念可视化三维数值数据.webp" alt=""></p><p>因此，您可以看到上面的图表不是传统的散点图，而是更多的气泡图，其点大小（气泡）根据 的数量而变化residual sugar。当然，您并不总是会在数据中找到明确的模式，就像在本例中一样，我们看到其他两个维度的大小不同。为了可视化三个离散的分类属性，虽然我们可以使用传统的条形图，但我们可以利用色调以及面或子图的概念来支持额外的第三个维度。该seaborn 框架帮助我们将代码保持在最低限度并有效地绘制出来。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualizing 3-D categorical data using bar plots</span></span><br><span class="line"><span class="comment"># leveraging the concepts of hue and facets</span></span><br><span class="line">fc = sns.factorplot(<span class="attribute">x</span>=<span class="string">&quot;quality&quot;</span>, <span class="attribute">hue</span>=<span class="string">&quot;wine_type&quot;</span>, <span class="attribute">col</span>=<span class="string">&quot;quality_label&quot;</span>,</span><br><span class="line">                    <span class="attribute">data</span>=wines, <span class="attribute">kind</span>=<span class="string">&quot;count&quot;</span>,</span><br><span class="line">                    palette=&#123;<span class="string">&quot;red&quot;</span>: <span class="string">&quot;#FF9999&quot;</span>, <span class="string">&quot;white&quot;</span>: <span class="string">&quot;#FFE888&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/通过引入色调和面的概念来可视化三维分类数据.webp" alt=""></p><p>上图清楚地显示了与每个维度相关的频率，您可以看到这对于理解相关见解是多么容易和有效。考虑到三个混合属性的可视化，我们可以使用色调的概念来分隔类别属性之一中的组，同时使用散点图等传统可视化来可视化数字属性的二维。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualizing 3-D mix data using scatter plots</span></span><br><span class="line"><span class="comment"># leveraging the concepts of hue for categorical dimension</span></span><br><span class="line">jp = sns.pairplot(wines, x_vars=[<span class="string">&quot;sulphates&quot;</span>], y_vars=[<span class="string">&quot;alcohol&quot;</span>], <span class="attribute">size</span>=4.5,</span><br><span class="line">                  <span class="attribute">hue</span>=<span class="string">&quot;wine_type&quot;</span>, palette=&#123;<span class="string">&quot;red&quot;</span>: <span class="string">&quot;#FF9999&quot;</span>, <span class="string">&quot;white&quot;</span>: <span class="string">&quot;#FFE888&quot;</span>&#125;,</span><br><span class="line">                  <span class="attribute">plot_kws</span>=dict(edgecolor=&quot;k&quot;, <span class="attribute">linewidth</span>=0.5))</span><br><span class="line"></span><br><span class="line"><span class="comment"># we can also view relationships\correlations as needed</span></span><br><span class="line">lp = sns.lmplot(<span class="attribute">x</span>=<span class="string">&#x27;sulphates&#x27;</span>, <span class="attribute">y</span>=<span class="string">&#x27;alcohol&#x27;</span>, <span class="attribute">hue</span>=<span class="string">&#x27;wine_type&#x27;</span>,</span><br><span class="line">                palette=&#123;<span class="string">&quot;red&quot;</span>: <span class="string">&quot;#FF9999&quot;</span>, <span class="string">&quot;white&quot;</span>: <span class="string">&quot;#FFE888&quot;</span>&#125;,</span><br><span class="line">                <span class="attribute">data</span>=wines, <span class="attribute">fit_reg</span>=<span class="literal">True</span>, <span class="attribute">legend</span>=<span class="literal">True</span>,</span><br><span class="line">                <span class="attribute">scatter_kws</span>=dict(edgecolor=&quot;k&quot;, <span class="attribute">linewidth</span>=0.5))</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/利用散点图和色调概念在三维空间中可视化混合属性.webp" alt=""></p><p>因此，色调是类别或组的良好分隔符，虽然如上所述没有相关性或相关性非常弱，但我们仍然可以从这些图中了解到，与白葡萄酒相比，红葡萄酒的相关性<code>sulphates</code> 略高。您还可以使用核密度图来代替散点图来了解三个维度的数据。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualizing 3-D mix data using kernel density plots</span></span><br><span class="line"><span class="comment"># leveraging the concepts of hue for categorical dimension</span></span><br><span class="line">ax = sns.kdeplot(white_wine[<span class="string">&#x27;sulphates&#x27;</span>], white_wine[<span class="string">&#x27;alcohol&#x27;</span>],</span><br><span class="line">                  <span class="attribute">cmap</span>=<span class="string">&quot;YlOrBr&quot;</span>, <span class="attribute">shade</span>=<span class="literal">True</span>, <span class="attribute">shade_lowest</span>=<span class="literal">False</span>)</span><br><span class="line">ax = sns.kdeplot(red_wine[<span class="string">&#x27;sulphates&#x27;</span>], red_wine[<span class="string">&#x27;alcohol&#x27;</span>],</span><br><span class="line">                  <span class="attribute">cmap</span>=<span class="string">&quot;Reds&quot;</span>, <span class="attribute">shade</span>=<span class="literal">True</span>, <span class="attribute">shade_lowest</span>=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/利用核密度图和色调概念在三维空间中可视化混合属性.webp" alt=""></p><p>与白葡萄酒相比，红葡萄酒样品中的含量是相当明显且符合预期的。您还可以根据色调强度查看密度浓度。 如果我们在三个维度中处理多个分类属性，我们可以使用色调和其中一个常规轴来可视化数据，并使用箱线图或小提琴图等可视化来可视化不同组的数据。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualizing 3-D mix data using violin plots</span></span><br><span class="line"><span class="comment"># leveraging the concepts of hue and axes for &gt; 1 categorical dimensions</span></span><br><span class="line">f, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 4))</span><br><span class="line">f.suptitle(<span class="string">&#x27;Wine Type - Quality - Acidity&#x27;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line"></span><br><span class="line">sns.violinplot(<span class="attribute">x</span>=<span class="string">&quot;quality&quot;</span>, <span class="attribute">y</span>=<span class="string">&quot;volatile acidity&quot;</span>,</span><br><span class="line">               <span class="attribute">data</span>=wines, <span class="attribute">inner</span>=<span class="string">&quot;quart&quot;</span>, <span class="attribute">linewidth</span>=1.3,ax=ax1)</span><br><span class="line">ax1.set_xlabel(<span class="string">&quot;Wine Quality&quot;</span>,size = 12,<span class="attribute">alpha</span>=0.8)</span><br><span class="line">ax1.set_ylabel(<span class="string">&quot;Wine Volatile Acidity&quot;</span>,size = 12,<span class="attribute">alpha</span>=0.8)</span><br><span class="line"></span><br><span class="line">sns.violinplot(<span class="attribute">x</span>=<span class="string">&quot;quality&quot;</span>, <span class="attribute">y</span>=<span class="string">&quot;volatile acidity&quot;</span>, <span class="attribute">hue</span>=<span class="string">&quot;wine_type&quot;</span>,</span><br><span class="line">               <span class="attribute">data</span>=wines, <span class="attribute">split</span>=<span class="literal">True</span>, <span class="attribute">inner</span>=<span class="string">&quot;quart&quot;</span>, <span class="attribute">linewidth</span>=1.3,</span><br><span class="line">               palette=&#123;<span class="string">&quot;red&quot;</span>: <span class="string">&quot;#FF9999&quot;</span>, <span class="string">&quot;white&quot;</span>: <span class="string">&quot;white&quot;</span>&#125;, <span class="attribute">ax</span>=ax2)</span><br><span class="line">ax2.set_xlabel(<span class="string">&quot;Wine Quality&quot;</span>,size = 12,<span class="attribute">alpha</span>=0.8)</span><br><span class="line">ax2.set_ylabel(<span class="string">&quot;Wine Volatile Acidity&quot;</span>,size = 12,<span class="attribute">alpha</span>=0.8)</span><br><span class="line">l = plt.legend(<span class="attribute">loc</span>=<span class="string">&#x27;upper right&#x27;</span>, <span class="attribute">title</span>=<span class="string">&#x27;Wine Type&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/利用分割小提琴图和色调概念在三维空间中可视化混合属性.webp" alt=""></p><p>在上图中，我们可以看到，在右侧图的 3D 可视化中，我们<code>quality</code> 在 x 轴上表示葡萄酒，并将其<code>wine_type</code>表示为色调。我们可以清楚地看到一些有趣的见解，例如红葡萄酒<code>volatile acidity</code> 的含量高于白葡萄酒。 您还可以考虑使用箱线图以类似的方式表示具有多个分类变量的混合属性。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualizing 3-D mix data using box plots</span></span><br><span class="line"><span class="comment"># leveraging the concepts of hue and axes for &gt; 1 categorical dimensions</span></span><br><span class="line">f, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 4))</span><br><span class="line">f.suptitle(<span class="string">&#x27;Wine Type - Quality - Alcohol Content&#x27;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line"></span><br><span class="line">sns.boxplot(<span class="attribute">x</span>=<span class="string">&quot;quality&quot;</span>, <span class="attribute">y</span>=<span class="string">&quot;alcohol&quot;</span>, <span class="attribute">hue</span>=<span class="string">&quot;wine_type&quot;</span>,</span><br><span class="line">               <span class="attribute">data</span>=wines, palette=&#123;<span class="string">&quot;red&quot;</span>: <span class="string">&quot;#FF9999&quot;</span>, <span class="string">&quot;white&quot;</span>: <span class="string">&quot;white&quot;</span>&#125;, <span class="attribute">ax</span>=ax1)</span><br><span class="line">ax1.set_xlabel(<span class="string">&quot;Wine Quality&quot;</span>,size = 12,<span class="attribute">alpha</span>=0.8)</span><br><span class="line">ax1.set_ylabel(<span class="string">&quot;Wine Alcohol %&quot;</span>,size = 12,<span class="attribute">alpha</span>=0.8)</span><br><span class="line"></span><br><span class="line">sns.boxplot(<span class="attribute">x</span>=<span class="string">&quot;quality_label&quot;</span>, <span class="attribute">y</span>=<span class="string">&quot;alcohol&quot;</span>, <span class="attribute">hue</span>=<span class="string">&quot;wine_type&quot;</span>,</span><br><span class="line">               <span class="attribute">data</span>=wines, palette=&#123;<span class="string">&quot;red&quot;</span>: <span class="string">&quot;#FF9999&quot;</span>, <span class="string">&quot;white&quot;</span>: <span class="string">&quot;white&quot;</span>&#125;, <span class="attribute">ax</span>=ax2)</span><br><span class="line">ax2.set_xlabel(<span class="string">&quot;Wine Quality Class&quot;</span>,size = 12,<span class="attribute">alpha</span>=0.8)</span><br><span class="line">ax2.set_ylabel(<span class="string">&quot;Wine Alcohol %&quot;</span>,size = 12,<span class="attribute">alpha</span>=0.8)</span><br><span class="line">l = plt.legend(<span class="attribute">loc</span>=<span class="string">&#x27;best&#x27;</span>, <span class="attribute">title</span>=<span class="string">&#x27;Wine Type&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/利用箱线图和色调概念在三维空间中可视化混合属性.webp" alt=""></p><p>我们可以看到，无论是对于<code>quality</code> 还是<code>quality_label</code> 属性，葡萄酒的<code>alcohol</code> 含量随着质量的提高而增加。此外，根据质量等级，与白葡萄酒相比，红葡萄酒的中值含量往往略高。然而，如果我们检查质量评级，我们可以看到，对于评级较低的葡萄酒（3 和 4），白葡萄酒的中值含量高于红葡萄酒样品。除此之外，与白葡萄酒相比，红葡萄酒的中位含量似乎略高。</p><h2 id="在四个维度-4-D-中可视化数据"><a href="#在四个维度-4-D-中可视化数据" class="headerlink" title="在四个维度 (4-D) 中可视化数据"></a>在四个维度 (4-D) 中可视化数据</h2><p>根据我们之前的讨论，我们利用图表的各个组件可视化多个维度。以四个维度可视化数据的一种方法是在散点图等传统绘图中使用深度和色调作为特定数据维度。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualizing 4-D mix data using scatter plots</span></span><br><span class="line"><span class="comment"># leveraging the concepts of hue and depth</span></span><br><span class="line">fig = plt.figure(figsize=(8, 6))</span><br><span class="line">t = fig.suptitle(<span class="string">&#x27;Wine Residual Sugar - Alcohol Content - Acidity - Type&#x27;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line">ax = fig.add_subplot(111, <span class="attribute">projection</span>=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">xs = list(wines[<span class="string">&#x27;residual sugar&#x27;</span>])</span><br><span class="line">ys = list(wines[<span class="string">&#x27;alcohol&#x27;</span>])</span><br><span class="line">zs = list(wines[<span class="string">&#x27;fixed acidity&#x27;</span>])</span><br><span class="line">data_points = [(x, y, z) <span class="keyword">for</span> x, y, z <span class="keyword">in</span> zip(xs, ys, zs)]</span><br><span class="line">colors = [<span class="string">&#x27;red&#x27;</span> <span class="keyword">if</span> wt == <span class="string">&#x27;red&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;yellow&#x27;</span> <span class="keyword">for</span> wt <span class="keyword">in</span> list(wines[<span class="string">&#x27;wine_type&#x27;</span>])]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data, color <span class="keyword">in</span> zip(data_points, colors):</span><br><span class="line">    x, y, z = data</span><br><span class="line">    ax.scatter(x, y, z, <span class="attribute">alpha</span>=0.4, <span class="attribute">c</span>=color, <span class="attribute">edgecolors</span>=<span class="string">&#x27;none&#x27;</span>, <span class="attribute">s</span>=30)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Residual Sugar&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Alcohol&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;Fixed Acidity&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/利用散点图以及色调和深度的概念在四维中可视化数据.webp" alt=""></p><p>该 <code>wine_type</code> 属性由色调表示，从上图可以明显看出。此外，虽然由于绘图的复杂性，解释这些可视化开始变得困难，但您仍然可以收集见解，例如红葡萄酒<code>fixed acidity</code>的较高和白葡萄酒的较高。当然，如果和之间存在某种关联，我们可能会看到逐渐增加或减少的数据点平面显示出某种趋势。</p><p>另一种策略是保留二维图，但使用色调和数据点大小作为数据维度。通常，这将是一个类似于我们之前想象的气泡图。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualizing 4-D mix data using bubble plots</span></span><br><span class="line"><span class="comment"># leveraging the concepts of hue and size</span></span><br><span class="line">size = wines[<span class="string">&#x27;residual sugar&#x27;</span>]<span class="number">*25</span></span><br><span class="line">fill_colors = [<span class="string">&#x27;#FF9999&#x27;</span> <span class="keyword">if</span> <span class="attribute">wt</span>==&#x27;red&#x27; <span class="keyword">else</span> <span class="string">&#x27;#FFE888&#x27;</span> <span class="keyword">for</span> wt <span class="keyword">in</span> list(wines[<span class="string">&#x27;wine_type&#x27;</span>])]</span><br><span class="line">edge_colors = [<span class="string">&#x27;red&#x27;</span> <span class="keyword">if</span> <span class="attribute">wt</span>==&#x27;red&#x27; <span class="keyword">else</span> <span class="string">&#x27;orange&#x27;</span> <span class="keyword">for</span> wt <span class="keyword">in</span> list(wines[<span class="string">&#x27;wine_type&#x27;</span>])]</span><br><span class="line"></span><br><span class="line">plt.scatter(wines[<span class="string">&#x27;fixed acidity&#x27;</span>], wines[<span class="string">&#x27;alcohol&#x27;</span>], <span class="attribute">s</span>=size,</span><br><span class="line">            <span class="attribute">alpha</span>=0.4, <span class="attribute">color</span>=fill_colors, <span class="attribute">edgecolors</span>=edge_colors)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Fixed Acidity&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Alcohol&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Wine Alcohol Content - Fixed Acidity - Residual Sugar - Type&#x27;</span>,<span class="attribute">y</span>=1.05)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/利用气泡图以及色调和大小的概念在四维中可视化数据.webp" alt=""></p><p>我们用色调来表示 <code>wine_type</code> ，用数据点大小来表示<code>residual sugar</code>。我们确实看到了与上一张图表中观察到的类似模式，白葡萄酒的气泡尺寸较大，通常表明白葡萄酒<code>residual sugar</code>的值高于红葡萄酒。 如果我们要表示两个以上的分类属性，我们可以重用利用色调和面的概念来描述这些属性，并使用散点图等常规图来表示数字属性。让我们看几个例子。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualizing 4-D mix data using scatter plots</span></span><br><span class="line"><span class="comment"># leveraging the concepts of hue and facets for &gt; 1 categorical attributes</span></span><br><span class="line">g = sns.FacetGrid(wines, <span class="attribute">col</span>=<span class="string">&quot;wine_type&quot;</span>, <span class="attribute">hue</span>=<span class="string">&#x27;quality_label&#x27;</span>,</span><br><span class="line">                  col_order=[<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;white&#x27;</span>], hue_order=[<span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;medium&#x27;</span>, <span class="string">&#x27;high&#x27;</span>],</span><br><span class="line">                  <span class="attribute">aspect</span>=1.2, <span class="attribute">size</span>=3.5, <span class="attribute">palette</span>=sns.light_palette(&#x27;navy&#x27;, 4)[1:])</span><br><span class="line">g.map(plt.scatter, <span class="string">&quot;volatile acidity&quot;</span>, <span class="string">&quot;alcohol&quot;</span>, <span class="attribute">alpha</span>=0.9,</span><br><span class="line">      <span class="attribute">edgecolor</span>=<span class="string">&#x27;white&#x27;</span>, <span class="attribute">linewidth</span>=0.5, <span class="attribute">s</span>=100)</span><br><span class="line">fig = g.fig</span><br><span class="line">fig.subplots_adjust(<span class="attribute">top</span>=0.8, <span class="attribute">wspace</span>=0.3)</span><br><span class="line">fig.suptitle(<span class="string">&#x27;Wine Type - Alcohol - Quality - Acidity&#x27;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line">l = g.add_legend(<span class="attribute">title</span>=<span class="string">&#x27;Wine Quality Class&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/利用散点图以及色调和面的概念在四维中可视化数据.webp" alt=""></p><p>我们可以轻松发现多种模式，这一事实验证了这种可视化的有效性。白葡萄酒volatile acidity的酸度较低，优质葡萄酒的酸度也较低。同样根据白葡萄酒样品，高质量的葡萄酒具有较高的水平，而低质量的葡萄酒具有最低的水平！</p><h2 id="五维-5-D-可视化数据"><a href="#五维-5-D-可视化数据" class="headerlink" title="五维 (5-D) 可视化数据"></a>五维 (5-D) 可视化数据</h2><p>再次遵循与上一节类似的策略，为了在五个维度上可视化数据，我们利用各种绘图组件。除了表示其他两个维度的常规轴之外，让我们使用深度、色调和大小来表示三个数据维度。由于我们使用大小的概念，因此我们基本上将绘制三维气泡图。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualizing 5-D mix data using bubble charts</span></span><br><span class="line"><span class="comment"># leveraging the concepts of hue, size and depth</span></span><br><span class="line">fig = plt.figure(figsize=(8, 6))</span><br><span class="line">ax = fig.add_subplot(111, <span class="attribute">projection</span>=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">t = fig.suptitle(<span class="string">&#x27;Wine Residual Sugar - Alcohol Content - Acidity - Total Sulfur Dioxide - Type&#x27;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line"></span><br><span class="line">xs = list(wines[<span class="string">&#x27;residual sugar&#x27;</span>])</span><br><span class="line">ys = list(wines[<span class="string">&#x27;alcohol&#x27;</span>])</span><br><span class="line">zs = list(wines[<span class="string">&#x27;fixed acidity&#x27;</span>])</span><br><span class="line">data_points = [(x, y, z) <span class="keyword">for</span> x, y, z <span class="keyword">in</span> zip(xs, ys, zs)]</span><br><span class="line"></span><br><span class="line">ss = list(wines[<span class="string">&#x27;total sulfur dioxide&#x27;</span>])</span><br><span class="line">colors = [<span class="string">&#x27;red&#x27;</span> <span class="keyword">if</span> wt == <span class="string">&#x27;red&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;yellow&#x27;</span> <span class="keyword">for</span> wt <span class="keyword">in</span> list(wines[<span class="string">&#x27;wine_type&#x27;</span>])]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data, color, size <span class="keyword">in</span> zip(data_points, colors, ss):</span><br><span class="line">    x, y, z = data</span><br><span class="line">    ax.scatter(x, y, z, <span class="attribute">alpha</span>=0.4, <span class="attribute">c</span>=color, <span class="attribute">edgecolors</span>=<span class="string">&#x27;none&#x27;</span>, <span class="attribute">s</span>=size)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Residual Sugar&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Alcohol&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;Fixed Acidity&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/利用气泡图以及色调、深度和大小的概念以五维方式可视化数据.webp" alt=""></p><p>该图表描绘了我们在上一节中讨论的相同模式和见解。然而，我们也可以看到，根据所代表的点大小<code>total sulfur dioxide</code>，白葡萄酒的<code>total sulfur dioxide</code>含量高于红葡萄酒。</p><p>除了深度之外，我们还可以使用构面和色调来表示这五个数据维度中的多个分类属性。表示大小的属性之一可以是数字（连续）甚至是分类（但我们可能需要用数据点大小的数字来表示）。虽然由于缺乏分类属性，我们没有在这里描述这一点，但请随意在您自己的数据集上尝试一下。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualizing 5-D mix data using bubble charts</span></span><br><span class="line"><span class="comment"># leveraging the concepts of hue, size and facets</span></span><br><span class="line">g = sns.FacetGrid(wines, <span class="attribute">col</span>=<span class="string">&quot;wine_type&quot;</span>, <span class="attribute">hue</span>=<span class="string">&#x27;quality_label&#x27;</span>,</span><br><span class="line">                  col_order=[<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;white&#x27;</span>], hue_order=[<span class="string">&#x27;low&#x27;</span>, <span class="string">&#x27;medium&#x27;</span>, <span class="string">&#x27;high&#x27;</span>],</span><br><span class="line">                  <span class="attribute">aspect</span>=1.2, <span class="attribute">size</span>=3.5, <span class="attribute">palette</span>=sns.light_palette(&#x27;black&#x27;, 4)[1:])</span><br><span class="line">g.map(plt.scatter, <span class="string">&quot;residual sugar&quot;</span>, <span class="string">&quot;alcohol&quot;</span>, <span class="attribute">alpha</span>=0.8,</span><br><span class="line">      <span class="attribute">edgecolor</span>=<span class="string">&#x27;white&#x27;</span>, <span class="attribute">linewidth</span>=0.5, <span class="attribute">s</span>=wines[<span class="string">&#x27;total sulfur dioxide&#x27;</span>]<span class="number">*2</span>)</span><br><span class="line">fig = g.fig</span><br><span class="line">fig.subplots_adjust(<span class="attribute">top</span>=0.8, <span class="attribute">wspace</span>=0.3)</span><br><span class="line">fig.suptitle(<span class="string">&#x27;Wine Type - Sulfur Dioxide - Residual Sugar - Alcohol - Quality&#x27;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line">l = g.add_legend(<span class="attribute">title</span>=<span class="string">&#x27;Wine Quality Class&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/利用气泡图以及色调、面和大小的概念可视化五维数据.webp" alt=""></p><p>这基本上是可视化我们之前绘制的五个维度的同一图的另一种方法。虽然在查看我们之前绘制的图时，深度的附加维度可能会让许多人感到困惑，但由于面的优势，该图仍然有效地保留在二维平面上，因此通常更有效且易于解释。</p><h2 id="六维-6-D-可视化数据"><a href="#六维-6-D-可视化数据" class="headerlink" title="六维 (6-D) 可视化数据"></a>六维 (6-D) 可视化数据</h2><p>现在我们已经玩得很开心了（我希望如此！），让我们在可视化中添加另一个数据维度。除了常规的两个轴之外，我们还将利用深度、色调、大小和形状来描述所有六个数据维度。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualizing 6-D mix data using scatter charts</span></span><br><span class="line"><span class="comment"># leveraging the concepts of hue, size, depth and shape</span></span><br><span class="line">fig = plt.figure(figsize=(8, 6))</span><br><span class="line">t = fig.suptitle(<span class="string">&#x27;Wine Residual Sugar - Alcohol Content - Acidity - Total Sulfur Dioxide - Type - Quality&#x27;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line">ax = fig.add_subplot(111, <span class="attribute">projection</span>=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">xs = list(wines[<span class="string">&#x27;residual sugar&#x27;</span>])</span><br><span class="line">ys = list(wines[<span class="string">&#x27;alcohol&#x27;</span>])</span><br><span class="line">zs = list(wines[<span class="string">&#x27;fixed acidity&#x27;</span>])</span><br><span class="line">data_points = [(x, y, z) <span class="keyword">for</span> x, y, z <span class="keyword">in</span> zip(xs, ys, zs)]</span><br><span class="line"></span><br><span class="line">ss = list(wines[<span class="string">&#x27;total sulfur dioxide&#x27;</span>])</span><br><span class="line">colors = [<span class="string">&#x27;red&#x27;</span> <span class="keyword">if</span> wt == <span class="string">&#x27;red&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;yellow&#x27;</span> <span class="keyword">for</span> wt <span class="keyword">in</span> list(wines[<span class="string">&#x27;wine_type&#x27;</span>])]</span><br><span class="line">markers = [<span class="string">&#x27;,&#x27;</span> <span class="keyword">if</span> q == <span class="string">&#x27;high&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;x&#x27;</span> <span class="keyword">if</span> q == <span class="string">&#x27;medium&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;o&#x27;</span> <span class="keyword">for</span> q <span class="keyword">in</span> list(wines[<span class="string">&#x27;quality_label&#x27;</span>])]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data, color, size, mark <span class="keyword">in</span> zip(data_points, colors, ss, markers):</span><br><span class="line">    x, y, z = data</span><br><span class="line">    ax.scatter(x, y, z, <span class="attribute">alpha</span>=0.4, <span class="attribute">c</span>=color, <span class="attribute">edgecolors</span>=<span class="string">&#x27;none&#x27;</span>, <span class="attribute">s</span>=size, <span class="attribute">marker</span>=mark)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Residual Sugar&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Alcohol&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;Fixed Acidity&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/利用散点图以及色调、深度、形状和大小的概念以六维方式可视化数据.webp" alt=""></p><p>哇，一个情节中有六个维度！我们用形状quality_label来描述葡萄酒，高品质（方形像素）、中品质（X 标记）和低品质（圆圈）的葡萄酒。由色调表示，由深度和数据点大小表示内容。</p><p>解释这一点可能看起来有点费力，但在尝试了解正在发生的情况时一次考虑几个组件。</p><p>1) 考虑到形状和y 轴，与低品质葡萄酒相比，我们拥有更高水平的高品质和中品质葡萄酒。alcohol</p><p>2) 考虑到颜色和大小，与红葡萄酒相比，白葡萄酒total sulfur dioxide的含量更高。</p><p>3) 考虑到深度和色调，与红葡萄酒相比，我们的白葡萄酒含量较低。fixed acidity</p><p>4) 考虑到色调和x 轴，与白葡萄酒相比，我们的红葡萄酒的含量较低。residual sugar</p><p>5) 考虑到色调和形状，与红葡萄酒相比，白葡萄酒似乎具有更高品质的葡萄酒（可能是由于白葡萄酒的样本量较大）。</p><p>我们还可以通过删除深度组件来构建 6 维可视化，并使用构面代替分类属性。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visualizing 6-D mix data using scatter charts</span></span><br><span class="line"><span class="comment"># leveraging the concepts of hue, facets and size</span></span><br><span class="line">g = sns.FacetGrid(wines, <span class="attribute">row</span>=<span class="string">&#x27;wine_type&#x27;</span>, <span class="attribute">col</span>=<span class="string">&quot;quality&quot;</span>, <span class="attribute">hue</span>=<span class="string">&#x27;quality_label&#x27;</span>, <span class="attribute">size</span>=4)</span><br><span class="line">g.map(plt.scatter,  <span class="string">&quot;residual sugar&quot;</span>, <span class="string">&quot;alcohol&quot;</span>, <span class="attribute">alpha</span>=0.5,</span><br><span class="line">      <span class="attribute">edgecolor</span>=<span class="string">&#x27;k&#x27;</span>, <span class="attribute">linewidth</span>=0.5, <span class="attribute">s</span>=wines[<span class="string">&#x27;total sulfur dioxide&#x27;</span>]<span class="number">*2</span>)</span><br><span class="line">fig = g.fig</span><br><span class="line">fig.set_size_inches(18, 8)</span><br><span class="line">fig.subplots_adjust(<span class="attribute">top</span>=0.85, <span class="attribute">wspace</span>=0.3)</span><br><span class="line">fig.suptitle(<span class="string">&#x27;Wine Type - Sulfur Dioxide - Residual Sugar - Alcohol - Quality Class - Quality Rating&#x27;</span>, <span class="attribute">fontsize</span>=14)</span><br><span class="line">l = g.add_legend(<span class="attribute">title</span>=<span class="string">&#x27;Wine Quality Class&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/MultiDimensionalData/利用散点图以及色调、面和大小的概念在六维中可视化数据.webp" alt="利用散点图以及色调、面和大小的概念在六维中可视化数据"></p><p>因此，在这种情况下，我们利用构面和色调来表示三个分类属性，并利用两个规则轴和大小来表示 6 维数据可视化的三个数值属性。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>数据可视化是一门艺术，也是一门科学。如果您正在阅读本文，我真诚地赞扬您为阅读这篇内容广泛的文章所做的努力。目的不是为了记住任何东西，也不是为了给出一组固定的数据可视化规则。这里的主要目标是理解和学习一些有效的数据可视化策略，特别是当维度数量开始增加时。我鼓励您将来利用这些片段来可视化您自己的数据集。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://towardsdatascience.com/the-art-of-effective-visualization-of-multi-dimensional-data-6c7202990c57">多维数据有效可视化的艺术</a></p>]]></content>
      
      
      <categories>
          
          <category> PYTHON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Moveit 初次接触</title>
      <link href="/2023/09/17/archived_ros_moveit_learning/"/>
      <url>/2023/09/17/archived_ros_moveit_learning/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#moveit-leaning">moveit leaning</a></li><li><a href="#moveit-tutorials">moveit tutorials</a><ul><li><a href="#环境配置">环境配置</a><ul><li><a href="#相关依赖安装">相关依赖安装</a></li><li><a href="#示例代码下载">示例代码下载</a></li><li><a href="#构建cakin-工作空间">构建cakin 工作空间</a></li></ul></li><li><a href="#在-rviz-中运行">在 RViz 中运行</a><ul><li><a href="#开启示例">开启示例</a></li></ul></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对moveit的使用进行简单的记录, 可能是对于用其他人已创建好的模型的使用的最快方法；</p><h1 id="moveit-leaning"><a href="#moveit-leaning" class="headerlink" title="moveit leaning"></a>moveit leaning</h1><p>起初在<a href="https://github.com/myyerrol/learning_moveit">github</a>项目中看到的这个，于是就自己尝试复现一下作者的操作，首先，搞定moveit配置环境(根据自己版本去替换，笔者自己用的是noetic)</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install ros-noetic-moveit</span><br></pre></td></tr></table></figure><p>进入ROS工程的存放地址, 并下载源码</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/catkin_ws/src</span></span><br><span class="line">git clone https:<span class="string">//github.com/myyerrol/learning_moveit.git</span></span><br><span class="line"><span class="keyword">cd</span> <span class="string">..</span></span><br><span class="line">rosdep install -y <span class="params">--from-paths</span> src <span class="params">--ignore-src</span> <span class="params">--rosdistro</span> noetic  <span class="comment"># 这个可能因为墙的原因无法正常执行</span></span><br><span class="line"><span class="keyword">cd</span> ~<span class="string">/catkin_ws/src/learning_moveit</span></span><br><span class="line"><span class="string">./setup.sh</span></span><br></pre></td></tr></table></figure><p>需要注意的是，此项目是基于kinetic建立的，因此需要将原项目中的kinetic全部替换成noetic, 这个比较简单，可以通过vim来查询含有这个关键词的位置，直接替换即可，参考指令如下</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">vim ~<span class="regexp">/catkin_ws/src</span><span class="regexp">/</span></span><br><span class="line"><span class="regexp">:vimgrep /kinetic</span><span class="regexp">/noetic/gj</span> **</span><br></pre></td></tr></table></figure><p>找到后替换即可，但是到编译的时候会报错，报错信息如下</p><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>static assertion failed: YOU_PREFORMED_AN_INVALID_TRANSFORMATION_CONVERSION</span><br></pre></td></tr></table></figure><p>这个是因为Eigen库更新时API的迁移问题，类似的采用vim查找关键词<code>Affine3d</code>, 替换成<code>Isometry3d</code>即可，如下图所示，为查找出来的两个地方</p><p><img src="/img/postImg/1_ros/moveit/learning_move_it.png" alt=""></p><p>接下来进行编译</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>编译成功，结果如下所示</p><p><img src="/img/postImg/1_ros/moveit/learning_moveit_OK.png" alt=""></p><p>接下来根据作者的给出的操作进行，不过最后没法显示出机器人，结果如下</p><p><img src="/img/postImg/1_ros/moveit/panda_bringup_gazebo_bug.png" alt=""></p><p>毕竟是五年前的东西，可以采用比较新的版本去搞，所以就没接着研究下去了，感觉是一个很好的开始，花了我半天的时间才编译通过，有一点小小的惊喜，哈哈哈~</p><h1 id="moveit-tutorials"><a href="#moveit-tutorials" class="headerlink" title="moveit tutorials"></a>moveit tutorials</h1><p>这部分则是 <a href="https://ros-planning.github.io/moveit_tutorials/doc/getting_started/getting_started.html#install-ros-and-catkin">moveit 官网</a>给出来的教程了，通过他们的教程，可以真实的创建一些机器人，把目前跑通了的给记录下来(Ubuntu 系统中), 这里假设之前已进行好相关的配置，比如在zshrc中加入了<code>source ~/catkin_ws/devel/setup.zsh</code>等等, 官方界面如下所示</p><p><img src="/img/postImg/1_ros/moveit/moveit官网示例.png" alt=""></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="相关依赖安装"><a href="#相关依赖安装" class="headerlink" title="相关依赖安装"></a>相关依赖安装</h3><p>由于自己已经安装好了 noetic 和 moveit, 所以只需要安装下面的即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python3-catkin-tools</span><br></pre></td></tr></table></figure><h3 id="示例代码下载"><a href="#示例代码下载" class="headerlink" title="示例代码下载"></a>示例代码下载</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">cd ~/catkin_ws/src/</span><br><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/ros-planning/moveit_tutorials.git -b <span class="keyword">master</span></span><br><span class="line"><span class="title">git</span> <span class="keyword">clone</span> <span class="title">https</span>://github.com/ros-planning/panda_moveit_config.git -b noetic-devel</span><br></pre></td></tr></table></figure><h3 id="构建cakin-工作空间"><a href="#构建cakin-工作空间" class="headerlink" title="构建cakin 工作空间"></a>构建cakin 工作空间</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/catkin_ws/src</span></span><br><span class="line">rosdep install -y <span class="params">--from-paths</span> . <span class="params">--ignore-src</span> <span class="params">--rosdistro</span> noetic</span><br><span class="line">sudo sh -c &#x27;<span class="keyword">echo</span> <span class="string">&quot;deb http://packages.ros.org/ros-testing/ubuntu $(lsb_release -sc) main&quot;</span> &gt; <span class="string">/etc/apt/sources.list.d/ros-latest.list</span>&#x27;</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h2 id="在-RViz-中运行"><a href="#在-RViz-中运行" class="headerlink" title="在 RViz 中运行"></a>在 RViz 中运行</h2><h3 id="开启示例"><a href="#开启示例" class="headerlink" title="开启示例"></a>开启示例</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">roslaunch panda_moveit_config demo.<span class="built_in">launch</span> rviz_tutorial:=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>可以看到一个空的界面，如下所示</p><p><img src="/img/postImg/1_ros/moveit/empty_moveit.png" alt=""></p><p>添加运动规划插件</p><p><img src="/img/postImg/1_ros/moveit/Add_moveit.png" alt=""></p><p>然后选中运动规划的插件</p><p><img src="/img/postImg/1_ros/moveit/add_motion_planning.png" alt=""></p><p>确定后得到的结果如图所示</p><p><img src="/img/postImg/1_ros/moveit/add_motion_planning_after.png" alt=""></p><p>现在可以手动拖动末端，进行相关的规划了，如下所示</p><p><img src="/img/postImg/1_ros/moveit/move_it_初次拖动.gif" alt=""></p><p>界面中还提供了很多丰富的选项，这里就不一一列举了，建议去官网浏览一遍；</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]. <a href="https://ros-planning.github.io/moveit_tutorials/doc/getting_started/getting_started.html#install-ros-and-catkin">moveit 官方教程</a></p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> ROS </tag>
            
            <tag> moveit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于KDL与DH参数的运动学正逆解</title>
      <link href="/2023/09/13/archived_ROS_KDL_FK/"/>
      <url>/2023/09/13/archived_ROS_KDL_FK/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#简介">简介</a></li><li><a href="#kdl-源码下载">KDL 源码下载</a></li><li><a href="#sdh-参数作为运动学模型的输入">SDH 参数作为运动学模型的输入</a></li><li><a href="#概念描述">概念描述</a><ul><li><a href="#机器人描述最小单元segment">机器人描述最小单元：Segment</a></li><li><a href="#关节-joint描述">关节 joint描述</a></li><li><a href="#连杆动力学参数rigidbodyinertia">连杆动力学参数：RigidBodyInertia</a></li><li><a href="#串联机器人链chain">串联机器人链：Chain</a></li><li><a href="#建立树tree">建立树：tree</a></li></ul></li><li><a href="#正运动学求解器">正运动学求解器</a></li><li><a href="#逆运动学求解器">逆运动学求解器</a></li><li><a href="#trac_ik逆解调用">TRAC_IK逆解调用</a><ul><li><a href="#参考代码示例">参考代码示例</a></li></ul></li><li><a href="#问题及解释">问题及解释</a><ul><li><a href="#1kdl的inverse-jacobian和trac_ik的inverse-jacobian区别">1.KDL的inverse Jacobian和TRAC_IK的inverse Jacobian区别？</a></li><li><a href="#2kdl中的joint-limit包括哪些">2.KDL中的joint limit包括哪些？</a></li><li><a href="#3kdl求解成功率低你认为主要问题在哪儿">3.KDL求解成功率低，你认为主要问题在哪儿？</a></li><li><a href="#4trac-ik非线性求解中cost-function是什么约束条件包括哪些">4.TRAC-IK非线性求解中cost function是什么？约束条件包括哪些？</a></li></ul></li><li><a href="#gazebo-仿真部分">Gazebo 仿真部分</a><ul><li><a href="#error-cannot-launch-node-of-type-robot_state_publisherstate_publisher解决方法">ERROR: cannot launch node of type [robot_state_publisher/state_publisher]:解决方法</a></li><li><a href="#demo_gazebo无法启动">demo_gazebo无法启动</a></li><li><a href="#gazebo仿真掉轴">gazebo仿真掉轴</a><ul><li><a href="#排查是否由于使用solidworks导出文件有误">排查是否由于使用solidworks导出文件有误</a></li></ul></li></ul></li><li><a href="#找不到要链接的动态链接库路径">找不到要链接的动态链接库路径</a><ul><li><a href="#注意事项">注意事项</a></li></ul></li><li><a href="#其他未归类事项">其他未归类事项</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://github.com/orocos/orocos_kinematics_dynamics">KDL</a>（Kinematics and Dynamics）：机器人运动学与动力学组件，是MoveIt!中的默认运动学插件，在使用MoveIt Setup Assistant进行模型配置时，可以进行配置。学习机器人路径规划、轨迹规划、逆解算法，甚至编程的话，是一个很好的学习素材； 本文的测试环境为： <code>Ubuntu 20.04.2 ARM64</code>, 以埃夫特机器人通用六轴工业机器人为例来说明如何调用KDL的正逆运动学求解部分; 下面简单对相关运动学求解器做个简单的介绍：</p><p>（1）KDL</p><p>KDL（Kinematics and Dynamics Library）是MoveIt!中的默认运动学插件，其有自己的优缺点，优点在于可求解封闭情况下逆运动，缺点在于速度慢，同时可能找不到解。</p><p>（2）TRAC-IK</p><p>TRAC-IK和KDL类似，也是一种基于数值解的运动学插件，但是在算法层面上进行了很多改进，求解效率高了很多。可通过如下方式安装（个人使用的是noetic版本）</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install ros-noetic-trac-ik-kinematics-plugin</span><br></pre></td></tr></table></figure><p>（3）IKFAST</p><p>IKFAST是一种基于解析算法的运动学插件，可以求解任意复杂运动链的运动学方程并保证每次求解的一致性，整体来说，IKFAST比较稳定快速，一般5us的速度可完成运算。</p><p>3.MoveIt!运动插件开发方法</p><p>MoveIt!并不提供算法源码，只是将算法按照约定的方法进行封装，算法是数学模型的代码实现，和MoveIt!本身并没有关系，如果需要集成功能算法到MoveIt!中，需要编写接口文件，满足MoveIt!的插件规范即可，然后向move_group进行注册，这样使用时即可通过yaml或launch文件进行直接的调用。</p><h1 id="KDL-源码下载"><a href="#KDL-源码下载" class="headerlink" title="KDL 源码下载"></a>KDL 源码下载</h1><p>首先，下载KDL源码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Destop</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/SarvagyaVaish/Orocos-KDL-Forward-Kinematics.git</span><br></pre></td></tr></table></figure><p>再需要安装相关依赖</p><figure class="highlight q"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install liborocos-kdl-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>第一步，确认是否配置成功，输入如下命令行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> orocos_kinematics_dynamics/orocos_kdl/</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br></pre></td></tr></table></figure><p>后，会得到如下图像<br><img src="/img/postImg/1_ros/KDL/FK/testReady.png" style="zoom:80%;" /></p><p>然后在命令行中输入<code>make</code>,看编译是否成功，如下图所示</p><p><img src="/img/postImg/1_ros/KDL/FK/kdl_make.png" alt=""></p><h1 id="SDH-参数作为运动学模型的输入"><a href="#SDH-参数作为运动学模型的输入" class="headerlink" title="SDH 参数作为运动学模型的输入"></a>SDH 参数作为运动学模型的输入</h1><p>在编写代码前，需要对DH参数进行转换，转换成KDL能够识别的内容，进行正逆运动学的计算，下面给出具体的代码(main.cpp)</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iomanip&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &quot;chain.hpp&quot;</span></span><br><span class="line"><span class="comment">// FK solver</span></span><br><span class="line"><span class="comment">#include  &quot;chainfksolverpos_recursive.hpp&quot;</span></span><br><span class="line"><span class="comment">// IK solver</span></span><br><span class="line"><span class="comment">#include &quot;chainiksolverpos_lma.hpp&quot;</span></span><br><span class="line"></span><br><span class="line">using <span class="keyword">namespace</span> <span class="title class_">KDL</span>;</span><br><span class="line">using <span class="keyword">namespace</span> <span class="title class_">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">int</span> JOINT_NUM = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// ARC12-200 parameters</span></span><br><span class="line"><span class="comment">// input link and tool parameters;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">double</span> L1  =  <span class="number">155.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">double</span> L2  =  <span class="number">483.6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">double</span> L3  =    <span class="number">850</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">double</span> L4  =  <span class="number">205.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">double</span> L5  = <span class="number">1000.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">double</span> L6  =   <span class="number">75.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">double</span> L7  =   -<span class="number">4.5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">double</span> PI2 =   PI/<span class="number">2</span>;</span><br><span class="line"><span class="comment">// tool parameters</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">double</span> tool_x =  <span class="number">10</span>;    </span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">double</span> tool_y = -<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">double</span> tool_z =  <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">double</span> tool_a =  <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">double</span> tool_b =  <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">double</span> tool_c =  <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> theta[JOINT_NUM]  = &#123;<span class="number">0</span>,  PI2, <span class="number">0</span>, PI, PI, PI&#125;;</span><br><span class="line"><span class="keyword">double</span> d[JOINT_NUM]      = &#123;L2, L7, <span class="number">0</span>, L5, <span class="number">0</span>, L6&#125;;</span><br><span class="line"><span class="keyword">double</span> a[JOINT_NUM]      = &#123;L1, L3, L4, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> alpha[JOINT_NUM]  = &#123;PI2, <span class="number">0</span>, PI2, PI2, PI2, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">Chain <span class="title function_ invoke__">eftRobot</span>() &#123;</span><br><span class="line">    Chain eft;</span><br><span class="line">    eft.<span class="title function_ invoke__">addSegment</span>(<span class="title function_ invoke__">Segment</span>(<span class="string">&quot;joint1&quot;</span>, <span class="title function_ invoke__">Joint</span>(<span class="title class_">Joint</span>::<span class="variable constant_">RotZ</span>),</span><br><span class="line">                           <span class="title class_">Frame</span>::<span class="title function_ invoke__">DH</span>(a[<span class="number">0</span>], alpha[<span class="number">0</span>], d[<span class="number">0</span>], theta[<span class="number">0</span>])));</span><br><span class="line">    eft.<span class="title function_ invoke__">addSegment</span>(<span class="title function_ invoke__">Segment</span>(<span class="string">&quot;joint2&quot;</span>, <span class="title function_ invoke__">Joint</span>(<span class="title class_">Joint</span>::<span class="variable constant_">RotZ</span>),</span><br><span class="line">                           <span class="title class_">Frame</span>::<span class="title function_ invoke__">DH</span>(a[<span class="number">1</span>], alpha[<span class="number">1</span>], d[<span class="number">1</span>], theta[<span class="number">1</span>])));</span><br><span class="line">    eft.<span class="title function_ invoke__">addSegment</span>(<span class="title function_ invoke__">Segment</span>(<span class="string">&quot;joint3&quot;</span>, <span class="title function_ invoke__">Joint</span>(<span class="title class_">Joint</span>::<span class="variable constant_">RotZ</span>),</span><br><span class="line">                           <span class="title class_">Frame</span>::<span class="title function_ invoke__">DH</span>(a[<span class="number">2</span>], alpha[<span class="number">2</span>], d[<span class="number">2</span>], theta[<span class="number">2</span>])));</span><br><span class="line">    eft.<span class="title function_ invoke__">addSegment</span>(<span class="title function_ invoke__">Segment</span>(<span class="string">&quot;joint4&quot;</span>, <span class="title function_ invoke__">Joint</span>(<span class="title class_">Joint</span>::<span class="variable constant_">RotZ</span>),</span><br><span class="line">                           <span class="title class_">Frame</span>::<span class="title function_ invoke__">DH</span>(a[<span class="number">3</span>], alpha[<span class="number">3</span>], d[<span class="number">3</span>], theta[<span class="number">3</span>])));</span><br><span class="line">    eft.<span class="title function_ invoke__">addSegment</span>(<span class="title function_ invoke__">Segment</span>(<span class="string">&quot;joint5&quot;</span>, <span class="title function_ invoke__">Joint</span>(<span class="title class_">Joint</span>::<span class="variable constant_">RotZ</span>),</span><br><span class="line">                           <span class="title class_">Frame</span>::<span class="title function_ invoke__">DH</span>(a[<span class="number">4</span>], alpha[<span class="number">4</span>], d[<span class="number">4</span>], theta[<span class="number">4</span>])));</span><br><span class="line">    eft.<span class="title function_ invoke__">addSegment</span>(<span class="title function_ invoke__">Segment</span>(<span class="string">&quot;joint6&quot;</span>, <span class="title function_ invoke__">Joint</span>(<span class="title class_">Joint</span>::<span class="variable constant_">RotZ</span>),</span><br><span class="line">                           <span class="title class_">Frame</span>::<span class="title function_ invoke__">DH</span>(a[<span class="number">5</span>], alpha[<span class="number">5</span>], d[<span class="number">5</span>], theta[<span class="number">5</span>])));</span><br><span class="line">    <span class="keyword">return</span> eft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="title function_ invoke__">main</span>(<span class="keyword">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">double</span> input_qj[JOINT_NUM];</span><br><span class="line">input_qj[<span class="number">0</span>] =  <span class="number">0</span>;</span><br><span class="line">input_qj[<span class="number">1</span>] =  <span class="number">0</span>;</span><br><span class="line">input_qj[<span class="number">2</span>] =  <span class="number">0</span>;</span><br><span class="line">input_qj[<span class="number">3</span>] =  <span class="number">0</span>;</span><br><span class="line">input_qj[<span class="number">4</span>] = <span class="number">50</span>;</span><br><span class="line">input_qj[<span class="number">5</span>] =  <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Chain eft_robot = <span class="title function_ invoke__">eftRobot</span>();</span><br><span class="line">  JntArray <span class="title function_ invoke__">q</span>(eft_robot.<span class="title function_ invoke__">getNrOfJoints</span>());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; JOINT_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="title function_ invoke__">q</span>(i) = input_qj[i] * deg2rad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> ChainFkSolverPos_recursive <span class="title function_ invoke__">fksolver</span>(eft_robot);</span><br><span class="line"></span><br><span class="line">    Frame flangeFrame;</span><br><span class="line">fksolver.<span class="title function_ invoke__">JntToCart</span>(q, flangeFrame);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Frame toolFrame;</span><br><span class="line">toolFrame.p[<span class="number">0</span>] = tool_x;</span><br><span class="line">toolFrame.p[<span class="number">1</span>] = tool_y;</span><br><span class="line">toolFrame.p[<span class="number">2</span>] = tool_z;</span><br><span class="line">Rotation toolRotation = <span class="title class_">Rotation</span>::<span class="title function_ invoke__">RPY</span>(tool_a * deg2rad, tool_b * deg2rad, tool_c * deg2rad);</span><br><span class="line">toolFrame.M = toolRotation;</span><br><span class="line"></span><br><span class="line">Frame T;</span><br><span class="line">T = flangeFrame * toolFrame;</span><br><span class="line">Rotation R;</span><br><span class="line">R = T.M;</span><br><span class="line"><span class="keyword">double</span> aa, bb, cc;</span><br><span class="line">R.<span class="title function_ invoke__">GetRPY</span>(cc, bb, aa);</span><br><span class="line"><span class="keyword">double</span> A, B, C;</span><br><span class="line">A = aa * rad2deg;</span><br><span class="line">B = bb * rad2deg;</span><br><span class="line">C = cc * rad2deg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> fkRes[<span class="number">6</span>];</span><br><span class="line">fkRes[<span class="number">0</span>] = T.p[<span class="number">0</span>];</span><br><span class="line">fkRes[<span class="number">1</span>] = T.p[<span class="number">1</span>];</span><br><span class="line">fkRes[<span class="number">2</span>] = T.p[<span class="number">2</span>];</span><br><span class="line">fkRes[<span class="number">3</span>] = A;</span><br><span class="line">fkRes[<span class="number">4</span>] = B;</span><br><span class="line">fkRes[<span class="number">5</span>] = C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;fk value is &quot;</span> &lt;&lt; fkRes[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// IK solve</span></span><br><span class="line">JntArray <span class="title function_ invoke__">qInit</span>(eft_robot.<span class="title function_ invoke__">getNrOfJoints</span>());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; JOINT_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="title function_ invoke__">qInit</span>(i) = input_qj[i] * deg2rad + <span class="number">0.1</span>;</span><br><span class="line">&#125;</span><br><span class="line">JntArray <span class="title function_ invoke__">qSol</span>(eft_robot.<span class="title function_ invoke__">getNrOfJoints</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> eps = <span class="number">1E-6</span>;  <span class="comment">// 笛卡尔空间的收敛阈值</span></span><br><span class="line"><span class="keyword">int</span> maxIter = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">double</span> eps_joints= <span class="number">1e-8</span>;   <span class="comment">// 关节空间的收敛阈值</span></span><br><span class="line">ChainIkSolverPos_LMA ikSolver = <span class="title function_ invoke__">ChainIkSolverPos_LMA</span>(eft_robot, eps, maxIter, eps_joints);</span><br><span class="line">ikSolver.<span class="title function_ invoke__">CartToJnt</span>(qInit, flangeFrame, qSol);</span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt;<span class="string">&quot;(KDL IK SOLVE)theta1 value is\t&quot;</span> &lt;&lt;  rad2deg * <span class="title function_ invoke__">qSol</span>(<span class="number">0</span>)  &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt;<span class="string">&quot;(KDL IK SOLVE)theta2 value is\t&quot;</span> &lt;&lt;  rad2deg * <span class="title function_ invoke__">qSol</span>(<span class="number">1</span>)  &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt;<span class="string">&quot;(KDL IK SOLVE)theta3 value is\t&quot;</span> &lt;&lt;  rad2deg * <span class="title function_ invoke__">qSol</span>(<span class="number">2</span>)  &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt;<span class="string">&quot;(KDL IK SOLVE)theta4 value is\t&quot;</span> &lt;&lt;  rad2deg * <span class="title function_ invoke__">qSol</span>(<span class="number">3</span>)  &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt;<span class="string">&quot;(KDL IK SOLVE)theta5 value is\t&quot;</span> &lt;&lt;  rad2deg * <span class="title function_ invoke__">qSol</span>(<span class="number">4</span>)  &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::<span class="variable constant_">cout</span> &lt;&lt;<span class="string">&quot;(KDL IK SOLVE)theta6 value is\t&quot;</span> &lt;&lt;  rad2deg * <span class="title function_ invoke__">qSol</span>(<span class="number">5</span>)  &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及对应的CmakeLists.txt如下</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.0</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span> (FK_KDL_Tutorial)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span> (orocos_kdl REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span> (<span class="variable">$&#123;orocos_kdl_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (SimpleRobotFK main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span> (SimpleRobotFK <span class="variable">$&#123;orocos_kdl_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure><p>另外需要修改在最上层的CMakeLists.txt， 加入build的目录，即可， 如下所示<br><img src="/img/postImg/1_ros/KDL/FK/ADD_SUBDIRECTORY.png" alt=""></p><p>加入完这段指令后，回到build目录，输入<code>cmake ..</code>, 在build目录中，能够看到如下内容(重要的就只有<code>main.cpp</code>与<code>CMakeLists.txt</code>了)</p><p><img src="/img/postImg/1_ros/KDL/FK/dir_build.png" alt=""></p><p>直接在命令行中<code>make</code>即可，如下图所示</p><p><img src="/img/postImg/1_ros/KDL/FK/make.png" alt=""></p><p>这样就成功了，然后通过如下指令，运行编译出来的结果</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">../devel/lib/orocos_kdl</span></span><br><span class="line"><span class="string">./SimpleRobotFK</span></span><br></pre></td></tr></table></figure><p><img src="/img/postImg/1_ros/KDL/FK/result.png" alt=""></p><p>至此，基本上运动学正逆解部分就已经结束了，这里采用的是标准DH（SDH）建模，对于工业机器人来说，SDH和MDH其实差别不大，主要体现在机器人标定以及动力学递归推导的简洁性，当然，KDL里面也提供了MDH以及旋量等方式进行的运动学建模，仅作为示例， 不一一列举；</p><h1 id="概念描述"><a href="#概念描述" class="headerlink" title="概念描述"></a>概念描述</h1><p>按照上面的例子，可以开始将这一工具用起来了，下面记录一些相关的概念；KDL描述机器人的方式分别是段，链，与树，可用于串并联机器人的描述；</p><h2 id="机器人描述最小单元：Segment"><a href="#机器人描述最小单元：Segment" class="headerlink" title="机器人描述最小单元：Segment"></a>机器人描述最小单元：Segment</h2><p>机器人最小结构所需要的参数：关节、坐标、连杆质量、连杆惯性张量</p><p><img src="/img/postImg/1_ros/KDL/segment/segment_describe.png" alt=""></p><p>其中 <code>oc</code>表示质心；在图中可以看出，segment拥有一个参考坐标系、关节坐标系、质心坐标系，tip坐标系，其中参考坐标系通常与关节坐标系重合，tip坐标系用于描述杆件姿态，同时作为下一个segment的参考坐标系，质心坐标系与参考坐标系同向。在KDL中采用三个结构体来描述，关节、坐标，刚体惯量; </p><h2 id="关节-joint描述"><a href="#关节-joint描述" class="headerlink" title="关节 joint描述"></a>关节 joint描述</h2><p>KDL源码对此部分的构造函数如下图所示</p><p><img src="/img/postImg/1_ros/KDL/joint_describe.png" alt=""></p><p>各个含义解释如下：</p><ul><li>1 关节名字：name</li><li>2 原点：origin</li><li>3 轴：_axis</li><li>4 关节类型：JointType</li><li><p>JointType = Fixed （表示被固定的关节）</p><p>RotAxis<br>RotX<br>RotY<br>RotZ<br>TransAxis<br>TransX<br>TransY<br>TransZ</p></li><li>5  减速比：scale，一般默认设置就可以，需要注意的是KDL里面没有耦合比，要做电机关节转换的时候需要自己写一个函数；<br>6 偏置：offset</li><li>7 惯量：inertia，绕转动轴的一维惯量</li><li>8 阻尼：damping</li><li>9 刚度：stiffness</li></ul><h2 id="连杆动力学参数：RigidBodyInertia"><a href="#连杆动力学参数：RigidBodyInertia" class="headerlink" title="连杆动力学参数：RigidBodyInertia"></a>连杆动力学参数：RigidBodyInertia</h2><p>连杆的动力学参数包括了三个量：</p><ul><li><p>1 质量：m</p></li><li><p>2 质心：oc</p></li><li><p>3 惯性张量矩阵：Ic</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">RotationalInertia(double <span class="attribute">Ixx</span>=0,double <span class="attribute">Iyy</span>=0,double <span class="attribute">Izz</span>=0,double <span class="attribute">Ixy</span>=0,double <span class="attribute">Ixz</span>=0,double <span class="attribute">Iyz</span>=0) </span><br></pre></td></tr></table></figure></li></ul><h2 id="串联机器人链：Chain"><a href="#串联机器人链：Chain" class="headerlink" title="串联机器人链：Chain"></a>串联机器人链：Chain</h2><p>由基本元素段segment相连，构成了一个串联的链，</p><p><img src="/img/postImg/1_ros/KDL/chain_describe.png" alt=""></p><h2 id="建立树：tree"><a href="#建立树：tree" class="headerlink" title="建立树：tree"></a>建立树：tree</h2><p>一般，树不会直接代码建立，而是采用更简单的方法，通过URDF文件获取，获取方法如下所示。</p><figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urdf_parser_py.urdf <span class="keyword">import</span> URDF</span><br><span class="line"><span class="keyword">from</span> pykdl_utils.kdl_kinematics <span class="keyword">import</span> KDLKinematics</span><br><span class="line"><span class="keyword">from</span> pykdl_utils.kdl_parser <span class="keyword">import</span> kdl_tree_from_urdf_model</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取URDF文件</span></span><br><span class="line">robot = URDF.from_xml_file(<span class="string">&quot;/yourpath/catkin_ws/src/robot_description/armc_description/urdf/armc_description.urdf&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将URDF转换为树</span></span><br><span class="line">tree = kdl_tree_from_urdf_model(robot)</span><br><span class="line"></span><br><span class="line"><span class="comment">#截取需要的部分构成链</span></span><br><span class="line">chain = tree.getChain(<span class="string">&quot;base_link&quot;</span>, <span class="string">&quot;sensor_link&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="正运动学求解器"><a href="#正运动学求解器" class="headerlink" title="正运动学求解器"></a>正运动学求解器</h1><ul><li><p>必须为每个链创建一个单独的求解器；</p></li><li><p>正运动学函数<code>JntToCart()</code>,从关节空间值计算笛卡尔空间值，逆运动学试用功能<code>CartToJnt()</code>,从笛卡尔空间值计算关节空间值；</p></li><li><p>KDL提供了关节运动学（从目前所看代码来说，并没有从电机角度到关节角度的转换，即无耦合比，但是有一个scale即传动比，所以推测是关节运动学）和动力学（关节动力学），考虑了从关节空间到笛卡尔空间的正逆运动学；</p></li><li><p>JntToCart方法： 求解关节空间到某一个segment笛卡尔空间的正运动学（位置或速度）；当segmentNr=-1(默认值), 从基座解算到法兰端，当segmentNr&gt;0如segmentNr=3时，对应的结果为$pc_{out} = T^0_3 = T^0_1T^1_2T^2_3$</p><p><img src="/img/postImg/1_ros/KDL/FK/ChainFk_JntToCart.png" alt=""></p></li></ul><h1 id="逆运动学求解器"><a href="#逆运动学求解器" class="headerlink" title="逆运动学求解器"></a>逆运动学求解器</h1><p>chainIksolver.hpp中有两个抽象类</p><ul><li>ChainIkSolverPos</li><li>ChainIkSolverVel</li><li>ChainIkSolverAcc(带有关节加速度约束的求解)</li></ul><p><img src="/img/postImg/1_ros/KDL/IK/逆解求解器3种.png" alt=""></p><p>KDL逆解采用的数值解法其中：</p><ul><li>位置求解有三种（Levenberg Marquardt(非线性最小二乘优化问题的算法, 结合了梯度下降和牛顿法的优点), Newton Raphson(基于泰勒展开的思想，将非线性函数线性化，从而在每次迭代中逐步逼近函数的根), Newton Raphson(关节限位))</li></ul><!--  | 文件                       | 含义                                            |   --><!--  | -------------------------- | ----------------------------------------------- |   --><!--  | chainiksolverpos_lma.hpp   | 使用Levenberg-Marquardt求解方法（默认求解方式） |   --><!--  | chainiksolverpos_nr.hpp    | Newton Raphson 迭代法求解                       |   --><!--  | chainiksolverpos_nr_jl.hpp | 带有关节限位的Newton Raphson 迭代法求解         |     --><p><img src="/img/postImg/1_ros/KDL/IK/tab_KDL_IK_position_sol.png" alt=""></p><ul><li>速度求解有四种（SVD分解及其优化）</li></ul><!--  | 文件                             | 含义                                                         | --><!--  | -------------------------------- | ------------------------------------------------------------ | --><!--  | chainiksolvervel_pinv.hpp        | 使用广义伪逆进行求解（基于Householder的SVD分解）， TRAC_IK求解器主要用到这个函数 | --><!--  | chainiksolvervel_pinv_givens.hpp | 使用广义伪逆进行求解（基于Maciejewski的SVD分解）             | --><!--  | chainiksolvervel_pinv_nso.hpp    | 针对冗余机器人的优化求解（SVD分解+冗余优化）                 | --><!--  | chainiksolvervel_wdls.hpp        | 加权最小二乘的SVD分解（避免在奇异配置下的数值不稳定性，以及在需要特定关节或方向优先运动时，通过权重矩阵调整实现更灵活的运动规划。） | --><p><img src="/img/postImg/1_ros/KDL/IK/tab_KDL_IK_vel_sol.png" alt=""></p><h1 id="TRAC-IK逆解调用"><a href="#TRAC-IK逆解调用" class="headerlink" title="TRAC_IK逆解调用"></a>TRAC_IK逆解调用</h1><h2 id="参考代码示例"><a href="#参考代码示例" class="headerlink" title="参考代码示例"></a>参考代码示例</h2><figure class="highlight twig"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">#include <span class="tag">&lt;<span class="name">ctime</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">#include <span class="tag">&lt;<span class="name">iomanip</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">#include <span class="tag">&lt;<span class="name">iostream</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">#include <span class="tag">&lt;<span class="name">random</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">#include <span class="tag">&lt;<span class="name">string</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">#include <span class="tag">&lt;<span class="name">vector</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">#include <span class="tag">&lt;<span class="name">random</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">#include &quot;chain.hpp&quot;</span></span><br><span class="line"><span class="language-xml">#include &quot;chainfksolverpos_recursive.hpp&quot;</span></span><br><span class="line"><span class="language-xml">#include &quot;optimal_ik.hpp&quot;</span></span><br><span class="line"><span class="language-xml">#include <span class="tag">&lt;<span class="name">chrono</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">using namespace EfortRobotics;</span></span><br><span class="line"><span class="language-xml">using namespace std;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">std::vector<span class="tag">&lt;<span class="name">double</span>&gt;</span> generateRandomNumbers(size_t N, double lower_bound,</span></span><br><span class="line"><span class="language-xml">                                          double upper_bound) &#123;</span></span><br><span class="line"><span class="language-xml">  // Create a random device and use it to seed the random number generator</span></span><br><span class="line"><span class="language-xml">  std::random_device rd;</span></span><br><span class="line"><span class="language-xml">  std::mt19937 generator(rd());</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  // Define the distribution range</span></span><br><span class="line"><span class="language-xml">  std::uniform_real_distribution<span class="tag">&lt;<span class="name">double</span>&gt;</span> distribution(lower_bound, upper_bound);</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  // Vector to store the random numbers</span></span><br><span class="line"><span class="language-xml">  std::vector<span class="tag">&lt;<span class="name">double</span>&gt;</span> random_numbers;</span></span><br><span class="line"><span class="language-xml">  random_numbers.reserve(N);</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  // Generate N random numbers</span></span><br><span class="line"><span class="language-xml">  for (size_t i = 0; i &lt; N; ++i) &#123;</span></span><br><span class="line"><span class="language-xml">    random_numbers.push_back(distribution(generator));</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  return random_numbers;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">const double GR1650RobotData[10][15] = </span></span><br><span class="line"><span class="language-xml"></span><span class="template-variable">&#123;&#123;<span class="number">3</span>.<span class="number">34794617</span>,-<span class="number">10</span>.<span class="number">58260822</span>,<span class="number">8</span>.<span class="number">23197365</span>,-<span class="number">0</span>.<span class="number">04651885</span>,-<span class="number">1</span>.<span class="number">02300739</span>,-<span class="number">26</span>.<span class="number">67648125</span>,<span class="number">45</span>.<span class="number">72592545</span>,-<span class="number">41</span>.<span class="number">07115173</span>,-<span class="number">15</span>.<span class="number">41529846</span>,<span class="number">1455</span>.<span class="number">87561</span>,<span class="number">268</span>.<span class="number">4154053</span>,<span class="number">574</span>.<span class="number">6983032</span>,<span class="number">121</span>.<span class="number">972</span>,<span class="number">66</span>.<span class="number">6175</span>,<span class="number">93</span>.<span class="number">079</span>&#125;,</span></span><br><span class="line"><span class="template-variable">&#123;<span class="number">3</span>.<span class="number">34794617</span>,-<span class="number">10</span>.<span class="number">58260822</span>,<span class="number">8</span>.<span class="number">23197365</span>,-<span class="number">0</span>.<span class="number">21433127</span>,-<span class="number">1</span>.<span class="number">15195727</span>,-<span class="number">26</span>.<span class="number">62742043</span>,<span class="number">45</span>.<span class="number">64493942</span>,-<span class="number">41</span>.<span class="number">24930191</span>,-<span class="number">15</span>.<span class="number">33370686</span>,<span class="number">1458</span>.<span class="number">096802</span>,<span class="number">264</span>.<span class="number">3443298</span>,<span class="number">572</span>.<span class="number">6964722</span>,<span class="number">121</span>.<span class="number">972</span>,<span class="number">66</span>.<span class="number">6175</span>,<span class="number">93</span>.<span class="number">079</span>&#125;,</span></span><br><span class="line"><span class="template-variable">&#123;<span class="number">3</span>.<span class="number">34794617</span>,-<span class="number">10</span>.<span class="number">58260822</span>,<span class="number">8</span>.<span class="number">23197365</span>,-<span class="number">0</span>.<span class="number">31202319</span>,-<span class="number">1</span>.<span class="number">22743583</span>,-<span class="number">26</span>.<span class="number">59846497</span>,<span class="number">45</span>.<span class="number">59809494</span>,-<span class="number">41</span>.<span class="number">35301208</span>,-<span class="number">15</span>.<span class="number">28658581</span>,<span class="number">1459</span>.<span class="number">392944</span>,<span class="number">261</span>.<span class="number">9689026</span>,<span class="number">571</span>.<span class="number">5285645</span>,<span class="number">121</span>.<span class="number">972</span>,<span class="number">66</span>.<span class="number">6175</span>,<span class="number">93</span>.<span class="number">079</span>&#125;,</span></span><br><span class="line"><span class="template-variable">&#123;<span class="number">3</span>.<span class="number">34794617</span>,-<span class="number">10</span>.<span class="number">58260822</span>,<span class="number">8</span>.<span class="number">23197365</span>,-<span class="number">0</span>.<span class="number">47910076</span>,-<span class="number">1</span>.<span class="number">35722435</span>,-<span class="number">26</span>.<span class="number">54826355</span>,<span class="number">45</span>.<span class="number">51836777</span>,-<span class="number">41</span>.<span class="number">53038788</span>,-<span class="number">15</span>.<span class="number">20662689</span>,<span class="number">1461</span>.<span class="number">614624</span>,<span class="number">257</span>.<span class="number">8968201</span>,<span class="number">569</span>.<span class="number">5262451</span>,<span class="number">121</span>.<span class="number">972</span>,<span class="number">66</span>.<span class="number">6175</span>,<span class="number">93</span>.<span class="number">079</span>&#125;,</span></span><br><span class="line"><span class="template-variable">&#123;<span class="number">3</span>.<span class="number">34794617</span>,-<span class="number">10</span>.<span class="number">58260822</span>,<span class="number">8</span>.<span class="number">23197365</span>,-<span class="number">0</span>.<span class="number">57634461</span>,-<span class="number">1</span>.<span class="number">43317449</span>,-<span class="number">26</span>.<span class="number">51864624</span>,<span class="number">45</span>.<span class="number">47224808</span>,-<span class="number">41</span>.<span class="number">63362122</span>,-<span class="number">15</span>.<span class="number">16045284</span>,<span class="number">1462</span>.<span class="number">910889</span>,<span class="number">255</span>.<span class="number">521225</span>,<span class="number">568</span>.<span class="number">3581543</span>,<span class="number">121</span>.<span class="number">972</span>,<span class="number">66</span>.<span class="number">6175</span>,<span class="number">93</span>.<span class="number">079</span>&#125;,</span></span><br><span class="line"><span class="template-variable">&#123;<span class="number">3</span>.<span class="number">34794617</span>,-<span class="number">10</span>.<span class="number">58260822</span>,<span class="number">8</span>.<span class="number">23197365</span>,-<span class="number">0</span>.<span class="number">74264199</span>,-<span class="number">1</span>.<span class="number">56375742</span>,-<span class="number">26</span>.<span class="number">46731567</span>,<span class="number">45</span>.<span class="number">39375305</span>,-<span class="number">41</span>.<span class="number">81016541</span>,-<span class="number">15</span>.<span class="number">08209801</span>,<span class="number">1465</span>.<span class="number">132568</span>,<span class="number">251</span>.<span class="number">4491119</span>,<span class="number">566</span>.<span class="number">355835</span>,<span class="number">121</span>.<span class="number">972</span>,<span class="number">66</span>.<span class="number">6175</span>,<span class="number">93</span>.<span class="number">079</span>&#125;,</span></span><br><span class="line"><span class="template-variable">&#123;<span class="number">3</span>.<span class="number">34794617</span>,-<span class="number">10</span>.<span class="number">58260822</span>,<span class="number">8</span>.<span class="number">23197365</span>,-<span class="number">0</span>.<span class="number">83942902</span>,-<span class="number">1</span>.<span class="number">64016712</span>,-<span class="number">26</span>.<span class="number">43704033</span>,<span class="number">45</span>.<span class="number">34833908</span>,-<span class="number">41</span>.<span class="number">91290665</span>,-<span class="number">15</span>.<span class="number">03684616</span>,<span class="number">1466</span>.<span class="number">428833</span>,<span class="number">249</span>.<span class="number">0735321</span>,<span class="number">565</span>.<span class="number">1878052</span>,<span class="number">121</span>.<span class="number">972</span>,<span class="number">66</span>.<span class="number">6175</span>,<span class="number">93</span>.<span class="number">079</span>&#125;,</span></span><br><span class="line"><span class="template-variable">&#123;<span class="number">3</span>.<span class="number">34794617</span>,-<span class="number">10</span>.<span class="number">58260822</span>,<span class="number">8</span>.<span class="number">23197365</span>,-<span class="number">1</span>.<span class="number">00494194</span>,-<span class="number">1</span>.<span class="number">77153146</span>,-<span class="number">26</span>.<span class="number">38458061</span>,<span class="number">45</span>.<span class="number">27103424</span>,-<span class="number">42</span>.<span class="number">08860397</span>,-<span class="number">14</span>.<span class="number">96004868</span>,<span class="number">1468</span>.<span class="number">650513</span>,<span class="number">245</span>.<span class="number">0014191</span>,<span class="number">563</span>.<span class="number">1854858</span>,<span class="number">121</span>.<span class="number">972</span>,<span class="number">66</span>.<span class="number">6175</span>,<span class="number">93</span>.<span class="number">079</span>&#125;,</span></span><br><span class="line"><span class="template-variable">&#123;<span class="number">3</span>.<span class="number">34794617</span>,-<span class="number">10</span>.<span class="number">58260822</span>,<span class="number">8</span>.<span class="number">23197365</span>,-<span class="number">1</span>.<span class="number">1012702</span>,-<span class="number">1</span>.<span class="number">84839332</span>,-<span class="number">26</span>.<span class="number">35364723</span>,<span class="number">45</span>.<span class="number">22629929</span>,-<span class="number">42</span>.<span class="number">19085312</span>,-<span class="number">14</span>.<span class="number">91569138</span>,<span class="number">1469</span>.<span class="number">946777</span>,<span class="number">242</span>.<span class="number">625824</span>,<span class="number">562</span>.<span class="number">0174561</span>,<span class="number">121</span>.<span class="number">972</span>,<span class="number">66</span>.<span class="number">6175</span>,<span class="number">93</span>.<span class="number">079</span>&#125;,</span></span><br><span class="line"><span class="template-variable">&#123;<span class="number">3</span>.<span class="number">34794617</span>,-<span class="number">10</span>.<span class="number">58260822</span>,<span class="number">8</span>.<span class="number">23197365</span>,-<span class="number">1</span>.<span class="number">26599526</span>,-<span class="number">1</span>.<span class="number">98052692</span>,-<span class="number">26</span>.<span class="number">30005836</span>,<span class="number">45</span>.<span class="number">15014267</span>,-<span class="number">42</span>.<span class="number">36568832</span>,-<span class="number">14</span>.<span class="number">84040546</span>,<span class="number">1472</span>.<span class="number">168579</span>,<span class="number">238</span>.<span class="number">5537109</span>,<span class="number">560</span>.<span class="number">0151367</span>,<span class="number">121</span>.<span class="number">972</span>,<span class="number">66</span>.<span class="number">6175</span>,<span class="number">93</span>.<span class="number">079</span>&#125;&#125;</span><span class="language-xml">;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">int main(int argc, char* argv[]) &#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  const int jointNum = 9;</span></span><br><span class="line"><span class="language-xml">  const int dataInputNumber = 10;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  const double theta[jointNum] = &#123;0, 0, 0,  0,   90,  0,   -90,     0, -90&#125;;</span></span><br><span class="line"><span class="language-xml">  const double d[jointNum] =     &#123;0, 0, 0,  0,    0,  0,  1500, 108.5,  87&#125;;</span></span><br><span class="line"><span class="language-xml">  const double a[jointNum] =     &#123;0, 0, 0,  0, 1400,  0,     0,     0,   0&#125;;</span></span><br><span class="line"><span class="language-xml">  const double alpha[jointNum] = &#123;0, 0, 0, 90,    0, 90,    70,   -70,   0&#125;;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  double tool_x=100, tool_y=101, tool_z=102;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  double low[jointNum] =   &#123;3.34794617-1e-5,-10.58260822-1e-5,8.23197365-1e-5, -180*deg2rad, -180*deg2rad, -160*deg2rad, -180*deg2rad, -180*deg2rad, -360*deg2rad&#125;;</span></span><br><span class="line"><span class="language-xml">  double upper[jointNum] = &#123;3.34794617,-10.58260822,8.23197365,  100*deg2rad,  180*deg2rad,  160*deg2rad,  180*deg2rad,  180*deg2rad,  360*deg2rad&#125;;</span></span><br><span class="line"><span class="language-xml">  double input_qt[dataInputNumber][jointNum];</span></span><br><span class="line"><span class="language-xml">  double qc[dataInputNumber][jointNum];</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  // TRAC_IK 求解需要限定求解最大时间以及阈值（所求出的关节角度正解后与期望的法兰位置对比的偏差）</span></span><br><span class="line"><span class="language-xml">  double thr = 1e-5;</span></span><br><span class="line"><span class="language-xml">  double maxTime = 5e-5;</span></span><br><span class="line"><span class="language-xml">  </span></span><br><span class="line"><span class="language-xml">  Chain eft_robot;</span></span><br><span class="line"><span class="language-xml">  eft_robot.addRigidBody(RigidBody(&quot;base_link&quot;));</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    eft_robot.addRigidBody(RigidBody(Joint(Joint::TransX),</span></span><br><span class="line"><span class="language-xml">                                 Frame::DH(a[0], alpha[0], d[0], theta[0])));</span></span><br><span class="line"><span class="language-xml">    eft_robot.addRigidBody(RigidBody(Joint(Joint::TransY),</span></span><br><span class="line"><span class="language-xml">                                 Frame::DH(a[1], alpha[1], d[1], theta[1])));</span></span><br><span class="line"><span class="language-xml">    eft_robot.addRigidBody(RigidBody(Joint(Joint::TransZ),</span></span><br><span class="line"><span class="language-xml">                                 Frame::DH(a[2], alpha[2], d[2], theta[2])));</span></span><br><span class="line"><span class="language-xml">    for (int i = 3; i &lt; jointNum; i++) &#123;</span></span><br><span class="line"><span class="language-xml">      eft_robot.addRigidBody(RigidBody(Joint(Joint::RotZ),</span></span><br><span class="line"><span class="language-xml">                                   Frame::DH(a[i], alpha[i], d[i], theta[i])));</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  PosJ qLow(eft_robot.getJointNumbers());</span></span><br><span class="line"><span class="language-xml">  PosJ qUpper(eft_robot.getJointNumbers());</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  for (int i = 0; i &lt; eft_robot.getJointNumbers(); i++) &#123;</span></span><br><span class="line"><span class="language-xml">    qLow(i) = low[i];</span></span><br><span class="line"><span class="language-xml">    qUpper(i) = upper[i];</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  double input_qj[500][jointNum];</span></span><br><span class="line"><span class="language-xml">  for (int i = 0; i &lt; 500; i++) &#123;</span></span><br><span class="line"><span class="language-xml">    for(int j = 0; j &lt; 3; j++) &#123;</span></span><br><span class="line"><span class="language-xml">input_qj[i][j] = GR1650RobotData[i][j];</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">for (int k = 3; k &lt; jointNum; k++)&#123;</span></span><br><span class="line"><span class="language-xml">        input_qj[i][k] = GR1650RobotData[i][k] * deg2rad;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">for (int m = 0; m &lt; 6; m++)&#123;</span></span><br><span class="line"><span class="language-xml">input_qt[i][m] = GR1650RobotData[i][m+jointNum];</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  ChainFkSolverPos_recursive fksolver(eft_robot);</span></span><br><span class="line"><span class="language-xml">  PosJ q(eft_robot.getJointNumbers());</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  Frame flangeFrame;</span></span><br><span class="line"><span class="language-xml">  // test it cost time;</span></span><br><span class="line"><span class="language-xml">  double aa, bb, cc;</span></span><br><span class="line"><span class="language-xml">  double A, B, C;</span></span><br><span class="line"><span class="language-xml">  double fkRes[6];</span></span><br><span class="line"><span class="language-xml">  auto fk_start = std::chrono::high_resolution_clock::now();</span></span><br><span class="line"><span class="language-xml">  const int LOOP_NUMBER = 200;</span></span><br><span class="line"><span class="language-xml">  const int COMPUTER_COUNT = dataInputNumber * LOOP_NUMBER;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  for (int k = 0; k &lt; LOOP_NUMBER; k++) &#123;</span></span><br><span class="line"><span class="language-xml">  for (int i = 0; i &lt; dataInputNumber; i++) &#123;</span></span><br><span class="line"><span class="language-xml">  for (int j = 0; j &lt; jointNum; j++) &#123;</span></span><br><span class="line"><span class="language-xml">q(j) = input_qj[i][j];</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  fksolver.fk(q, flangeFrame);</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  auto fk_end = std::chrono::high_resolution_clock::now();</span></span><br><span class="line"><span class="language-xml">  auto fk_duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(fk_end - fk_start);</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  double fk_sol_time = fk_duration.count() * 1.0 / COMPUTER_COUNT;</span></span><br><span class="line"><span class="language-xml">  std::cout &lt;&lt; &quot;正解函数执行耗时: &quot; &lt;&lt; fk_sol_time &lt;&lt; &quot; 微秒&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  PosJ qInit(eft_robot.getJointNumbers());</span></span><br><span class="line"><span class="language-xml">  auto ik_start = std::chrono::high_resolution_clock::now();</span></span><br><span class="line"><span class="language-xml">  OPTIMAL_IK::OPTIMAL_IK ik_solver_trac_ik(eft_robot, qLow, qUpper, maxTime, thr);</span></span><br><span class="line"><span class="language-xml">  </span></span><br><span class="line"><span class="language-xml">  PosJ result(eft_robot.getJointNumbers());</span></span><br><span class="line"><span class="language-xml">  int rc;</span></span><br><span class="line"><span class="language-xml">  int solFailNumber = 0;</span></span><br><span class="line"><span class="language-xml">  for (int k = 0; k &lt; LOOP_NUMBER; k++) &#123;</span></span><br><span class="line"><span class="language-xml">  std::vector<span class="tag">&lt;<span class="name">double</span>&gt;</span> random_numbers = generateRandomNumbers(jointNum, -10, 10);</span></span><br><span class="line"><span class="language-xml">  for (int i = 0; i &lt; dataInputNumber; i++) &#123;</span></span><br><span class="line"><span class="language-xml">  for (int j = 0; j &lt; jointNum; j++) &#123;</span></span><br><span class="line"><span class="language-xml">q(j) =input_qj[i][j];</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">          fksolver.fk(q, flangeFrame);</span></span><br><span class="line"><span class="language-xml">          for (int m = 0; m &lt; jointNum; m++) &#123;</span></span><br><span class="line"><span class="language-xml">      qInit(m) = input_qj[i][m] + random_numbers[m] * deg2rad;</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  rc = ik_solver_trac_ik.ik(qInit, flangeFrame, result);</span></span><br><span class="line"><span class="language-xml">  if (rc &lt; 0) &#123;</span></span><br><span class="line"><span class="language-xml">  solFailNumber += 1;</span></span><br><span class="line"><span class="language-xml">//return -1;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  auto ik_end = std::chrono::high_resolution_clock::now();</span></span><br><span class="line"><span class="language-xml">  auto ik_duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(ik_end - ik_start);</span></span><br><span class="line"><span class="language-xml">  double fk_ik_sol_time = ik_duration.count() * 1.0 / COMPUTER_COUNT;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  std::cout &lt;&lt; &quot;逆解失败次数 &quot; &lt;&lt; solFailNumber &lt;&lt; std::endl;</span></span><br><span class="line"><span class="language-xml">  std::cout &lt;&lt; &quot;正解+逆解函数执行耗时: &quot; &lt;&lt; fk_ik_sol_time &lt;&lt; &quot; 微秒&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  return 0;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="问题及解释"><a href="#问题及解释" class="headerlink" title="问题及解释"></a>问题及解释</h1><h2 id="1-KDL的inverse-Jacobian和TRAC-IK的inverse-Jacobian区别？"><a href="#1-KDL的inverse-Jacobian和TRAC-IK的inverse-Jacobian区别？" class="headerlink" title="1.KDL的inverse Jacobian和TRAC_IK的inverse Jacobian区别？"></a>1.KDL的inverse Jacobian和TRAC_IK的inverse Jacobian区别？</h2><p>TRAC_IK 主要使用了 KDL 的 ChainIkSolverVel_pinv 来计算雅可比矩阵的伪逆，并基于非线性优化库 NLOPT 来进行求解。具体来说，TRAC-IK 结合了 KDL 提供的伪逆方法和 NLOPT 的优化算法，来提高逆运动学求解的效率和成功率。所以并没有新的雅可比求解的方式。</p><h2 id="2-KDL中的joint-limit包括哪些？"><a href="#2-KDL中的joint-limit包括哪些？" class="headerlink" title="2.KDL中的joint limit包括哪些？"></a>2.KDL中的joint limit包括哪些？</h2><p>KDL的关节限制仅用于求解的，比如求解带有关节限制情况下，可用KDL中的<code>ChainIkSoverPos_NR_JL</code>来计算；另外提供了锁轴的计算方式, 相关内容可直接去看源码。</p><h2 id="3-KDL求解成功率低，你认为主要问题在哪儿？"><a href="#3-KDL求解成功率低，你认为主要问题在哪儿？" class="headerlink" title="3.KDL求解成功率低，你认为主要问题在哪儿？"></a>3.KDL求解成功率低，你认为主要问题在哪儿？</h2><p>个人认为主要问题在于初始猜测、奇异性、关节限制处理、数值稳定性(如迭代次数, 阈值的设定)和运动学链复杂性等因素。</p><h2 id="4-TRAC-IK非线性求解中cost-function是什么？约束条件包括哪些？"><a href="#4-TRAC-IK非线性求解中cost-function是什么？约束条件包括哪些？" class="headerlink" title="4.TRAC-IK非线性求解中cost function是什么？约束条件包括哪些？"></a>4.TRAC-IK非线性求解中cost function是什么？约束条件包括哪些？</h2><p>在 TRAC-IK 中，cost function 被定义为机器人位置和姿态（法兰端）与期望目标（如果带有工具参数，需要转到法兰端）之间的误差。</p><p>约束条件只有关节限制，通过成本函数与约束条件限制，然后调用开源的非线性优化求解器NLOPT来进行求解。</p><h1 id="Gazebo-仿真部分"><a href="#Gazebo-仿真部分" class="headerlink" title="Gazebo 仿真部分"></a>Gazebo 仿真部分</h1><h2 id="ERROR-cannot-launch-node-of-type-robot-state-publisher-state-publisher-解决方法"><a href="#ERROR-cannot-launch-node-of-type-robot-state-publisher-state-publisher-解决方法" class="headerlink" title="ERROR: cannot launch node of type [robot_state_publisher/state_publisher]:解决方法"></a>ERROR: cannot launch node of type [robot_state_publisher/state_publisher]:解决方法</h2><p>解决方法为修改/launch/display.launch文件中的 robot_state_publisher节点的 type为“robot_state_publisher”即可。</p><h2 id="demo-gazebo无法启动"><a href="#demo-gazebo无法启动" class="headerlink" title="demo_gazebo无法启动"></a>demo_gazebo无法启动</h2><p>所报的问题如下</p><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Error </span>[parser.cc:488] parse as old deprecated model file failed.</span><br><span class="line"><span class="keyword">Error </span>Code 4 Msg: Required attribute[filename] in element[plugin] is not specified in SDF.</span><br><span class="line"><span class="keyword">Error </span>Code 8 Msg: Error reading element &lt;plugin&gt;</span><br><span class="line"><span class="keyword">Error </span>Code 8 Msg: Error reading element &lt;model&gt;</span><br><span class="line"><span class="keyword">Error </span>Code 8 Msg: Error reading element &lt;sdf&gt;</span><br></pre></td></tr></table></figure><p>解决方式，屏蔽掉相关代码，参考如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;trans_joint_6&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;joint_6&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;joint_6_motor&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/EffortJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">          &lt;plugin name=&quot;gazebo_ros_control&quot;&gt;</span></span><br><span class="line"><span class="comment">              &lt;robotNamespace&gt;/&lt;/robotNamespace&gt;</span></span><br><span class="line"><span class="comment">          &lt;/plugin&gt;</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是屏蔽掉后，无法在gazebo中做控制, 最后还是要对此部分内容做修改， 加入PID参数等。</p><h2 id="gazebo仿真掉轴"><a href="#gazebo仿真掉轴" class="headerlink" title="gazebo仿真掉轴"></a>gazebo仿真掉轴</h2><h3 id="排查是否由于使用solidworks导出文件有误"><a href="#排查是否由于使用solidworks导出文件有误" class="headerlink" title="排查是否由于使用solidworks导出文件有误"></a>排查是否由于使用solidworks导出文件有误</h3><p>在gazebo中将重力(gravity)关闭，观察机器人是否正常起立, 若能正常起立，则为ros_gazebo_control部分没有配置好；ros_gazebo_control的控制参数形式如下：</p><p><img src="/img/postImg/1_ros/KDL/gazebo_simulation/control_parameters_vie.png" alt=""></p><p>其中<code>i_clamp</code>为积分限幅（相当于死区控制），防止积分项过度累积，导致控制器输出不稳定的影响；</p><h1 id="找不到要链接的动态链接库路径"><a href="#找不到要链接的动态链接库路径" class="headerlink" title="找不到要链接的动态链接库路径"></a>找不到要链接的动态链接库路径</h1><p>编译正常，但是运行的时候会报出如下的错误</p><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error </span>while loading shared libraries: liborocos-kdl.so.1.5: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>那么在编译时需指明运行时链接的库的位置，参考代码如下所示(l为小写的L，且-Wl逗号后面不能有空格)</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">g++ <span class="selector-tag">main</span><span class="selector-class">.cpp</span> -lorocos-kdl -Wl,<span class="attr">--rpath</span>=/usr/local/lib</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在安装了ROS的情况下，KDL库的相关路径已经被添加到环境变量中，则可以直接链接，否则需要给出库的完整路径，此外，若有添加库路径到环境变量中的方法，应该也可以实现仅给出库的名称而不列出完整路径</p><h1 id="其他未归类事项"><a href="#其他未归类事项" class="headerlink" title="其他未归类事项"></a>其他未归类事项</h1><p>建立软连接（用于自己修改KDL源码并在ROS中仿真）：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo ln -s <span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>liborocos-kdl-models.so <span class="regexp">/usr/</span>local<span class="regexp">/include/</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://github.com/SarvagyaVaish/Orocos-KDL-Forward-Kinematics">Orocos-KDL-Forward-Kinematics</a></p><p>[2] <a href="https://www.guyuehome.com/37371">机器人KDL库（Kinematic Solvers）</a></p><p>[3] <a href="https://blog.csdn.net/weixin_43956732/article/details/106908452">PyKDL—-运动段、运动链和运动树</a></p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> KDL </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS launch</title>
      <link href="/2023/09/13/archived_ros_launch/"/>
      <url>/2023/09/13/archived_ros_launch/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#简介">简介</a></li><li><a href="#xml">XML</a><ul><li><a href="#计算次序">计算次序</a></li><li><a href="#替代参数substitution-args">替代参数(Substitution args)</a></li><li><a href="#if和unless属性">If和unless属性</a></li></ul></li><li><a href="#launch文件案例">launch文件案例</a><ul><li><a href="#简单案例">简单案例</a></li><li><a href="#重映射机制">重映射机制</a></li><li><a href="#复杂案例">复杂案例</a></li><li><a href="#参数服务器">参数服务器</a></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>如果<code>rosrun</code>是执行一个节点的命令，那么<code>roslaunch</code>是运行多个节点的概念。该命令允许运行多个确定的节点。其他功能还包括一些专为执行具有诸多选项的节点的ROS命令，比如包括更改功能包参数或节点名称、配置节点命名空间、设置<code>ROS_ROOT</code>和<code>ROS_PACKAGE_PATH</code>以及更改环境变量等。</p><p>roslaunch使用*.launch文件来设置可执行节点，它基于可扩展标记语言（XML），并提供XML标记形式的多种选项。像许多ROS包会有相应的启动配置，通过运行下面的指令来进行启动</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">roslaunch package_name <span class="built_in">file</span>.<span class="built_in">launch</span></span><br></pre></td></tr></table></figure><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="计算次序"><a href="#计算次序" class="headerlink" title="计算次序"></a>计算次序</h2><p>roslaunch与XML文件单一传递。include是按照深度优先遍历的顺序处理。标签tag进行串行处理并且最后的设置有效。因此，若一个参数被多次设置，最后指定的值将被使用。 比较推荐的是使用<code>$(arg)/&lt;arg&gt;</code>设置来进行重写行为。</p><h2 id="替代参数-Substitution-args"><a href="#替代参数-Substitution-args" class="headerlink" title="替代参数(Substitution args)"></a>替代参数(Substitution args)</h2><p>launch文件支持替代参数，roslaunch将在启动节点之前对其进行解析。当前支持的替代参数有：</p><p>1) $(env ENVIRONMENT_VARIABLE)：用环境变量替换变量的值。如果未设置环境变量，则启动将失败。此值不能被<env>标记覆盖。</p><p>2) $(optenv ENVIRONMENT_VARIABLE)：如果设置了环境变量的值，则替换该值。若提供default_value，则在未设置环境变量的情况下使用default_value。若未提供default_value，则将使用空字符串。default_value可以是多个单词，并用空格分隔。</p><p>例如：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;param <span class="attribute">name</span>=<span class="string">&quot;foo&quot;</span> <span class="attribute">value</span>=<span class="string">&quot;<span class="variable">$(optenv NUM_CPUS 1)</span>&quot;</span> /&gt;</span><br><span class="line">&lt;param <span class="attribute">name</span>=<span class="string">&quot;foo&quot;</span> <span class="attribute">value</span>=<span class="string">&quot;<span class="variable">$(optenv CONFIG_PATH /home/marvin/ros_workspace)</span>&quot;</span> /&gt;</span><br><span class="line">&lt;param <span class="attribute">name</span>=<span class="string">&quot;foo&quot;</span> <span class="attribute">value</span>=<span class="string">&quot;<span class="variable">$(optenv VARIABLE ros rocks)</span>&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>NUM_CPUS的default_value为1；VARIABLE的default_value为ros和rocks。</p><p>3) <code>$(find pkg)</code>: 指定相对于软件包的路径。</p><p>例如：查找rospy子目录下的manifest.xml文件。</p><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">find</span> rospy)/manifest.xml</span><br></pre></td></tr></table></figure><p>4) <code>$(anon name)</code>：根据名称生成匿名id，id不能重名。例如：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;node <span class="attribute">name</span>=<span class="string">&quot;<span class="variable">$(anon foo)</span>&quot;</span> <span class="attribute">pkg</span>=<span class="string">&quot;rospy_tutorials&quot;</span> <span class="attribute">type</span>=<span class="string">&quot;talker.py&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>5) $(eval <expression>)：用于计算任意复杂的python表达式。例如：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;param <span class="attribute">name</span>=<span class="string">&quot;circumference&quot;</span> <span class="attribute">value</span>=<span class="string">&quot;<span class="variable">$(eval 2.* 3.1415 * arg(&#x27;radius&#x27;)</span>)&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>6) <code>$(dirname)</code>：返回启动文件所在目录的绝对路径。例如：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">include</span> <span class="keyword">file</span>=<span class="string">&quot;$(dirname)/other.launch&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>file指向当前launch文件所在目录下的other.launch文件。</p><p>7) <code>$(arg foo)</code>: 计算由<arg>标签指定的值，在声明arg的同一启动文件中必须有对应的<arg>标签。例如</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;param <span class="attribute">name</span>=<span class="string">&quot;foo&quot;</span> <span class="attribute">value</span>=<span class="string">&quot;<span class="variable">$(arg my_foo)</span>&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>将指定 my_foo 到 foo 参数, 另外一个例子：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;node <span class="attribute">name</span>=<span class="string">&quot;add_two_ints_server&quot;</span> <span class="attribute">pkg</span>=<span class="string">&quot;beginner_tutorials&quot;</span> <span class="attribute">type</span>=<span class="string">&quot;add_two_ints_server&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;node <span class="attribute">name</span>=<span class="string">&quot;add_two_ints_client&quot;</span> <span class="attribute">pkg</span>=<span class="string">&quot;beginner_tutorials&quot;</span> <span class="attribute">type</span>=<span class="string">&quot;add_two_ints_client&quot;</span> <span class="attribute">args</span>=<span class="string">&quot;<span class="variable">$(arg a)</span> <span class="variable">$(arg b)</span>&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>将会从 <add\_tow\_ints> 例子中启动server和client,作为参数值a和传递。产生的启动项目能用如下语句调用：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">roslaunch beginner tutorials launch_file<span class="selector-class">.launch</span> <span class="selector-tag">a</span>:=<span class="number">1</span> <span class="selector-tag">b</span>:=<span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="If和unless属性"><a href="#If和unless属性" class="headerlink" title="If和unless属性"></a>If和unless属性</h2><p>所有标签都支持if和unless属性，这些属性基于值的评估包含或不包含在标签内。 “ 1”和“ true”被视为真实值。 “ 0”和“ false”被视为错误值。 其他值将出错。</p><p><code>if=value (optional)</code>：如果value评估为true，则包含标记及其内容。<br><code>unless=value (optional)</code>：如果value的值为false，则包含标记及其内容。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span> <span class="attr">if</span>=<span class="string">&quot;$(arg foo)&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 此处的代码仅当foo为true时才被读取 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 满足unless条件时不会设置此参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">unless</span>=<span class="string">&quot;$(arg foo)&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure><h1 id="launch文件案例"><a href="#launch文件案例" class="headerlink" title="launch文件案例"></a>launch文件案例</h1><h2 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h2><p>以下案例具备最基本的启动文件配置。它启动一个单独的“talker”节点，该节点是“rospy_tutorials”软件包的一部分。 该节点将使用当前配置的ROS环境（即ROS_ROOT等）在本地计算机上启动。</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">  &lt;node name<span class="operator">=</span><span class="string">&quot;talker&quot;</span> pkg<span class="operator">=</span><span class="string">&quot;rospy_tutorials&quot;</span> type<span class="operator">=</span><span class="string">&quot;talker&quot;</span> /&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><h2 id="重映射机制"><a href="#重映射机制" class="headerlink" title="重映射机制"></a>重映射机制</h2><p> ROS提供一种重映射的机制，简单来说就是取别名，类似于C++中的别名机制，不需要修改别人功能包的接口，只需要将接口名称重映射一下，取个别名。launch文件中的<remap>标签可以帮我们实现这个重映射的功能。 比如turtlebot的键盘控制节点，发布的速度控制指令话题可能是/turtlebot/cmd_vel，但是我们自己的机器人订阅的速度控制话题是/cmd_vel，这个时候使用<code>remap</code>就可以轻松解决问题，将/turtlebot /cmd_vel重映射为/cmd_vel，机器人就可以接收到速度控制指令了：</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&lt;remap from<span class="operator">=</span><span class="string">&quot;/turtlebot/cmd_vel&quot;</span>to<span class="operator">=</span><span class="string">&quot;/cmd_vel&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>重映射机制在ROS中的使用非常广泛，也非常重要，方法不止这一种，也可以在终端rosrun命令中实现重映射;</p><h2 id="复杂案例"><a href="#复杂案例" class="headerlink" title="复杂案例"></a>复杂案例</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- local machine already has a definition by default.</span></span><br><span class="line"><span class="comment">       This tag overrides the default definition with</span></span><br><span class="line"><span class="comment">       specific ROS_ROOT and ROS_PACKAGE_PATH values --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">machine</span> <span class="attr">name</span>=<span class="string">&quot;local_alt&quot;</span> <span class="attr">address</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ros-root</span>=<span class="string">&quot;/user/ros/&quot;</span> <span class="attr">ros-package-path</span>=<span class="string">&quot;/user/ros/ros-pkg&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- a basic listener node --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;listener-1&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rospy_tutorials&quot;</span> <span class="attr">type</span>=<span class="string">&quot;listener&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- pass args to the listener node --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;listener-2&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rospy_tutorials&quot;</span> <span class="attr">type</span>=<span class="string">&quot;listener&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-foo arg2&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- a respawn-able listener node --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;listener-3&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rospy_tutorials&quot;</span> <span class="attr">type</span>=<span class="string">&quot;listener&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- start listener node in the &#x27;wg1&#x27; namespace --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">ns</span>=<span class="string">&quot;wg1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;listener-wg1&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rospy_tutorials&quot;</span> <span class="attr">type</span>=<span class="string">&quot;listener&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- start a group of nodes in the &#x27;wg2&#x27; namespace --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">&quot;wg2&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- remap applies to all future statements in this scope. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;chatter&quot;</span> <span class="attr">to</span>=<span class="string">&quot;hello&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rospy_tutorials&quot;</span> <span class="attr">type</span>=<span class="string">&quot;listener&quot;</span> <span class="attr">name</span>=<span class="string">&quot;listener&quot;</span> <span class="attr">args</span>=<span class="string">&quot;--test&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;rospy_tutorials&quot;</span> <span class="attr">type</span>=<span class="string">&quot;talker&quot;</span> <span class="attr">name</span>=<span class="string">&quot;talker&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- set a private parameter for the node --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;talker_1_param&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a value&quot;</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- nodes can have their own remap args --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;chatter&quot;</span> <span class="attr">to</span>=<span class="string">&quot;hello-1&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- you can set environment variables for a node --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">env</span> <span class="attr">name</span>=<span class="string">&quot;ENV_EXAMPLE&quot;</span> <span class="attr">value</span>=<span class="string">&quot;some value&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参数服务器"><a href="#参数服务器" class="headerlink" title="参数服务器"></a>参数服务器</h2><p>可以在参数服务器上设置参数，这些参数将在启动任何节点之前存储在参数服务器上。如果值是明确的，则可以省略type属性。支持的类型为str，int，double，bool。例子如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;somestring1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;bar&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- force to string instead of integer --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;somestring2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> <span class="attr">type</span>=<span class="string">&quot;str&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;someinteger1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;someinteger2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;somefloat1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.14159&quot;</span> <span class="attr">type</span>=<span class="string">&quot;double&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;somefloat2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.0&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- you can set parameters in child namespaces --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;wg/childparam&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a child namespace parameter&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- upload the contents of a file to the server --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;configfile&quot;</span> <span class="attr">textfile</span>=<span class="string">&quot;$(find roslaunch)/example.xml&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- upload the contents of a file as base64 binary to the server --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;binaryfile&quot;</span> <span class="attr">binfile</span>=<span class="string">&quot;$(find roslaunch)/example.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]. 《ROS机器人编程—从基本概念到机器人应用程序编程实战》</p><p>[2]. <a href="https://www.guyuehome.com/34772">ROS入门（二）：launch文件解析</a></p><p>[3]. <a href="https://www.guyuehome.com/2195">ROS探索总结（五十六）—— launch文件</a></p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> ROS </tag>
            
            <tag> launch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代机器人学：角速度</title>
      <link href="/2023/09/11/archived_Modern_Robotics_Angular_Velocity/"/>
      <url>/2023/09/11/archived_Modern_Robotics_Angular_Velocity/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#反对称矩阵">反对称矩阵</a></li><li><a href="#角速度表示">角速度表示</a></li><li><a href="#空间角速度">空间角速度</a></li><li><a href="#空间旋转轴的表示方法">空间旋转轴的表示方法</a></li><li><a href="#物体角速度的解释">物体角速度的解释</a></li><li><a href="#更容易理解的推导">更容易理解的推导</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><p>在了解角速度这块的时候，有必要了解一些基础的知识；</p><h1 id="反对称矩阵"><a href="#反对称矩阵" class="headerlink" title="反对称矩阵"></a>反对称矩阵</h1><div align="center"> <img src="/img/postImg/32_robotics/角速度相关/反对称矩阵的矩阵表示.png" width="10%" height="10%"> </div><p>称其为反对称矩阵，将向量表示成反对称矩阵如下</p><p><img src="/img/postImg/32_robotics/角速度相关/反对称矩阵的向量表示.png" style="zoom:6%;" /></p><p>后面用符号<strong>[x]</strong>来表示向量x的反对称矩阵，将所有的3*3反对称矩阵称为so(3), 其中so表示反对称矩阵，定义如下</p><p><img src="/img/postImg/32_robotics/角速度相关/so定义.png" style="zoom:7%;" /></p><p>其中反对称矩阵so(3)称为SO(3)群的李代数，SO表示特殊正交（special orthogonal）的意思, 特殊在detR=+1,用于表示空间中的旋转矩阵，其SO的定义如下</p><p><img src="/img/postImg/32_robotics/角速度相关/特殊正交群的SO定义.png" style="zoom:15%;" /></p><h1 id="角速度表示"><a href="#角速度表示" class="headerlink" title="角速度表示"></a>角速度表示</h1><p>R可以表示空间中的旋转，那如果想知道空间旋转的角速度，是不是直接求导就行了？和他提出的疑问是一样的</p><p><img src="/img/postImg/32_robotics/角速度相关/是否能以R的求导来表示空间的角速度呢.png" style="zoom:45%;" /></p><p>当然不能直接求导，因为矩阵里面有9个变量，只希望用三个变量来表示角速度，我们知道，角速度可以通过一个旋转轴和对应的旋转速度来表示</p><p><img src="/img/postImg/32_robotics/角速度相关/角速度的表示方法.png" alt=""></p><h1 id="空间角速度"><a href="#空间角速度" class="headerlink" title="空间角速度"></a>空间角速度</h1><p>这里假设了旋转轴为<img src="/img/postImg/mathSym/omega_s.png" width="1%" height="1%"> , 是一个相对于惯性坐标系，也可以称之为静止坐标系，为了单位的统一，这里可以假设旋转轴为单位旋转向量，其中单位向量的识别符为在上面加个帽子，即<img src="/img/postImg/mathSym/hat_omega_s.png" width="1%" height="1%"> ，用单位旋转轴乘以其速率，即可得到角速度向量<img src="/img/postImg/mathSym/omega_s.png" width="1%" height="1%"> ,即</p><p><img src="/img/postImg/32_robotics/角速度相关/空间角速度.png" style="zoom:3%;" /></p><p><img src="/img/postImg/32_robotics/角速度相关/角速度向量w_s.png" alt=""></p><p>这样坐标系{b}在绕这个轴旋转时，其x轴方向将相对于s坐标系画一个圆，</p><p><img src="/img/postImg/32_robotics/角速度相关/坐标系绕轴旋转时，坐标系b的X轴.png" alt=""></p><p>不难得到，坐标系{b}的三个轴的速度可以表示为</p><p><img src="/img/postImg/32_robotics/角速度相关/物体坐标系的速度.png" style="zoom:5%;" /></p><p>利用括号运算符（表示叉乘）， 通过上式，就可以直接得到如下关系式了（比直接看机器人操作的数学导论更容易理解，那书中就直接定义了，也没给出解释，搞得有点懵）</p><p><img src="/img/postImg/32_robotics/角速度相关/空间速度与旋转矩阵之间的关系.png" style="zoom:10%;" /></p><h1 id="空间旋转轴的表示方法"><a href="#空间旋转轴的表示方法" class="headerlink" title="空间旋转轴的表示方法"></a>空间旋转轴的表示方法</h1><p>相对于s坐标系的旋转矩阵一般可以省略下标，通过以上推导，就不难得到第一个重要的公式，即</p><p><img src="/img/postImg/32_robotics/角速度相关/重要公式1，空间旋转轴的表示方法.png" style="zoom:10%;" /></p><p>当然，这里给出的角速度是相对于空间坐标系的，当然可以相对于物体坐标系，通过下标对消规则，<img src="/img/postImg/mathSym/omega_b.png" width="1%" height="1%"> 可以表示为</p><p><img src="/img/postImg/32_robotics/角速度相关/omega_b.png" style="zoom:10%;" /></p><p>下面得到第二个重要公式前，需要知道一个定理，即</p><p><img src="/img/postImg/32_robotics/角速度相关/关于反对称矩阵的一个重要定理.png" style="zoom:5%;" /></p><p>这样不难推导出第二个重要公式，即</p><p><img src="/img/postImg/32_robotics/角速度相关/第二个重要公式.png" style="zoom:15%;" /></p><h1 id="物体角速度的解释"><a href="#物体角速度的解释" class="headerlink" title="物体角速度的解释"></a>物体角速度的解释</h1><p>值得注意的是：<img src="/img/postImg/mathSym/omega_b.png" width="1.7%" height="1.7%">并不是相对动坐标系的角速度；确切地说，<img src="/img/postImg/mathSym/omega_b.png" width="1.7%" height="1.7%"> 表示的是相对静坐标系{b}的角速度，{b}只是与运动刚体随动坐标系瞬时重合。另外还需要注意一点，这里无论对  <img src="/img/postImg/mathSym/dot_R.png" width="1%" height="1%"> 左乘还是右乘 <img src="/img/postImg/mathSym/R_T.png" width="1%" height="1%"> 都会得到有关角速度的一个反对称矩阵，只是相对的坐标系不同。</p><h1 id="更容易理解的推导"><a href="#更容易理解的推导" class="headerlink" title="更容易理解的推导"></a>更容易理解的推导</h1><p>根据坐标变换公式：</p><p><img src="/img/postImg/32_robotics/角速度相关/只考虑旋转的坐标变换公式.png" style="zoom:100%;" /></p><p>对上式左右同时求导:</p><p><img src="/img/postImg/32_robotics/角速度相关/只考虑旋转的坐标变换公式同时两边求导.png" style="zoom:100%;" /></p><p>因为 p是附着在刚体上的, 所以p相对于刚体坐标系下的速度为0，故有</p><p><img src="/img/postImg/32_robotics/角速度相关/角速度的推导结束.png" style="zoom:100%;" /></p><p>可以看出 <img src="/img/postImg/mathSym/dot_R.png" width="1%" height="1%"><img src="/img/postImg/mathSym/R_1.png" width="1.7%" height="1.7%"> 将点的位置变成了点的线速度。又有角速度和线速度的公式:</p><p><img src="/img/postImg/32_robotics/角速度相关/角速度与线速度的公式.png" style="zoom:100%;" /></p><p>所以有空间角速度</p><p><img src="/img/postImg/32_robotics/角速度相关/空间角速度表达式.png" style="zoom:100%;" /></p><p>对于自己而言，这种方式推导出的结果，记忆效果最佳；</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] 现代机器人学</p><p>[2] 机器人学笔记——中科院软件所</p>]]></content>
      
      
      <categories>
          
          <category> ROBOTICS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> robotics </tag>
            
            <tag> velocity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda 常用指令介绍</title>
      <link href="/2023/09/06/archived_conda/"/>
      <url>/2023/09/06/archived_conda/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#列出所有环境">列出所有环境</a></li><li><a href="#激活环境">激活环境</a></li><li><a href="#创建环境">创建环境</a></li><li><a href="#删除环境">删除环境</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为经常会用到其他人的Python代码，版本不一，安装的配置不一，故需要使用到conda作为环境的管理工具，下面列出自己在mac/Term下频繁使用到的一些conda指令；</p><h1 id="列出所有环境"><a href="#列出所有环境" class="headerlink" title="列出所有环境"></a>列出所有环境</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/conda/conda_env_list.png" style="zoom:100%;" /></p><h1 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h1><p>这个一般在<code>bashrc</code>或者<code>zshrc</code>中直接起别名就好了，比如自己在zhsrc中的定义</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> py2=&#x27;conda <span class="built_in">activate</span> py2&#x27;</span><br><span class="line"><span class="built_in">alias</span> py3=&#x27;conda <span class="built_in">activate</span> py3&#x27;</span><br><span class="line"><span class="built_in">alias</span> py38=&#x27;conda <span class="built_in">activate</span> py38&#x27;</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/conda/python_version_list.png" style="zoom:100%;" /></p><p>然后直接在命令行中输入<code>py2</code>就可以切换环境了，比较方便</p><h1 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h1><p>这个比较简单，用下面的方式可以创建一个Python版本为3.8的</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">conda</span> create --name py38 python=<span class="number">3</span>.<span class="number">8</span></span><br></pre></td></tr></table></figure><p>类似的，在zshrc中起个别名就行了</p><h1 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h1><p>删除环境的时候注意需要从所删除的环境中退出，用下面指令可以直接删除</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">remove</span> -n conda_name <span class="comment">--all</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PYTHON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URDF</title>
      <link href="/2023/08/25/archived_ros_URDF/"/>
      <url>/2023/08/25/archived_ros_URDF/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#简介">简介</a></li><li><a href="#搭建模型">搭建模型</a><ul><li><a href="#material">material</a></li><li><a href="#link">link</a><ul><li><a href="#连杆标签的属性">连杆标签的属性</a></li></ul></li><li><a href="#joint">joint</a></li></ul></li><li><a href="#辅助工具">辅助工具</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近需要对运动学以及动力学做一些相关仿真以及实现，故需要了解以及设计一些可视化模型，相关的知识点将会放到这里；另外需要说明的是，solidworks可以导出此部分文件，因此这部分内容作为了解即可，<br>或者是以后可能需要修改一些参数而需要用到的一部分知识。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>URDF(Unified Robot Description Format)，统一机器人描述格式，是一种特殊的xml格式，用来描述一个机器人. 在ROS中，urdf功能包包含一个urdf格式文件的C++解析器，这样，任何通过统一编码格式设计的机器人都可以通过该解析器得到一个可视化的模型.</p><p>URDF创造的机器人模型包含的内容有：</p><blockquote><p>连杆 link<br>关节 joint<br>运动学参数 axis<br>动力学参数 dynamics<br>可视化模型 visual<br>碰撞检测模型 collision</p></blockquote><h1 id="搭建模型"><a href="#搭建模型" class="headerlink" title="搭建模型"></a>搭建模型</h1><p>最终想要搭建的模型效果如下</p><div align="center"> <img src="/img/postImg/1_ros/URDF/最终想实现的三关节四连杆的结果.png" width="80%" height="40%"> </div><p>下面一步步的说明搭建的过程(这里假设所有的包，如OpenManipulator Chain的源代码、URDF、Gazebo和MoveIt！都已安装好的前提下)</p><p>按如下所示创建testbot_description功能包，然后创建urdf目录。然后使用编辑器创建一个testbot.urdf文件，并输入下面的URDF例程。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg testbot_description urdf</span><br><span class="line"><span class="built_in">cd</span> testbot_description</span><br><span class="line"><span class="built_in">mkdir</span> urdf</span><br><span class="line"><span class="built_in">cd</span> urdf</span><br><span class="line">vim testbot.urdf</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;testbot&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.0 0.0 0.0 1.0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;orange&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1.0 0.4 0.0 1.0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;fixed&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;link1&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;link1&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.25&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.1 0.1 0.5&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.25&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.1 0.1 0.5&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.25&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">iyy</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">izz</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;joint1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;revolute&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;link1&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;link2&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.5&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 1&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">limit</span> <span class="attr">effort</span>=<span class="string">&quot;30&quot;</span> <span class="attr">lower</span>=<span class="string">&quot;-2.617&quot;</span> <span class="attr">upper</span>=<span class="string">&quot;2.617&quot;</span> <span class="attr">velocity</span>=<span class="string">&quot;1.571&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;link2&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.25&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.1 0.1 0.5&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.25&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.1 0.1 0.5&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;orange&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.25&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">iyy</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">izz</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;joint2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;revolute&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;link2&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;link3&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.5&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">limit</span> <span class="attr">effort</span>=<span class="string">&quot;30&quot;</span> <span class="attr">lower</span>=<span class="string">&quot;-2.617&quot;</span> <span class="attr">upper</span>=<span class="string">&quot;2.617&quot;</span> <span class="attr">velocity</span>=<span class="string">&quot;1.571&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;link3&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.5&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.1 0.1 1&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.5&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.1 0.1 1&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.5&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">iyy</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">izz</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;joint3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;revolute&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;link3&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;link4&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 1.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">limit</span> <span class="attr">effort</span>=<span class="string">&quot;30&quot;</span> <span class="attr">lower</span>=<span class="string">&quot;-2.617&quot;</span> <span class="attr">upper</span>=<span class="string">&quot;2.617&quot;</span> <span class="attr">velocity</span>=<span class="string">&quot;1.571&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;link4&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.25&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.1 0.1 0.5&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.25&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.1 0.1 0.5&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;orange&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.25&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">iyy</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">izz</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>URDF使用XML标签来描述机器人的每个组件。以URDF形式先描述机器人的名称、 基座（在URDF中将基座看作一个固定的连杆）的名称和类型、连接到基座的连杆，之后逐一说明连杆和关节的内容。连杆描述连杆的名称、大小、重量和惯性等。关节描述每个关节的名称、类型和连接的连杆。并且可以很容易地设置机器人的动力学元素、可视化和碰撞模型。URDF是以<robot>标签来开始，详细内容中通常会反复交替出现<link>标签和<joint>标签，这两种标签都用于定义机器人的组件-连杆和关节。其中，为了与ROSControl共用，通常还包括用于设置关节和舵机之间的关系的<transmission>标签;</p><h2 id="material"><a href="#material" class="headerlink" title="material"></a>material</h2><p>material标签描述连杆的颜色和纹理等信息。在下面的例子中，定义了两种材质，黑色和橙色，以区分每个连杆。颜色是利用color标签，可以在rgba选项后面输入对应于红色、绿色和蓝色的三个0.0到1.0之间的一个数字来分别设置。最后一个数字的透明度（alpha）值为0.0到1.0，值为1.0意味着没有透明度。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">”black”</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.0 0.0 0.0 1.0&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;orange&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1.0 0.4 0.0 1.0&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><p>机械手臂的第一种组件，基座在URDF中以连杆表示。基座通过关节连接到第一个连杆，这个关节是固定的，位于原点（0,0,0）。为了进行更多关于<link>标签的详细描述，先来看第一个连杆（link1）标签。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">”base”/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;fixed&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;link1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;link1&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.25&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.1 0.1 0.5&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.25&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.1 0.1 0.5&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.25&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">iyy</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">izz</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上面的例子，URDF <link>标签由碰撞（collision）、视觉（visual）和惯性（inertial）标签组成</p><h3 id="连杆标签的属性"><a href="#连杆标签的属性" class="headerlink" title="连杆标签的属性"></a>连杆标签的属性</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span>：      连杆的可视化、碰撞和惯性信息设置</span><br><span class="line"><span class="tag">&lt;<span class="name">collision</span>&gt;</span>： 设置连杆的碰撞计算的信息</span><br><span class="line"><span class="tag">&lt;<span class="name">visual</span>&gt;</span>：    设置连杆的可视化信息</span><br><span class="line"><span class="tag">&lt;<span class="name">inertial</span>&gt;</span>：  设置连杆的惯性信息</span><br><span class="line"><span class="tag">&lt;<span class="name">mass</span>&gt;</span>：      连杆重量（单位：kg）的设置</span><br><span class="line"><span class="tag">&lt;<span class="name">inertia</span>&gt;</span>：   惯性张量（Inertia tensor）设置</span><br><span class="line"><span class="tag">&lt;<span class="name">origin</span>&gt;</span>：    设置相对于连杆相对坐标系的移动和旋转</span><br><span class="line"><span class="tag">&lt;<span class="name">geometry</span>&gt;</span>：  输入模型的形状。提供box、cylinder、sphere等形态，也可以导入COLLADA</span><br><span class="line">（.dae）、STL（.stl）格式的设计文件。在<span class="tag">&lt;<span class="name">collision</span>&gt;</span>标签中，可以指定为简单的</span><br><span class="line">形态来减少计算时间</span><br><span class="line"><span class="tag">&lt;<span class="name">material</span>&gt;</span>：  设置连杆的颜色和纹理</span><br></pre></td></tr></table></figure><div align="center"> <img src="/img/postImg/1_ros/URDF/单个连杆的建模参数.png" width="40%" height="40%"> </div><h2 id="joint"><a href="#joint" class="headerlink" title="joint"></a>joint</h2><p>关节标签描述了关节的特征，具体来说它描述关节的名称和类型，如revolute（旋转运动型）、 prismatic(平移运动型）、continuous（连续旋转的轮）、fixed（固定型）、floating （非固定）和planar（在与轴垂直的平面移动的形态）。它还描述连接的两个连杆的名 称、关节的位置、旋转和平移运动的基准轴的动作限制。连接的连杆根据位置称为父连杆 （parent link）和子连杆（child link），父连杆通常是靠近基座的连杆。关节参数可参考下图中所示</p><div align="center"> <img src="/img/postImg/1_ros/URDF/关节的建模参数.png" width="40%" height="40%"> </div><p>以下示例显示了joint2关节的设置。</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&lt;joint name<span class="operator">=</span>”joint2” type<span class="operator">=</span>”revolute”&gt;</span><br><span class="line"> &lt;parent link<span class="operator">=</span><span class="string">&quot;link2&quot;</span>/&gt;</span><br><span class="line"> &lt;child link<span class="operator">=</span><span class="string">&quot;link3&quot;</span>/&gt;</span><br><span class="line"> &lt;origin xyz<span class="operator">=</span><span class="string">&quot;0 0 0.5&quot;</span> rpy<span class="operator">=</span><span class="string">&quot;0 0 0&quot;</span>/&gt;</span><br><span class="line"> &lt;axis xyz<span class="operator">=</span><span class="string">&quot;0 1 0&quot;</span>/&gt;</span><br><span class="line"> &lt;limit effort<span class="operator">=</span><span class="string">&quot;30&quot;</span> lower<span class="operator">=</span><span class="string">&quot;-2.617&quot;</span> upper<span class="operator">=</span><span class="string">&quot;2.617&quot;</span> velocity<span class="operator">=</span><span class="string">&quot;1.571&quot;</span>/&gt;</span><br><span class="line">&lt;/joint&gt;</span><br></pre></td></tr></table></figure><p>完成建模后，我们来检查每个连杆和关节，看它们是否逻辑正确。在ROS中，可以用 <code>check_urdf</code>命令来检查已创建的URDF的语法错误以及每个连杆的连接关系，如下例所示。如果在语法和逻辑上没有问题，则可以看到连杆1、2、3和4正常连接，如下所示。</p><div align="center"> <img src="/img/postImg/1_ros/URDF/check_urdf.png" width="40%" height="40%"> </div><p>如果提示没有check_urdf命令，在命令行中输入如下即可</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install liburdfdom-tools</span><br></pre></td></tr></table></figure><p>接下来，来用关系图表示urdf_to_graphiz程序创建的模型。如果运行 urdf_to_graphiz，则会创建一个.gv文件和一个.pdf文件。如果用PDF阅读器，可以一目了然地看到连杆与关节之间的关系，以及每个关节之间的相对坐标转换，</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">urdf_to_graphiz testbot.urdf</span><br><span class="line">Created <span class="keyword">file</span> testbot.<span class="keyword">gv</span></span><br><span class="line">Created <span class="keyword">file</span> testbot.pdf</span><br></pre></td></tr></table></figure><p>用pdf阅读器打开所生成的PDF文件，如下所示</p><div align="center"> <img src="/img/postImg/1_ros/URDF/testbot.png" width="40%" height="40%"> </div><p>用check_urdf和urdf_to_graphiz是检查模型的连杆关系的最快的方法。 下面使用RViz检查机器人模型。转至testbot_description功能包目录并创建一个testbot.launch文件，在命令行中输入如下指令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src/testbot_description</span><br><span class="line"><span class="built_in">mkdir</span> launch</span><br><span class="line"><span class="built_in">cd</span> launch</span><br><span class="line">gedit testbot.launch</span><br></pre></td></tr></table></figure><p>并输入如下内容</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line"> &lt;arg name<span class="operator">=</span><span class="string">&quot;model&quot;</span> default<span class="operator">=</span><span class="string">&quot;$(find testbot_description)/urdf/testbot.urdf&quot;</span> /&gt;</span><br><span class="line"> &lt;arg name<span class="operator">=</span><span class="string">&quot;gui&quot;</span> default<span class="operator">=</span><span class="string">&quot;True&quot;</span> /&gt;</span><br><span class="line"> &lt;param name<span class="operator">=</span><span class="string">&quot;robot_description&quot;</span> textfile<span class="operator">=</span><span class="string">&quot;$(arg model)&quot;</span> /&gt;</span><br><span class="line"> &lt;param name<span class="operator">=</span><span class="string">&quot;use_gui&quot;</span> value<span class="operator">=</span><span class="string">&quot;$(arg gui)&quot;</span>/&gt;</span><br><span class="line"> &lt;node pkg<span class="operator">=</span><span class="string">&quot;joint_state_publisher&quot;</span> type<span class="operator">=</span><span class="string">&quot;joint_state_publisher&quot;</span> name<span class="operator">=</span><span class="string">&quot;joint_state_publisher&quot;</span>/&gt;</span><br><span class="line"> &lt;node pkg<span class="operator">=</span><span class="string">&quot;robot_state_publisher&quot;</span> type<span class="operator">=</span><span class="string">&quot;state_publisher&quot;</span> name<span class="operator">=</span><span class="string">&quot;robot_state_publisher&quot;</span>/&gt;</span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><p>Launch文件由包含URDF的参数、joint_state_publisher 节点和robot_state_publisher节点组成。joint_state_publisher节点通过sensor_msgs/JointState消息的形式发布URDF形式的机器人的关节状态，并提供一个GUI工具来给关节提供命令。 robot_state_publisher节点以tf消息的形式发布forward kinematics的结果，这个结果是由URDF中设置的机器人信息和sensor_msgs/JointState话题信息来计算得出的。</p><h1 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h1><p>有直接可以从DH参数生成URDF文件的，网址链接为： <code>https://adohaha.github.io/DH2URDF/</code>, 但是。。。。没有通过check(可能需要在这个基础上稍微改改)….这就尴尬了，于是接着搜索，在github上找到了 <a href="https://github.com/yunlongdong/RoboticsInOne">RoboticsInOne</a>, 于是在自己的MAC上进行了简单的试用，当然，也是有很多坑需要去踩的，配置环境产生了一系列的问题，因为不断地去试，所以就没能一点点的记录整个试的过程了，下面记录一些比较重要的点</p><p>1， 利用conda安装所需Python的配置环境, 主要是去解决wxpython的一些问题, 当时的报错信息如下</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">This program needs <span class="keyword">access</span> <span class="keyword">to</span> the screen. Please run <span class="keyword">with</span> a Framework</span><br><span class="line">build <span class="keyword">of</span> python, <span class="keyword">and</span> <span class="keyword">only</span> <span class="keyword">when</span> you are <span class="keyword">logged</span> <span class="keyword">in</span> <span class="keyword">on</span> the main display</span><br><span class="line"><span class="keyword">of</span> your Mac.</span><br></pre></td></tr></table></figure><p>解决方式如下：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">conda <span class="keyword">install</span> python.app</span><br></pre></td></tr></table></figure><p>然后再利用这个环境，来跑<code>RIO.py</code>这个函数，例如自己这边的操作为</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>zhangxiaolong<span class="regexp">/miniconda3/</span>bin/python.app RIO.py</span><br></pre></td></tr></table></figure><p>剩下的就是缺了啥包，就安装啥包就行，最简单粗暴的方式就是直接进入python的命令行, 以缺少 ‘wxPython’ 为例</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>zhangxiaolong<span class="regexp">/miniconda3/</span>bin/python.app</span><br></pre></td></tr></table></figure><p>在Python的命令行中输入</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import pip </span><br><span class="line">pip<span class="selector-class">.main</span>(<span class="selector-attr">[<span class="string">&#x27;install&#x27;</span>, <span class="string">&#x27;wxPython&#x27;</span>]</span>)</span><br></pre></td></tr></table></figure><p>以此类推即可，虽然解决方式有些繁琐，但最后也是成功了的，就没必要研究更快更好的方法了。。。。。。最后可以打开里面的用例，以库卡机器人为例，效果如下</p><p><img src="/img/postImg/1_ros/URDF/RoboticsInOne_demo_kuka.png" alt=""></p><p>自然，里面给的urdf模型是可以通过check的；可以拿里面提供的URDF文件进行仿真，当然，想找到URDF仿真来说，相对来说是个比较简单的问题;</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://zhuanlan.zhihu.com/p/41939935">ROS开发——URDF简介</a></p><p>[2]《ROS机器人编程—从基本概念到机器人应用程序编程实战》</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> ros </tag>
            
            <tag> urdf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分贝 dB</title>
      <link href="/2023/08/24/archived_dB_%E5%88%86%E8%B4%9D/"/>
      <url>/2023/08/24/archived_dB_%E5%88%86%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#什么是分贝">什么是分贝</a></li><li><a href="#分贝的定义">分贝的定义</a></li><li><a href="#常见参考值">常见参考值</a></li><li><a href="#-3-db">-3 dB</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="什么是分贝"><a href="#什么是分贝" class="headerlink" title="什么是分贝"></a>什么是分贝</h1><p>关于分贝 dB， 人们的第一感觉认为是声音的大小单位, 但实际上它不是一个单位， 它是个无量纲量。 经常在声学、 振动、 电子学、 电信、 音频工程和设计等领域见到它。</p><h1 id="分贝的定义"><a href="#分贝的定义" class="headerlink" title="分贝的定义"></a>分贝的定义</h1><p>分贝 dB 定义为两个数值的对数比率， 这两个数值分别是测量值和参考值 （也称为基准值）。 存在两种定义形式：</p><p>1, 一种为功率之比：</p><div align="center"> <img src="/img/postImg/17_Control/dB/dB_def_1.png" width="10%" height="10%"> </div><p>2, 一种为幅值之比(功率与电压的平方成正比)：</p><div align="center"> <img src="/img/postImg/17_Control/dB/dB_def_2.png" width="20%" height="20%"> </div><p>下标为 0 的数值均为幅值和功率的参考值。因为分贝值完全依赖于测量值与参考值之比， 因此， 计算时选择合适的参考值尤为关键。当测量结果相互比较时， 这一点非常重要， 选择的参考值不同， 计算结果肯定不一样。</p><h1 id="常见参考值"><a href="#常见参考值" class="headerlink" title="常见参考值"></a>常见参考值</h1><p>在不同领域中，分贝的参考值不同。例如：</p><p>&bull; 声音强度：以20μPa 作为参考声压。</p><p>&bull; 通信信号：以1mW作为参考功率，记作 dBm。 </p><p>&bull; 电压：以1V或其他电压作为参考。</p><h1 id="3-dB"><a href="#3-dB" class="headerlink" title="-3 dB"></a>-3 dB</h1><p>-3dB 对应的幅值比为 0.707。 如果按功率比计算，则功率比为 1/2，即原来功率的一半， 因此，- 3dB 称为 “半功率点”, 在振动教材中，有用半功率带宽法求阻尼的方法。半功率带宽法求阻尼的公式为</p><p><img src="/img/postImg/17_Control/dB/半功率带宽法求阻尼的公式.png" alt=""></p><p>在幅频曲线的峰值wr,处的左右两侧，找到峰值幅值的0.707倍处w1和w2,这两点称为 “半功率点”。因此，这种阻尼比估计方法称为半功率带宽法，如图所示</p><p><img src="/img/postImg/17_Control/dB/半功率带宽求阻尼.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] &lt;&lt;从这里学NVH噪声、 振动、 模态分析的入门与进阶&gt;&gt; — 谭祥军 编著</p>]]></content>
      
      
      <categories>
          
          <category> CONTROL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> control </tag>
            
            <tag> dB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC 配置与相关工具推荐</title>
      <link href="/2023/08/22/continue_MacBookConfigure/"/>
      <url>/2023/08/22/continue_MacBookConfigure/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#禁止生成-ds_store-文件">禁止生成 .DS_Store 文件</a></li><li><a href="#命令行批量处理照片">命令行批量处理照片</a><ul><li><a href="#配置环境">配置环境</a><ul><li><a href="#imagemagick">imagemagick</a></li><li><a href="#jpegoptim--optipng">jpegoptim &amp; optipng</a></li></ul></li></ul></li></ul><!-- vim-markdown-toc --><h1 id="禁止生成-DS-Store-文件"><a href="#禁止生成-DS-Store-文件" class="headerlink" title="禁止生成 .DS_Store 文件"></a>禁止生成 .DS_Store 文件</h1><p>macOS可以通过命令行修改系统配置，让系统不再在文件夹中生成这个配置文件，命令如下：<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">defaults <span class="built_in">write</span> com.apple.desktopservices DSDontWriteNetworkStores <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h1 id="命令行批量处理照片"><a href="#命令行批量处理照片" class="headerlink" title="命令行批量处理照片"></a>命令行批量处理照片</h1><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>输入如下命令行指令配置环境</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span>update</span><br><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>imagemagick</span><br><span class="line"><span class="keyword">brew </span><span class="keyword">install </span><span class="keyword">jpegoptim</span></span><br></pre></td></tr></table></figure><h3 id="imagemagick"><a href="#imagemagick" class="headerlink" title="imagemagick"></a>imagemagick</h3><p>下面给出具体的例子如，图片尺寸修改为原图的85%</p><figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">convert -resize <span class="number">85</span><span class="built_in">%x</span>85% <span class="built_in">$img</span> <span class="built_in">$img</span>-resized<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>限定宽度和高度</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">convert</span> -resize 1024x800 <span class="variable">$img</span> <span class="variable">$img</span>-resized;</span><br></pre></td></tr></table></figure><p>指定宽度，高度自适应</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">convert</span> -resize 1024x <span class="variable">$img</span> <span class="variable">$img</span>-resized;</span><br></pre></td></tr></table></figure><h3 id="jpegoptim-amp-optipng"><a href="#jpegoptim-amp-optipng" class="headerlink" title="jpegoptim &amp; optipng"></a>jpegoptim &amp; optipng</h3><p>jpegoptim 是针对jpg或者jpeg格式的图片进行压缩，optipng是针对png格式的图片进行压缩的，以jpegoptim为例</p><p>优化图片所占硬盘空间 (直接修改原图)</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">jpegoptim <span class="attribute">--size</span>=400 <span class="variable">$img</span></span><br></pre></td></tr></table></figure><p>批量处理可参考如下shell指令</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> your_path -name <span class="string">&quot;*.jpg&quot;</span> | xargs jpegoptim</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MAC BOOK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 构建功能包</title>
      <link href="/2023/08/12/archived_ros_%E6%9E%84%E5%BB%BA%E5%8A%9F%E8%83%BD%E5%8C%85_2023/"/>
      <url>/2023/08/12/archived_ros_%E6%9E%84%E5%BB%BA%E5%8A%9F%E8%83%BD%E5%8C%85_2023/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#创建功能包">创建功能包</a></li><li><a href="#编写源代码">编写源代码</a></li><li><a href="#构建功能包">构建功能包</a></li><li><a href="#运行节点">运行节点</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里以一个例子来阐述下怎么搭建功能包的过程, 在整个构建的过程莫过于CMakeLists编写内容所代表含义那块有点不理解，多看几遍书和其他人写的博客也就慢慢的理解了；</p><h1 id="创建功能包"><a href="#创建功能包" class="headerlink" title="创建功能包"></a>创建功能包</h1><p>创建ROS功能包的命令如下:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">catkin_create_pkg <span class="selector-attr">[功能包名称]</span> <span class="selector-attr">[依赖功能包1]</span> <span class="selector-attr">[依赖功能包n]</span></span><br></pre></td></tr></table></figure><p>“catkin_create_pkg”命令在创建用户功能包时会生成catkin 构建系统所需的CMakeLists.txt和package.xml文件的包目录, 这部分专门做了记录，这里不再赘述。输入命令行移动到工作的目录:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br></pre></td></tr></table></figure><p>和书籍[1]里面保持一致，使用以下命令创建一个名为my_first_ros_pkg的功能包：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">catkin_create_pkg my_first_ros_pkg std_msgs roscpp</span></span><br></pre></td></tr></table></figure><p>上面用“std_msgs”和“roscpp”作为前面命令格式中的依赖功能包的选项。这意味着为了使用ROS的标准消息包std_msgs和客户端库roscpp（为了在ROS中使用C/C++），在创建功能包之前先进行这些选项安装。这些相关的功能包的设置可以在创建功能包时指定，也可以在创建之后直接在package.xml中输入。</p><p>如果已经创建了功能包，“~/catkin_ws/src”会创建“my_first_ros_pkg”功能包目录、ROS功能包应有的内部目录以及CMakeLists.txt和package.xml文件。可通过如下指令去查看此目录下的文件内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> my_first_ros_pkg</span><br></pre></td></tr></table></figure><p>修改构建配置文件<code>CMakeLists</code>:</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(my_first_ros_pkg)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(catkin REQUIRED COMPONENTS roscpp std_msgs)</span></span></span><br><span class="line"><span class="function"><span class="title">catkin_package</span><span class="params">(CATKIN_DEPENDS roscpp std_msgs)</span></span></span><br><span class="line"><span class="function"><span class="title">include_directories</span><span class="params">($&#123;catkin_INCLUDE_DIRS&#125;)</span></span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(hello_world_node src/hello_world_node.cpp)</span></span></span><br><span class="line"><span class="function"><span class="title">target_link_libraries</span><span class="params">(hello_world_node $&#123;catkin_LIBRARIES&#125;)</span></span></span><br></pre></td></tr></table></figure><h1 id="编写源代码"><a href="#编写源代码" class="headerlink" title="编写源代码"></a>编写源代码</h1><p>在上述CMakelists.txt文件的可执行文件创建部分（add_executable）中，进行了以下设置:</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(hello_world_node src/hello_world_node.cpp)</span></span></span><br></pre></td></tr></table></figure><p>换句话说，是引用功能包的src目录中的<code>hello_world_node.cpp</code>源代码来生成hello_world_node可执行文件。由于这里没有hello_world_node.cpp源代码，需要进行编写，<br>首先，用cd命令转到功能包目录中包含源代码的目录（src），并创建hello_world_node.cpp文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src/my_first_ros_pkg/src/</span><br><span class="line"><span class="built_in">touch</span> hello_world_node.cpp</span><br></pre></td></tr></table></figure><p>之后如下修改代码:</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_msgs/String.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;hello_world_node&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::Publisher chatter_pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::<span class="type">String</span>&gt;(<span class="string">&quot;say_hello_world&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">            std_msgs::<span class="type">String</span> msg;</span><br><span class="line">            std::stringstream ss;</span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; count;</span><br><span class="line">            msg.data = ss.<span class="built_in">str</span>();</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;%s&quot;</span>, msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">            chatter_pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">            ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">            loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">            ++count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构建功能包"><a href="#构建功能包" class="headerlink" title="构建功能包"></a>构建功能包</h1><p>所有构建功能包的准备工作都已完成。在构建之前，使用以下命令更新ROS功能包的配置文件。这是一个将之前创建的功能包反映在ROS功能包列表的命令，这并不是必选操作，但在创建新功能包后更新的话使用时会比较方便。</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rospack profile</span></span><br></pre></td></tr></table></figure><p>之后进行catkin构建。移动到catkin工作目录后进行catkin构建</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws &amp;&amp; catkin_make</span><br></pre></td></tr></table></figure><p>构建成功后，可参考下图所示</p><p><img src="/img/postImg/1_ros/1_构建系统/hello_world_node_builting_OK.png" width="100%" height="100%"> </p><h1 id="运行节点"><a href="#运行节点" class="headerlink" title="运行节点"></a>运行节点</h1><p>如果构建无误，那么将在“~/catkin_ws/devel/lib/my_first_ros_pkg”中生成“hello_world_node”文件。 下一步是运行该节点，打开一个终端窗口（Ctrl + Alt + t）并在运行该节点之前先运行roscore。请注意，运行roscore后，ROS中的所有节点都可用，除非退出了roscore，否则只需运行一次。</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">roscore</span></span><br></pre></td></tr></table></figure><p>最后，打开一个新的终端窗口（Ctrl + Alt + t）并使用以下命令运行节点。这是在名为my_first_ros_pkg的功能包中运行名为hello_world_node的节点的命令。</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rosrun my_first_ros_pkg hello_world_node</span></span><br></pre></td></tr></table></figure><p>运行效果如图所示</p><p><img src="/img/postImg/1_ros/1_构建系统/ros_run_my_first_pkg_OK.png" width="100%" height="100%"> </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]. 《ROS机器人编程—从基本概念到机器人应用程序编程实战》</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome做web性能分析</title>
      <link href="/2023/08/11/archived_chrome%E5%81%9Aweb%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
      <url>/2023/08/11/archived_chrome%E5%81%9Aweb%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#详细步骤">详细步骤</a></li><li><a href="#面板大致功能列表">面板大致功能列表</a></li><li><a href="#推荐软件">推荐软件</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>优化网站加载速度时候，发现了一部分有用的知识点，记录于此；</p><h1 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h1><p>要使用Chrome进行Web性能分析，可以利用Chrome开发者工具的性能面板来监测网页加载过程中的各种性能指标。以下是详细步骤：</p><p>1, 打开Chrome浏览器：确保你已经安装了最新版本的Chrome浏览器。</p><p>2, 打开目标网页：在Chrome浏览器中打开你要进行性能分析的网页。</p><p>3, 打开开发者工具：有多种方法可以打开开发者工具，最常见的方法是通过右键点击网页上的任何地方，然后选择“检查”或“审查元素”，或者使用快捷键”Ctrl+Shift+I”（Windows/Linux）或”Cmd+Option+I”（Mac）。</p><p>4, 切换到性能面板：在开发者工具中，你会看到一些选项卡，如“Elements”、“Console”、“Sources”等等。选择“Performance”（或者你可能会看到“Performance”选项卡上的一个类似鼓的图标）。</p><p>5, 开始记录性能：点击性能面板上的录制按钮（红色的圆点），开始记录网页的性能数据。你可以选择记录的时间范围，通常建议记录整个页面加载过程。</p><p>6, 操作网页：在记录期间，可以在网页上执行各种操作，如点击链接、滚动页面等，以模拟用户与网页的交互。</p><p>7, 停止记录性能：完成网页上的操作后，点击性能面板上的停止按钮（红色的方块）来停止记录性能数据。</p><p>8, 分析性能数据：现在你会在性能面板上看到网页加载过程中的各种性能指标，例如网络请求、DOMContentLoaded时间、页面完全加载时间等等。你可以在这里找到有关页面性能的重要信息。</p><p>9, 查看性能分析：你可以在图表中看到性能数据的可视化展示，帮助你理解页面加载的过程。</p><p>10, 优化：根据性能数据，你可以识别出潜在的性能问题。根据问题的类型，你可以采取相应的优化措施，例如优化代码、减少网络请求、使用缓存等等，以提升网页的加载速度和用户体验。</p><h1 id="面板大致功能列表"><a href="#面板大致功能列表" class="headerlink" title="面板大致功能列表"></a>面板大致功能列表</h1><div class="table-container"><table><thead><tr><th>名称             &emsp;</th><th>描述</th></tr></thead><tbody><tr><td>Elements 面板   &emsp;</td><td>可以查看 DOM 结构、编辑 CSS 样式，用于测试页面布局和设计页面。</td></tr><tr><td>Console 面板    &emsp;</td><td>可以看成是 JavaSeript Shell，能执行 JavaScript 脚本。通过 Console 还能和页面中的 JavaScrip 对象交互。</td></tr><tr><td>Sources 面板    &emsp;</td><td>1. 查看 Web 应用加载的所有文件<br />2. 编辑 CSS 和 JavaScript 文件内容<br />3.  将打乱的 CSS 文件或者 JavaScript 文件格式化：<br/>4. 支持 JavaScript 的调试功能：<br/>5. 设置工作区，将更改的文件保存到本地文件夹中</td></tr><tr><td>NetWork面板     &emsp;</td><td>展示了页面中所有的请求内容列表，能查看每项请求的请求行、请求头、请求体、时间线以及网络请求瀑布图等信息</td></tr><tr><td>Performance 面板&emsp;</td><td>记录和查看 Web 应用生命周期内的各种事件，并用来分析在执行过程中一些影响性能的要点</td></tr><tr><td>Memory 面板     &emsp;</td><td>用来查看运行过程中的 JavaScript 占用堆内存情况，追踪是否存在内存泄漏的情况等</td></tr><tr><td>Application面板 &emsp;</td><td>1. 查看 Web 应用的数据存储情况<br/>2. PWA 的基础数据：IndexedDB: Web SQL：本地和会话存储：Cookie：应用程序缓存：图像：字体和样式表等</td></tr><tr><td>Security面板    &emsp;</td><td>显示当前页面一些基础的安全信息</td></tr><tr><td>Audits 面板     &emsp;</td><td>会对当前网页进行网络利用情况、网页性能方面的诊断，并给出一些优化建议 Layers 面板展示一些渲染过程中分层的基础信息。</td></tr><tr><td>Layers 面板     &emsp;</td><td>展示一些渲染过程中分层的基础信息。</td></tr></tbody></table></div><h1 id="推荐软件"><a href="#推荐软件" class="headerlink" title="推荐软件"></a>推荐软件</h1><p>1, Fiddler Everywhere， 抓包软件;<br>2, 若用到，后续再补充;</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]. chatGPT<br>[2]. <a href="https://blog.poetries.top/browser-working-principle/guide/part5/lesson21.html#chrome-%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7">浏览器工作原理与实践</a></p>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uml类图解释及其常用绘制工具</title>
      <link href="/2023/08/10/archived_uml%E7%B1%BB%E5%9B%BE%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%BB%98%E5%88%B6%E5%B7%A5%E5%85%B72023/"/>
      <url>/2023/08/10/archived_uml%E7%B1%BB%E5%9B%BE%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%BB%98%E5%88%B6%E5%B7%A5%E5%85%B72023/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#uml-类图介绍">UML 类图介绍</a></li><li><a href="#使用-doxygen-从源代码生成-uml-类图">使用 Doxygen 从源代码生成 UML 类图</a></li><li><a href="#mermaid绘制流程图的语法">Mermaid绘制流程图的语法</a></li><li><a href="#命令行生成">命令行生成</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="UML-类图介绍"><a href="#UML-类图介绍" class="headerlink" title="UML 类图介绍"></a>UML 类图介绍</h1><p>在UML类图中，箭头和线的样式用于表示类与类之间的关系。以下是各种关系及其对应的箭头和线的含义：</p><p>1, 关联（Association）：<br>箭头：普通箭头（实心箭头或空心箭头，通常是实心箭头）。<br>线：通常是直线，连接两个类的关联关系。<br>含义：表示两个类之间的静态关系，表示一个类与另一个类之间的连接。关联是一种比较强的关系，表明两个类之间存在关联，但不一定是紧密耦合的。</p><p>2, 聚集（Aggregation）：<br>箭头：带空心菱形的箭头。<br>线：通常是直线，连接一个整体与其部分。<br>含义：表示整体与部分之间的关系，整体可以包含部分，但部分可以独立存在。聚集表示一种弱关系，整体的生命周期不依赖于部分的生命周期。</p><p>3, 组合（Composition）：<br>箭头：带实心菱形的箭头。<br>线：通常是直线，连接一个整体与其部分。<br>含义：表示整体与部分之间的关系，整体包含部分，部分不能独立存在，它们的生命周期是紧密耦合的。组合表示一种强关系，整体的生命周期取决于部分的生命周期。</p><p>4, 依赖（Dependency）：<br>箭头：带箭头的虚线。<br>线：通常是虚线，连接一个使用另一个类的类。<br>含义：表示一个类的实现或行为依赖于另一个类。依赖是一种比较弱的关系，表示类之间的一种使用关系，当一个类的变化可能影响到另一个类时，它们之间存在依赖关系。</p><h1 id="使用-Doxygen-从源代码生成-UML-类图"><a href="#使用-Doxygen-从源代码生成-UML-类图" class="headerlink" title="使用 Doxygen 从源代码生成 UML 类图"></a>使用 Doxygen 从源代码生成 UML 类图</h1><p>1, 安装Doxygen：首先，需要安装Doxygen工具。可以从Doxygen的官方网站（<a href="https://www.doxygen.nl/download.html）下载并安装适合的操作系统版本。">https://www.doxygen.nl/download.html）下载并安装适合的操作系统版本。</a><br>2, 配置Doxyfile：Doxygen使用名为Doxyfile的配置文件来指定需要生成的文档和设置。在项目根目录下创建一个名为Doxyfile的文件。可以使用以下命令在项目根目录生成默认的Doxyfile：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">doxygen -<span class="selector-tag">g</span> Doxyfile</span><br></pre></td></tr></table></figure><p>3, 配置Doxyfile中的参数：打开Doxyfile文件，并设置以下参数：<br> 1)<code>INPUT</code>：指定源代码目录，你可以在这里列出你希望生成UML类图的源代码目录。<br> 2)<code>GENERATE_UML</code>：设置为YES，允许Doxygen生成UML图。<br> 3)<code>UML_LOOK</code>：设置为YES以生成较为简洁的UML类图（可选）。<br> 4)<code>UML_LIMIT_NUM_FIELDS</code>：设置生成的UML图中类的最大字段数量（可选）。<br> 5)<code>UML_LIMIT_NUM_RELATIONS</code>：设置生成的UML图中类之间的最大关系数量（可选）。<br>注意：确保删除或注释掉EXTRACT_ALL和EXTRACT_PRIVATE等参数，以便Doxygen生成所有类的UML类图。<br>4, 运行Doxygen：配置完成后，使用以下命令运行Doxygen：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">doxygen Doxyfile</span></span><br></pre></td></tr></table></figure><p>运行完成后，Doxygen将在输出目录中生成文档。<br>5, 查看生成的UML类图：打开生成的文档，在文档中应该可以找到生成的UML类图，通常以SVG或PNG格式呈现。</p><p>请注意，Doxygen生成的UML类图可能相对简单，特别是在大型项目中，因为它主要关注源代码的文档生成。如果需要更复杂的UML图，可能需要使用其他专业的UML建模工具，如Enterprise Architect、Visual Paradigm等。</p><h1 id="Mermaid绘制流程图的语法"><a href="#Mermaid绘制流程图的语法" class="headerlink" title="Mermaid绘制流程图的语法"></a>Mermaid绘制流程图的语法</h1><p>Mermaid是一种简洁易读的文本描述语言，用于绘制流程图、时序图、甘特图等各种图表。下面是Mermaid绘制流程图的基本语法:</p><p>1, 定义节点和连接关系：<br>    1) 使用graph或flowchart关键字开始绘图，然后使用TD（从上到下）或LR（从左到右）来指定节点排列方式。<br>    2) 使用—&gt;定义连接箭头，箭头可以用来连接两个节点。<br>    3) 使用—-定义没有箭头的连接线。<br>节点标识符通常由字母、数字、下划线和连字符组成。</p><p>2, 定义节点的形状和样式：<br>    1) 使用[ ]来定义方形节点。<br>    2) 使用[ ]]来定义圆角矩形节点。<br>    3) 使用(( ))来定义圆形节点。<br>    4) 使用{ }来定义菱形节点。<br>    5) 使用样式选项来更改节点的外观，如style、class和stroke等。</p><p>3, 添加子图：<br>    1) 使用子图可以在一个节点内部绘制更复杂的流程图。<br>    2) 使用subgraph关键字开始子图，然后在其中定义节点和连接。<br>    3) 使用end关键字结束子图。</p><p>下面是一个示例Mermaid流程图的代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">graph <span class="selector-tag">TD</span>;</span><br><span class="line">    <span class="selector-tag">A</span>((开始)) --&gt; <span class="selector-tag">B</span><span class="selector-attr">[处理A]</span>;</span><br><span class="line">    <span class="selector-tag">B</span> --&gt; C<span class="selector-attr">[处理B]</span>;</span><br><span class="line">    <span class="selector-tag">B</span> --&gt; D<span class="selector-attr">[处理C]</span>;</span><br><span class="line">    C --&gt; E<span class="selector-attr">[处理D]</span>;</span><br><span class="line">    D --&gt; E;</span><br><span class="line">    E --&gt; F((结束));</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了几个节点，例如(开始)、[处理A]、{ }、((结束))等，并用箭头—&gt;表示连接关系。</p><p>注意，Mermaid语法不区分大小写，并且注释以%%开头。</p><h1 id="命令行生成"><a href="#命令行生成" class="headerlink" title="命令行生成"></a>命令行生成</h1><p>非常可惜的是官网在生成图片的时候特别慢，有的时候试了十几次，没错，是十几次，都没有生成出来PNG图片，一开始以为是自己网络问题导致的，后面发现，无论网络好不好都生成不了，推荐使用命令行的方式来生成，首先配置好命令行下所需的环境</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g @mermaid-js/mermaid-cli</span><br></pre></td></tr></table></figure><p>然后创建文件后缀名为<code>.mmd</code>, 采用如下命令行即可生成PNG图片</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">mmdc -<span class="selector-tag">i</span> test<span class="selector-class">.mmd</span> -o blue<span class="selector-class">.png</span> -w <span class="number">1080</span> -h <span class="number">3600</span> -t forest -<span class="selector-tag">b</span> transparent</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]. chatGPT 的回答</p>]]></content>
      
      
      <categories>
          
          <category> TOOLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Python给图片加文字</title>
      <link href="/2023/07/18/archived_python_%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E6%96%87%E5%AD%97/"/>
      <url>/2023/07/18/archived_python_%E5%9B%BE%E7%89%87%E6%B7%BB%E5%8A%A0%E6%96%87%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><p>导入所需要的库</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFont</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageDraw</span><br></pre></td></tr></table></figure><p>添加字体（需要设置，可以不设置），加文字, 代码参考如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFont</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageDraw</span><br><span class="line"></span><br><span class="line"><span class="comment">#打开底版图片</span></span><br><span class="line">imageFile = <span class="string">&quot;test.jpg&quot;</span></span><br><span class="line">tp=Image.<span class="built_in">open</span>(imageFile)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在图片上添加文字</span></span><br><span class="line">draw = ImageDraw.Draw(tp)</span><br><span class="line">draw.text((<span class="number">100</span>, <span class="number">100</span>),<span class="string">&quot;测试文字&quot;</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存</span></span><br><span class="line">tp.save(<span class="string">&quot;testOutput.png&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://blog.csdn.net/weixin_45240714/article/details/123233036">Python在图片上添加文字</a></p>]]></content>
      
      
      <categories>
          
          <category> PYTHON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> figure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 的CMakeLists编写</title>
      <link href="/2023/07/12/archived_ros_CMakeLists_write/"/>
      <url>/2023/07/12/archived_ros_CMakeLists_write/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#总体结构和顺序">总体结构和顺序</a></li><li><a href="#cmake版本">CMake版本</a></li><li><a href="#软件包包名">软件包包名</a></li><li><a href="#查找编译依赖的cmake包">查找编译依赖的CMake包</a><ul><li><a href="#find_package做了什么">find_package()做了什么？</a></li><li><a href="#为何将catkin软件包指定为组件">为何将Catkin软件包指定为组件？</a></li><li><a href="#boost库">Boost库</a></li></ul></li><li><a href="#catkin_package">catkin_package()</a></li><li><a href="#明确编译的目标">明确编译的目标</a><ul><li><a href="#目标命名">目标命名</a></li><li><a href="#自定义输出目录">自定义输出目录</a></li><li><a href="#头文件和库路径">头文件和库路径</a></li><li><a href="#include_directories">include_directories()</a></li><li><a href="#link_directories">link_directories()</a></li><li><a href="#可执行目标">可执行目标</a></li><li><a href="#库目标">库目标</a></li></ul></li><li><a href="#target_link_libraries">target_link_libraries</a></li><li><a href="#消息服务和操作目标">消息、服务和操作目标</a><ul><li><a href="#重要的前提和限制">重要的前提和限制</a></li><li><a href="#例子">例子</a></li></ul></li><li><a href="#启动python模块支持">启动Python模块支持</a></li><li><a href="#单元测试">单元测试</a></li><li><a href="#可选步骤明确安装目标">可选步骤：明确安装目标</a><ul><li><a href="#安装python可执行脚本">安装Python可执行脚本</a></li><li><a href="#安装头文件">安装头文件</a></li><li><a href="#安装roslaunch文件或其他源">安装roslaunch文件或其他源</a></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="总体结构和顺序"><a href="#总体结构和顺序" class="headerlink" title="总体结构和顺序"></a>总体结构和顺序</h1><p>CMakeList.txt文件必须遵循如下的格式，不然就无法正确地编译(编译ROS软件包时提示“ROS未定义的引用”的错误，原因就是CMakeList.txt文件中命令顺序不正确)。</p><ul><li>必需的CMake版本：cmake_minimum_required()</li><li>软件包名：project()</li><li>查找编译依赖的其他CMake/Catkin包(声明依赖库)：find_package()</li><li>启动Python模块支持：catkin_python_package()</li><li>消息/服务/操作(Message/Service/Action)生成器：add_message_files(),add_service_files(),add_action_files()</li><li>调用消息/服务/操作生成：generate_messages()</li><li>指定包编译信息导出：catkin_package()</li><li>添加要编译的库和可执行文件：add_library()/add_executable()/target_link_libraries()</li><li>测试编译：catkin_add_gtest()</li><li>安装规则：install()</li></ul><h1 id="CMake版本"><a href="#CMake版本" class="headerlink" title="CMake版本"></a>CMake版本</h1><p>每一个catkin CMakeList.txt文件必须以所需的CMake版本说明语句开始，Catkin需要2.8.3或者更高的版本</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cmake_minimum_required</span>(VERSION <span class="number">2</span>.<span class="number">8</span>.<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h1 id="软件包包名"><a href="#软件包包名" class="headerlink" title="软件包包名"></a>软件包包名</h1><p>软件包报名使用CMake的 project()函数指明，例如以robot_brain命名一个软件包：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">project</span><span class="params">(robot_brain)</span></span></span><br></pre></td></tr></table></figure><p>CMake中，可以通过使用变量 ${PROJECT_NAME}在CMake脚本后面的任何位置引用项目名称。</p><h1 id="查找编译依赖的CMake包"><a href="#查找编译依赖的CMake包" class="headerlink" title="查找编译依赖的CMake包"></a>查找编译依赖的CMake包</h1><p>编译一个项目，需要使用CMake 的 find_package函数确定依赖的其他CMake包并找到它们，一般情况下至少会有一个catkin依赖：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(catkin REQUIRED)</span></span></span><br></pre></td></tr></table></figure><p>除此之外，项目依赖的其他软件包，都会自动成为catkin的组件(components)(就CMake而言)。因此可以将这些依赖包指定为catkin的组件，而不必再使用find_package，这样将会变得简单，例如依赖包nodelet：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(catkin REQUIRED COMPONENTS nodelet)</span></span></span><br></pre></td></tr></table></figure><p>注意：只能find_package那些想要编译标志的组件，不能添加运行时(runtime)依赖。 当然也可以写成下面的方式，但不方便:</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(catkin REQUIRED)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(nodelet REQUIRED)</span></span></span><br></pre></td></tr></table></figure><h2 id="find-package-做了什么？"><a href="#find-package-做了什么？" class="headerlink" title="find_package()做了什么？"></a>find_package()做了什么？</h2><p> 如果CMake通过 find<em>package()查找到一个软件包，它就会创建几个CMake环境变量，以提供有关已查找到的软件包的信息。这些环境变量可以在后面的CMake脚本中使用，它们表示软件包导出的头文件所在的位置、源文件所在的位置、软件包依赖的库以及这些库的查找路径，环境变量的名字遵循<PACKAGENAME>\</em><PROPERTY>，即包名-属性：</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">NAME</span>&gt;<span class="variable">_FOUND</span>：当库被查找到时置为<span class="literal">true</span>，否则为<span class="literal">false</span></span><br><span class="line">&lt;<span class="built_in">NAME</span>&gt;<span class="variable">_INCLUDE_DIRS</span>或&lt;<span class="built_in">NAME</span>&gt;<span class="variable">_INCLUDES</span>：软件包导出的头文件路径</span><br><span class="line">&lt;<span class="built_in">NAME</span>&gt;<span class="variable">_LIBRARIES</span>或&lt;<span class="built_in">NAME</span>&gt;<span class="variable">_LIBS</span>：软件包导出的库的路径</span><br><span class="line">&lt;<span class="built_in">NAME</span>&gt;<span class="variable">_DEFINITIONS</span>：</span><br></pre></td></tr></table></figure><h2 id="为何将Catkin软件包指定为组件？"><a href="#为何将Catkin软件包指定为组件？" class="headerlink" title="为何将Catkin软件包指定为组件？"></a>为何将Catkin软件包指定为组件？</h2><p> Catkin软件包严格意义上并不是catkin的组件，而且，CMake的功能组件功能被用于catkin的设计，以节省大量的打字时间。 对于catkin软件包，以catkin的组件的方式 find_package它们是有好处的，因为这个过程以catkin_prefix的形式创建了一组环境变量。例如，在程序中要使用nodelet软件包，推荐查找软件包的方式是：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(catkin REQUIRED COMPONENTS nodelet)</span></span></span><br></pre></td></tr></table></figure><h2 id="Boost库"><a href="#Boost库" class="headerlink" title="Boost库"></a>Boost库</h2><p>如果使用C++和Boost库，需要在Boost上调用 find_package()，并指定Boost中将要作为组件的那部分。例如，如果想要使用Boost的线程，可以用：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(Boost REQUIRED COMPONENTS thread)</span></span></span><br></pre></td></tr></table></figure><h1 id="catkin-package"><a href="#catkin-package" class="headerlink" title="catkin_package()"></a>catkin_package()</h1><p>catkin_package()是一个由catkin提供的CMake宏。需要指定特定的catkin信息到编译系统，而这些信息又会被用于生成pkg-config和CMake文件。 该函数必须在使用 add_library()或add_executable()声明任何targets之前调用。其5个可选参数：</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">INCLUDE_DIRS：软件包导出的头文件路径(例如cflags)</span><br><span class="line">LIBRARIES：项目导出的库</span><br><span class="line"><span class="built_in">CATKIN_DEPENDS</span>：当前项目依赖的其他catkin项目</span><br><span class="line">DEPENDS：当前项目依赖的非catkin <span class="built_in">CMake</span>项目，详细解释参见这里</span><br><span class="line"><span class="built_in">CFG_EXTRAS</span>：其他的配置选项</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">catkin_package( INCLUDE_DIRS <span class="keyword">include</span>  </span><br><span class="line">                LIBRARIES <span class="variable">$&#123;PROJECT_NAME&#125;</span>   </span><br><span class="line">                CATKIN_DEPENDS roscpp nodelet   </span><br><span class="line">                DEPENDS eigen opencv)</span><br></pre></td></tr></table></figure><p>这里表明软件包文件夹中的include文件夹是导出头文件的位置，CMake环境变量 ${PROJECT_NAME}将会鉴定之前传递给project()函数的所有内容，在这种情况下它作为“robot_brain”。“roscpp”+“nodelet”是编译/运行此程序包需要存在的软件包，“eigen”+“opencv”是编译/运行此程序包时需要存在的系统依赖项(ROS packages有时会需要操作系统提供一些外部函数库，这些函数库就是所谓的“系统依赖项”)。</p><h1 id="明确编译的目标"><a href="#明确编译的目标" class="headerlink" title="明确编译的目标"></a>明确编译的目标</h1><p>编译目标可以采取多种形式，但通常它们代表两种可能性之一：</p><ul><li>可执行目标：可以运行的程序</li><li>库目标：在编译和/或运行时可以由可执行目标使用的库</li></ul><h2 id="目标命名"><a href="#目标命名" class="headerlink" title="目标命名"></a>目标命名</h2><p>非常重要的一点是，不管编译/安装到哪个文件夹中，编译目标在catkin中的名称都必须是唯一的。这是CMake的一项要求，但目标唯一的名称又只是在CMake内部是必需的。可以使用set_target_properties()函数对目标重命名，例如</p><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">set_target_properties</span>(<span class="variable">rviz_image_view</span> </span></span><br><span class="line"><span class="function">                      <span class="variable">PROPERTIES</span> <span class="variable">OUTPUT_NAME</span> <span class="variable">image_view</span></span></span><br><span class="line"><span class="function">                      <span class="variable">PREFIX</span> <span class="string">&quot;&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>这会在编译和安装输出中将目标 rviz_image_view的名称改为image_view。</p><h2 id="自定义输出目录"><a href="#自定义输出目录" class="headerlink" title="自定义输出目录"></a>自定义输出目录</h2><p>可执行文件和库的默认输出目录通常设置为了合理的值，但在某些情况下必须进行自定义，例如，包含Python绑定的库必须放置在不同的文件夹中才能在Python中导入。 例子：</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">set_target_properties(python_module_library  PROPERTIES LIBRARY_OUTPUT_DIRECTORY </span></span><br><span class="line"><span class="language-xml"></span><span class="template-variable">&#123;CATKIN_DEVEL_PREFIX&#125;</span><span class="language-xml">/</span><span class="template-variable">&#123;CATKIN_PACKAGE_PYTHON_DESTINATION&#125;</span><span class="language-xml">)</span></span><br></pre></td></tr></table></figure><h2 id="头文件和库路径"><a href="#头文件和库路径" class="headerlink" title="头文件和库路径"></a>头文件和库路径</h2><p>在指定目标之前，需要指定可以为所述目标找到资源的位置，特别是头文件和库：</p><ul><li>头文件目录：将要编译的代码(C/C++)所需的头文件路径</li><li>库目录：可执行目标编译指向的库路径</li><li>include_directories(<dir1>, <dir2>, …, <dirN>)</li><li>link_directories(<dir1>, <dir2>, …, <dirN>)</li></ul><h2 id="include-directories"><a href="#include-directories" class="headerlink" title="include_directories()"></a>include_directories()</h2><p>include_directories的参数应该是由调用find_package生成的* _INCLUDE_DIRS变量以及需要包含的任何其他目录。如果使用catkin和Boost，include_directories()的调用为：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">include_directories</span><span class="params">(include &#123;Boost_INCLUDE_DIRS&#125; &#123;catkin_INCLUDE_DIRS&#125;)</span></span></span><br></pre></td></tr></table></figure><p>第一个参数“include”表示包中的include/目录也是路径的一部分。</p><h2 id="link-directories"><a href="#link-directories" class="headerlink" title="link_directories()"></a>link_directories()</h2><p>CMake的 link_directories()函数可以添加其他的库目录，然而，并不推荐这么做。所有的catkin和CMake包在find_package时都会自动添加链接信息。只需链接到target_link_libraries()中的库。</p><p>例子：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">link_directories</span><span class="params">(~/my_libs)</span></span></span><br></pre></td></tr></table></figure><h2 id="可执行目标"><a href="#可执行目标" class="headerlink" title="可执行目标"></a>可执行目标</h2><p>要指定必须编译的可执行目标，必须使用CMake函数 add_executable()。声明想要的可执行文件的文件名，以此生成此可执行文件所需的源文件列表，如果有多个源文件，用空格区分开。例如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">add_executable(myProgram <span class="attribute">src</span>/<span class="selector-tag">main</span><span class="selector-class">.cpp</span> <span class="attribute">src</span>/some_file<span class="selector-class">.cpp</span> <span class="attribute">src</span>/another_file<span class="selector-class">.cpp</span>)</span><br></pre></td></tr></table></figure><p>该命令会编译名为 myProgram的可执行文件，它是由后面的三个源文件共同编译生成的。</p><h2 id="库目标"><a href="#库目标" class="headerlink" title="库目标"></a>库目标</h2><p>CMake函数 add_library()指定用于编译的库文件，默认情况下，catkin编译共享库。<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">add_library</span><span class="params">(&#123;PROJECT_NAME&#125; &#123;$&#123;PROJECT_NAME&#125;_SRCS&#125;)</span></span></span><br></pre></td></tr></table></figure></p><h1 id="target-link-libraries"><a href="#target-link-libraries" class="headerlink" title="target_link_libraries"></a>target_link_libraries</h1><p>使用 target_link_libraries()函数指定可执行目标所要链接的库，即告诉CMake当链接此可执行文件时需要链接哪些库（这些库在上面的find_package中定义），通常在调用完add_executable()后被调用。如果出现ros未定义的引用错误，则添加${catkin_LIBRARIES}。</p><p>语法：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">target_link_libraries(<span class="tag">&lt;<span class="name">executableTargetName</span>&gt;</span>, <span class="tag">&lt;<span class="name">lib1</span>&gt;</span>, <span class="tag">&lt;<span class="name">lib2</span>&gt;</span>, ... <span class="tag">&lt;<span class="name">libN</span>&gt;</span>)</span><br></pre></td></tr></table></figure></p><p>例子:<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(foo src/foo.cpp)</span></span></span><br><span class="line"><span class="function"><span class="title">add_library</span><span class="params">(moo src/moo.cpp)</span></span></span><br><span class="line"><span class="function"><span class="title">target_link_libraries</span><span class="params">(foo moo)</span></span></span><br></pre></td></tr></table></figure></p><p>上面的例子将 foo与libmoo.so链接起来, 注意，在大多数使用情况下，没有必要使用link_directories()，因为该信息通过find_package()已经自动提取到了。 这就意味着nodelet导出的头文件路径、库等都会附加到 catkin_variables上，比如，catkin_INCLUDE_DIRS不仅包含catkin的头文件路径，也包含了nodelet软件包的头文件路径，这在后面会派上用场。 如果单独的find_package nodelet：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(nodelet)</span></span></span><br></pre></td></tr></table></figure><p>这意味着nodelet的头文件路径、库及其他文件都不会包含在 catkin_variables中，对于nodelet_INCLUDE_DIRS,nodelet_LIBRARIES及其他变量也是如此。相同的变量也可以通过下面的方式创建：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(catkin REQUIRED COMPONENTS nodelet)</span></span></span><br></pre></td></tr></table></figure><h1 id="消息、服务和操作目标"><a href="#消息、服务和操作目标" class="headerlink" title="消息、服务和操作目标"></a>消息、服务和操作目标</h1><p>在被ROS软件包编译和使用之前，ROS中的消息（.msg）、服务（.srv）和操作（.action）文件需要特殊的预处理器编译步骤。这些宏的要点是生成编程语言特定的文件，以便可以在编程语言中使用消息、服务和操作。编译系统将使用所有可用的生成器（例如gencpp、genpy、genlisp）生成绑定。</p><p>提供了三个宏来分别处理消息，服务和操作：</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_message_files</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">add_service_files</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">add_action_files</span></span><br></pre></td></tr></table></figure><p>这些宏后面必须调用一个调用生成的宏：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">generate_messages</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><h2 id="重要的前提和限制"><a href="#重要的前提和限制" class="headerlink" title="重要的前提和限制"></a>重要的前提和限制</h2><p>这些宏必须在调用catkin_package()之前被调用，以正确地完成生成工作。<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(catkin REQUIRED COMPONENTS ...)</span></span> </span><br><span class="line"><span class="function"><span class="title">add_message_files</span><span class="params">(...)</span></span> </span><br><span class="line"><span class="function"><span class="title">add_service_files</span><span class="params">(...)</span></span> </span><br><span class="line"><span class="function"><span class="title">add_action_files</span><span class="params">(...)</span></span> </span><br><span class="line"><span class="function"><span class="title">generate_messages</span><span class="params">(...)</span></span> </span><br><span class="line"><span class="function"><span class="title">catkin_package</span><span class="params">(...)</span></span> ...</span><br><span class="line"><span class="function"><span class="title">catkin_package</span><span class="params">()</span></span>宏必须包含一个在message_runtime上的CATKIN_DEPENDS依赖。</span><br><span class="line"><span class="built_in">catkin_package</span>( ... </span><br><span class="line">                CATKIN_DEPENDS message_runtime ... </span><br><span class="line">                ...)</span><br></pre></td></tr></table></figure></p><p>必须对软件包message_generation使用find_package()，可单独或者作为catkin的组件使用：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(catkin REQUIRED COMPONENTS message_generation)</span></span></span><br></pre></td></tr></table></figure><p>1, package.xml文件必须包含一个在message_generation上的编译依赖和一个在message_runtime上的运行时依赖，如果从其他包中传递依赖关系，则这不是必需的。 </p><p>2, 如果有一个目标（甚至是过渡性的）依赖于需要建立消息/服务/动作的其他目标，需要在目标catkin_EXPORTED_TARGETS上添加显式依赖项，以使它们按照正确的顺序编译。这种情况几乎总是适用，除非你的软件包真的不使用ROS的任何部分。不幸的是，这种依赖不能自动传播。（some_target是由add_executable()设置的目标的名字）</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">add_dependencies</span><span class="params">(some_target $&#123;catkin_EXPORTED_TARGETS&#125;)</span></span></span><br></pre></td></tr></table></figure><p>如果有编译消息和/或服务的软件包以及使用这些软件的可执行文件，则需要在自动生成的消息目标上创建明确的依赖关系，以便它们按正确的顺序编译。（some_target是由add_executable()设置的目标的名字）</p><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">add_dependencies</span><span class="params">(some_target <span class="string">$&#123;</span><span class="string">$&#123;</span>PROJECT_NAME&#125;_EXPORTED_TARGETS&#125;)</span></span></span><br></pre></td></tr></table></figure><p>如果软件包满足上述两个条件，则需要添加两个依赖项，即：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">add_dependencies</span><span class="params">(some_target &#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125;                  &#123;catkin_EXPORTED_TARGETS&#125;)</span></span></span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>如果在msg目录下有两个消息文件 MyMessage1.msg和MyMessage2.msg，并且这些消息依赖于std_msgs和sensor_msgs，另外在srv目录下有一个服务文件MyService.srv，就可以使用这些消息、服务定义可执行message_program，和可执行的程序does_not_use_local_messages_program，这个过程使用了ROS的某些部分，但不包含此包中定义的消息/服务。需要在CMakeList.txt文件中加上一下内容：</p><figure class="highlight leaf"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">#</span><span class="keyword">Get</span> the information about this package&#x27;s buildtime dependencies  find_package(catkin REQUIRED    </span><br><span class="line"><span class="punctuation">#</span><span class="keyword">COMPONENTS</span> message_generation std_msgs sensor_msgs)  </span><br><span class="line"><span class="punctuation">#</span><span class="keyword">Declare</span> the message files to be built  </span><br><span class="line"><span class="punctuation">#</span><span class="keyword">add_message_files</span><span class="params">(<span class="variable">FILES</span> <span class="variable">MyMessage1</span>.<span class="variable">msg</span> <span class="variable">MyMessage2</span>.<span class="variable">msg</span>  )</span>  </span><br><span class="line"><span class="punctuation">#</span><span class="keyword">Declare</span> the service files to be built  add_service_files(FILES    MyService.srv  )  </span><br><span class="line"><span class="punctuation">#</span><span class="keyword">Actually</span> generate the language-specific message and service files  generate_messages(DEPENDENCIES std_msgs sensor_msgs)  </span><br><span class="line"><span class="punctuation">#</span><span class="keyword">Declare</span> that this catkin package&#x27;s runtime dependencies  </span><br><span class="line"><span class="punctuation">#</span><span class="keyword">catkin_package</span><span class="params">(<span class="variable">CATKIN_DEPENDS</span> <span class="variable">message_runtime</span> <span class="variable">std_msgs</span> <span class="variable">sensor_msgs</span>  )</span>  </span><br><span class="line"><span class="punctuation">#</span><span class="keyword">define</span> executable using MyMessage1 etc.  add_executable(message_program src/main.cpp) </span><br><span class="line"><span class="punctuation">#</span><span class="keyword">add_dependencies</span><span class="params">(<span class="variable">message_program</span> &#123;$&#123;<span class="variable">PROJECT_NAME</span>&#125;<span class="variable">_EXPORTED_TARGETS</span>&#125; &#123;<span class="variable">catkin_EXPORTED_TARGETS</span>&#125;)</span>  </span><br><span class="line"><span class="punctuation">#</span><span class="keyword">define</span> executable not using any messages/services provided by this package  </span><br><span class="line">add_executable(does_not_use_local_messages_program src/main.cpp)</span><br><span class="line">add_dependencies(does_not_use_local_messages_program $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br></pre></td></tr></table></figure><p>另外如果需要编译actionlib操作，并且在action目录下有一个名为MyAction.action的操作规范文件，就必须要添加actionlib_msgs到组件列表中，该组件列表就是find_package中catkin的组件，并在调用generate_messages()之前调用：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">add_action_files</span><span class="params">(FILES MyAction.action)</span></span></span><br></pre></td></tr></table></figure><p>此外，该包必须对 actionlib_msgs具有编译依赖关系。</p><h1 id="启动Python模块支持"><a href="#启动Python模块支持" class="headerlink" title="启动Python模块支持"></a>启动Python模块支持</h1><p>如果ROS软件包提供了一些Python模块，就要创建一个setup.py文件并调用：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">catkin_python_setup</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><p>该调用要在generate_message()和catkin_package()的调用之前。</p><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>特定的catkin宏 catkin_add_gtest()用于处理基于gtest的单元测试：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">catkin_add_gtest</span><span class="params">(myUnitTest test/utest.cpp)</span></span></span><br></pre></td></tr></table></figure></p><h1 id="可选步骤：明确安装目标"><a href="#可选步骤：明确安装目标" class="headerlink" title="可选步骤：明确安装目标"></a>可选步骤：明确安装目标</h1><p>编译完成后，目标被放入catkin工作空间下的devel目录。一般希望将目标安装到系统上，以使其他用户使用，或者安装到本地目录来测试系统级别的安装。也就是说，如果希望能够对代码进行make install，就需要明确目标结束的位置。</p><p>上述过程可以使用CMake的 install()函数实现，该函数的参数有：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">TARGETS：要安装的目标</span><br><span class="line">ARCHIVE DESTINATION：静态库和动态链接库<span class="built_in">DLL</span>(Windows)<span class="selector-class">.lib</span>存根</span><br><span class="line">LIBRARY DESTINATION：非DLL共享库和模块</span><br><span class="line">RUNTIME DESTINATION：可执行目标和<span class="built_in">DLL</span>(Windows)模式共享库</span><br></pre></td></tr></table></figure><p>例子：<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS <span class="variable">$&#123;PROJECT_NAME&#125;</span>  </span><br><span class="line">        ARCHIVE DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span>  </span><br><span class="line">        LIBRARY DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span>  </span><br><span class="line">        RUNTIME DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span>)</span><br></pre></td></tr></table></figure></p><p>除了这些标准的目标，还要安装一些文件到特定的目录下，即一个包含Python绑定的库必须要安装到另外的不同的目录下，这对Python是重要的：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS python_module_library  </span><br><span class="line">        ARCHIVE DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_PYTHON_DESTINATION&#125;</span>  </span><br><span class="line">        LIBRARY DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_PYTHON_DESTINATION&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="安装Python可执行脚本"><a href="#安装Python可执行脚本" class="headerlink" title="安装Python可执行脚本"></a>安装Python可执行脚本</h2><p>Python代码的安装规则有些不同，它不需要使用 add_library()和add_executable()函数来告知CMake哪个文件是目标文件、目标文件是什么类型的。而是使用如下的CMakeList.txt文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catkin_install_python(PROGRAMS scripts/myscript  </span><br><span class="line">                      DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span>)</span><br></pre></td></tr></table></figure></p><p>如果只是安装了Python的脚本，不提供任何模块的话，就不用创建上文提到的 setup.py文件，也不用调用catkin_python_setup()。</p><h2 id="安装头文件"><a href="#安装头文件" class="headerlink" title="安装头文件"></a>安装头文件</h2><p>头文件必须安装到include目录下，这通常通过安装整个文件夹的文件来完成（可以根据文件名模式进行过滤，并排除SVN子文件夹）。可以通过一下安装规则实现：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY <span class="keyword">include</span>/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/  </span><br><span class="line">        DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_INCLUDE_DESTINATION&#125;</span>  </span><br><span class="line">        PATTERN <span class="string">&quot;.svn&quot;</span> EXCLUDE)</span><br></pre></td></tr></table></figure><p>或者如果include目录下的子文件夹无法和软件包名匹配时：<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY <span class="keyword">include</span>/  </span><br><span class="line">        DESTINATION <span class="variable">$&#123;CATKIN_GLOBAL_INCLUDE_DESTINATION&#125;</span>  </span><br><span class="line">        PATTERN <span class="string">&quot;.svn&quot;</span> EXCLUDE)</span><br></pre></td></tr></table></figure></p><h2 id="安装roslaunch文件或其他源"><a href="#安装roslaunch文件或其他源" class="headerlink" title="安装roslaunch文件或其他源"></a>安装roslaunch文件或其他源</h2><p>其他像launchfiles的资源可以安装到 ${CATKIN_PACKAGE_SHARE_DESTINATION}：<br><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">install(DIRECTORY <span class="keyword">launch</span>/  </span><br><span class="line">        DESTINATION $&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;/<span class="keyword">launch</span>  </span><br><span class="line">        PATTERN <span class="string">&quot;.svn&quot;</span> EXCLUDE)</span><br></pre></td></tr></table></figure></p><p>CMakeLists.txt文件书写模板</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8.3)</span><br><span class="line">project(my_p)</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Compile as C++11, supported in ROS Kinetic and newer</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_compile_options(-std=c++11)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Find catkin macros and libraries</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># is used, also find other catkin packages</span></span></span><br><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># System dependencies are found with CMake&#x27;s conventions</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find_package(Boost REQUIRED COMPONENTS system)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Uncomment this if the package has a setup.py. This macro ensures</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># modules and global scripts declared therein get installed</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># See http://ros.org/doc/api/catkin/html/user_guide/setup_dot_py.html</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">catkin_python_setup()</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###############################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Declare ROS messages, services and actions ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###############################################</span></span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># To declare and build messages, services or actions from within this</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># package, follow these steps:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># * Let MSG_DEP_SET be the set of packages whose message types you use in</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   your messages/services/actions (e.g. std_msgs, actionlib_msgs, ...).</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># * In the file package.xml:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   * add a build_depend tag for &quot;message_generation&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   * add a build_depend and a run_depend tag for each package in MSG_DEP_SET</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   * If MSG_DEP_SET isn&#x27;t empty the following dependency has been pulled in</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#     but can be declared for certainty nonetheless:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#     * add a run_depend tag for &quot;message_runtime&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># * In this file (CMakeLists.txt):</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   * add &quot;message_generation&quot; and every package in MSG_DEP_SET to</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#     find_package(catkin REQUIRED COMPONENTS ...)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   * add &quot;message_runtime&quot; and every package in MSG_DEP_SET to</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#     catkin_package(CATKIN_DEPENDS ...)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   * uncomment the add_*_files sections below as needed</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#     and list every .msg/.srv/.action file to be processed</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   * uncomment the generate_messages entry below</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   * add every package in MSG_DEP_SET to generate_messages(DEPENDENCIES ...)</span></span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Generate messages in the &#x27;msg&#x27; folder</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_message_files(</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  FILES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  Message1.msg</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  Message2.msg</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Generate services in the &#x27;srv&#x27; folder</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_service_files(</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  FILES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  Service1.srv</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  Service2.srv</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Generate actions in the &#x27;action&#x27; folder</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_action_files(</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  FILES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  Action1.action</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  Action2.action</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Generate added messages and services with any dependencies listed here</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">generate_messages(</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  DEPENDENCIES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  std_msgs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###############################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Declare ROS dynamic reconfigure parameters ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###############################################</span></span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># To declare and build dynamic reconfigure parameters within this</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># package, follow these steps:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># * In the file package.xml:</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   * add a build_depend and a run_depend tag for &quot;dynamic_reconfigure&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># * In this file (CMakeLists.txt):</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   * add &quot;dynamic_reconfigure&quot; to</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#     find_package(catkin REQUIRED COMPONENTS ...)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   * uncomment the &quot;generate_dynamic_reconfigure_options&quot; section below</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#     and list every .cfg file to be processed</span></span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Generate dynamic reconfigure parameters in the &#x27;cfg&#x27; folder</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">generate_dynamic_reconfigure_options(</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  cfg/DynReconf1.cfg</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  cfg/DynReconf2.cfg</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># catkin specific configuration ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># The catkin_package macro generates cmake config files for your package</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Declare things to be passed to dependent projects</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># INCLUDE_DIRS: uncomment this if your package contains header files</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># LIBRARIES: libraries you create in this project that dependent projects also need</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># CATKIN_DEPENDS: catkin_packages dependent projects also need</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># DEPENDS: system dependencies of this project that dependent projects also need</span></span></span><br><span class="line">catkin_package(</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> INCLUDE_DIRS include</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> LIBRARIES my_p</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> CATKIN_DEPENDS roscpp rospy std_msgs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> DEPENDS system_lib</span></span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Build ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########</span></span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Specify additional locations of header files</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Your package locations should be listed before other locations</span></span></span><br><span class="line">include_directories(</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">include</span></span><br><span class="line"><span class="meta prompt_">  $</span><span class="language-bash">&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Declare a C++ library</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_library(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  src/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/my_p.cpp</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Add cmake target dependencies of the library</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># as an example, code may need to be generated before libraries</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># either from message generation or dynamic reconfigure</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_dependencies(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;<span class="variable">$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125;</span> <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Declare a C++ executable</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># With catkin_make all packages are built within a single CMake context</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># The recommended prefix ensures that target names across packages don&#x27;t collide</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_node src/my_p_node.cpp)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Rename C++ executable without prefix</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># The above recommended prefix causes long target names, the following renames the</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># target back to the shorter version for ease of user use</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># e.g. &quot;rosrun someones_pkg node&quot; instead of &quot;rosrun someones_pkg someones_pkg_node&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">set_target_properties(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_node PROPERTIES OUTPUT_NAME node PREFIX <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Add cmake target dependencies of the executable</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># same as for the library above</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">add_dependencies(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_node <span class="variable">$&#123;<span class="variable">$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125;</span> <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Specify libraries to link a library or executable target against</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_node</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Install ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############</span></span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">all install targets should use catkin DESTINATION variables</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See http://ros.org/doc/api/catkin/html/adv_user_guide/variables.html</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Mark executable scripts (Python etc.) for installation</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># in contrast to setup.py, you can choose the destination</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install(PROGRAMS</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  scripts/my_python_script</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Mark executables and/or libraries for installation</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install(TARGETS <span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span>_node</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  ARCHIVE DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  LIBRARY DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  RUNTIME DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Mark cpp header files for installation</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install(DIRECTORY include/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_INCLUDE_DESTINATION&#125;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  FILES_MATCHING PATTERN <span class="string">&quot;*.h&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  PATTERN <span class="string">&quot;.svn&quot;</span> EXCLUDE</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Mark other files for installation (e.g. launch and bag files, etc.)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install(FILES</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  <span class="comment"># myfile1</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  <span class="comment"># myfile2</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_SHARE_DESTINATION&#125;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">)</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Testing ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############</span></span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Add gtest based cpp test target and link libraries</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">catkin_add_gtest(<span class="variable">$&#123;PROJECT_NAME&#125;</span>-<span class="built_in">test</span> <span class="built_in">test</span>/test_my_p.cpp)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span>(TARGET <span class="variable">$&#123;PROJECT_NAME&#125;</span>-<span class="built_in">test</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span>-<span class="built_in">test</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">endif()</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Add folders to be run by python nosetests</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">catkin_add_nosetests</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]. <a href="https://blog.csdn.net/jinking01/article/details/102891918">ROS的CMakeList文件详解</a></p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> ros </tag>
            
            <tag> CMakeLists </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++模版</title>
      <link href="/2023/01/05/archived_cPP%E6%A8%A1%E7%89%88/"/>
      <url>/2023/01/05/archived_cPP%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#模版简介">模版简介</a></li><li><a href="#定义和使用模板">定义和使用模板</a></li><li><a href="#类型参数">类型参数</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="模版简介"><a href="#模版简介" class="headerlink" title="模版简介"></a>模版简介</h1><p>模板是 C++ 中的泛型编程的基础。 作为强类型语言,C++ 要求所有变量都具有特定类型,由程序员显式声明或编译器推导。 但是,许多数据结构和算法无论在哪种类型上操作,看起来都是相同的。 使用模板可以定义类或函数的操作,并让用户指定这些操作应处理的具体类型。</p><h1 id="定义和使用模板"><a href="#定义和使用模板" class="headerlink" title="定义和使用模板"></a>定义和使用模板</h1><p>模板是基于用户为模板参数提供的参数在编译时生成普通类型或函数的构造。 例如,可以定义如下所示的函数模板：</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T minimum(const T&amp; <span class="built_in">lhs</span>, const T&amp; <span class="built_in">rhs</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">lhs</span> &lt; <span class="built_in">rhs</span> ? <span class="built_in">lhs</span> : <span class="built_in">rhs</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码描述了一个具有单个类型参数 T 的泛型函数的模板,其返回值和调用参数(lhs 和 rhs)都具有此类型。 可以随意命名类型参数,但按照约定,最常使用单个大写字母。 T 是模板参数；关键字 <code>typename</code> 表示此参数是类型的占位符。 调用函数时,编译器会将每个 T 实例替换为由用户指定或编译器推导的具体类型参数。 编译器从模板生成类或函数的过程称为“模板实例化”；<code>minimum&lt;int&gt;</code> 是模板 <code>minimum&lt;T&gt;</code> 的实例化。</p><p>在其他地方,用户可以声明专用于 int 的模板实例。假设 get_a() 和 get_b() 是返回 int 的函数：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int a</span> = get_a();</span><br><span class="line"><span class="attribute">int b</span> = get_b();</span><br><span class="line"><span class="attribute">int i</span> = minimum&lt;int&gt;(a, b);</span><br></pre></td></tr></table></figure><p>但是,由于这是一个函数模板,编译器可以从参数 a 和 b 中推导出类型,因此可以像普通函数一样调用它：<code>T</code></p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int i</span> = minimum(a, b);</span><br></pre></td></tr></table></figure><p>当编译器遇到最后一个语句时,它会生成一个新函数,在该函数中,T 在模板中的每个匹配项都替换为 <code>int</code>：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimum</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; lhs, <span class="type">const</span> <span class="type">int</span>&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs &lt; rhs ? lhs : rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h1><p>在上面的 <code>minimum</code> 模板中,请注意,在将类型参数 T 用于函数调用参数(在这些参数中会添加 const 和引用限定符)之前,不会以任何方式对其进行限定。</p><p>类型参数的数量没有实际限制。 以逗号分隔多个参数：</p><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">template &lt;typename T, typename U, typename V&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>在此上下文中,关键字 class 等效于 typename。 可以将前面的示例表示为：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> <span class="symbol">T, <span class="symbol">class</span></span> <span class="symbol">U, <span class="symbol">class</span></span> <span class="symbol">V</span>&gt; <span class="symbol">class</span> <span class="symbol">Foo</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>可以使用省略号运算符 (…) 定义采用任意数量的零个或多个类型参数的模板：</p><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">template&lt;typename... Arguments&gt; <span class="class"><span class="keyword">class</span> <span class="title">vtclass</span></span>;</span><br><span class="line"></span><br><span class="line">vtclass&lt; &gt; vtinstance1;</span><br><span class="line">vtclass&lt;<span class="keyword">int</span>&gt; vtinstance2;</span><br><span class="line">vtclass&lt;float, bool&gt; vtinstance3;</span><br></pre></td></tr></table></figure><p>任何内置类型或用户定义的类型都可以用作类型参数。 例如,可以使用标准库中的 std::vector 来存储类型 int、double、std::string、MyClass、const、MyClass*、MyClass&amp; 等的变量。 使用模板时的主要限制是类型参数必须支持应用于类型参数的任何操作。 例如,如果我们使用 MyClass 调用 minimum,如以下示例所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    std::wstring description;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass mc1 &#123;<span class="number">1</span>, <span class="string">L&quot;hello&quot;</span>&#125;;</span><br><span class="line">    MyClass mc2 &#123;<span class="number">2</span>, <span class="string">L&quot;goodbye&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">minimum</span>(mc1, mc2); <span class="comment">// Error! C2678</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/templates-cpp?view=msvc-170">模板(C++)</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> work </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年总结与展望</title>
      <link href="/2022/12/31/archived_2022_summary_2023_plan/"/>
      <url>/2022/12/31/archived_2022_summary_2023_plan/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2022年, 于我而言是荒废的一年, 基本上所有的目标,没有一个是完成的,这一年, 在我的人生之中, 也算是失去的一年, 先后经历了长达三个月的疫情封锁,然后忙于工作, 忙于项目,极少给自己时间去思考, 即使有很多时间的前提下, 生活较为放纵。想想所制定的目标,却鲜有完成了的, 惭愧！！！ </p><p>落笔时思索, 今天是2022年的最后一天了,也是即将迎来新的一年, 告别过往的一年, 在2022年, 自己到底做了哪些有价值的事情呢,技艺并没有精进,懒惰有所助长,身材逐渐离谱。即使是荒废的一年, 也还要做一些总结的。 </p><h1 id="去年挖的坑"><a href="#去年挖的坑" class="headerlink" title="去年挖的坑"></a>去年挖的坑</h1><p>1, <del>对ROS的使用,可以做到相对熟悉的程度。</del></p><p>2, <del>加强自己的数学以及力学分析等能力,对旋量代数和动力学控制有深入的理解。</del></p><p>3, <del>通过合理的饮食以及健身,有较好的线条。</del></p><p>4, <del>用ADAMS对一个完整的机器人进行柔性建模与仿真控制,并输出学习文档或博客中。</del></p><p>5, <del>深入学习经典控制理论与现代控制理论,并输出到学习文档或博客中。</del></p><p>6, <del>写两个发明专利。</del> </p><p>7, <del>跑步累积300KM。</del> </p><p>8,<del>骑行累积超5000KM(相当于一个月500KM,很恐怖的量。。。。)。</del> </p><p>9,<del>学习数据结构与算法,尤其是数据结构,并输出到学习文档或博客中。</del> </p><p>10,<del>一整年中,记录的照片及视频超1T。其中照片不少于500张,视频不少于50个。</del> </p><h1 id="2023-年目标"><a href="#2023-年目标" class="headerlink" title="2023 年目标"></a>2023 年目标</h1><p>1, 会用吉他弹一些小曲, 如《天空之城》。</p><p>2, 会用电子钢琴弹一些简单的曲,如《遇见》。</p><p>3, 有至少三篇博客的输出。</p><p>4, 见媳妇她弟。</p><p>5, 与媳妇一起见高中老师。</p><p>6, 学习数据结构,对简单的数据结构做到非常熟悉。</p><p>7, 会用Mathematica分析控制系统。</p><p>8,提高乒乓球技术,参加相关比赛。</p><p>9, 减肥至120斤以内。</p><p>10, 见小沈一面(于2023.1.2 完成)。</p>]]></content>
      
      
      <categories>
          
          <category> LIFE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> dots </tag>
            
            <tag> memory </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 命令与功能介绍</title>
      <link href="/2022/07/12/archived_ros_command/"/>
      <url>/2022/07/12/archived_ros_command/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc Redcarpet --><ul><li><a href="#ros-shell">ROS shell</a></li><li><a href="#执行命令">执行命令</a></li><li><a href="#信息命令">信息命令</a></li><li><a href="#ros-catkin">ROS catkin</a></li><li><a href="#功能包命令">功能包命令</a></li><li><a href="#rosnode">rosnode</a></li><li><a href="#rostopic">rostopic</a></li><li><a href="#rosservice">rosservice</a></li><li><a href="#rosparam">rosparam</a></li><li><a href="#rosmsg">rosmsg</a></li><li><a href="#rossrv">rossrv</a></li><li><a href="#rosbag">rosbag</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="ROS-shell"><a href="#ROS-shell" class="headerlink" title="ROS shell"></a>ROS shell</h1><div class="table-container"><table><thead><tr><th>命令  &emsp;</th><th>重要度&emsp;</th><th>命令释义                 &emsp;</th><th>详细说明</th></tr></thead><tbody><tr><td>roscd &emsp;</td><td>★★★   &emsp;</td><td>ros+cd(changes directory) &emsp;</td><td>移动到指定的ROS功能包目录</td></tr><tr><td>rosls &emsp;</td><td>★☆☆    &emsp;</td><td>ros+ls(lists files)       &emsp;</td><td>显示ROS功能包的文件和目录</td></tr><tr><td>rosed &emsp;</td><td>★☆☆    &emsp;</td><td>ros+ed(editor)            &emsp;</td><td>编辑ROS功能包的文件</td></tr><tr><td>roscp &emsp;</td><td>★☆☆    &emsp;</td><td>ros+cp(copies files)      &emsp;</td><td>复制ROS功能包的文件</td></tr><tr><td>rospd &emsp;</td><td>☆☆☆    &emsp;</td><td>ros+pushd                 &emsp;</td><td>添加目录至ROS目录索引</td></tr><tr><td>rosd  &emsp;</td><td>☆☆☆    &emsp;</td><td>ros+directory             &emsp;</td><td>显示ROS目录索引中的目录</td></tr></tbody></table></div><h1 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h1><div class="table-container"><table><thead><tr><th>命令     &emsp;</th><th>重要度 &emsp;</th><th>命令释义       &emsp;</th><th>详细说明</th></tr></thead><tbody><tr><td>roscore   &emsp;</td><td>★★★    &emsp;</td><td>ros+core master &emsp;</td><td>ROS名称服务） + rosout（日志记录） + parameter server（参数管理）</td></tr><tr><td>rosrun    &emsp;</td><td>★★★    &emsp;</td><td>ros+run         &emsp;</td><td>运行节点</td></tr><tr><td>roslaunch &emsp;</td><td>★★★    &emsp;</td><td>ros+launch      &emsp;</td><td>运行多个节点及设置运行选项</td></tr><tr><td>rosclean  &emsp;</td><td>★★☆    &emsp;</td><td>ros+clean       &emsp;</td><td>检查或删除ROS日志文件</td></tr></tbody></table></div><h1 id="信息命令"><a href="#信息命令" class="headerlink" title="信息命令"></a>信息命令</h1><p>ROS信息命令用于识别话题、服务、节点和参数等信息。尤其是rostopic、 rosservice、rosnode和rosparam经常被使用，并且rosbag是ROS的主要特征之一，它具有记录数据和回放功能，务必要掌握。</p><div class="table-container"><table><thead><tr><th>命令     &emsp;</th><th>重要度 &emsp;</th><th>命令释义            &emsp;</th><th>详细说明</th></tr></thead><tbody><tr><td>rostopic  &emsp;</td><td>★★★    &emsp;</td><td>ros+topic            &emsp;</td><td>确认ROS话题信息</td></tr><tr><td>rosservice&emsp;</td><td>★★★    &emsp;</td><td>ros+service          &emsp;</td><td>确认ROS服务信息</td></tr><tr><td>rosnode   &emsp;</td><td>★★★    &emsp;</td><td>ros+node             &emsp;</td><td>确认ROS节点信息</td></tr><tr><td>rosparam  &emsp;</td><td>★★★    &emsp;</td><td>ros+param(parameter) &emsp;</td><td>确认和修改ROS参数信息</td></tr><tr><td>rosbag    &emsp;</td><td>★★★    &emsp;</td><td>ros+bag              &emsp;</td><td>记录和回放ROS消息</td></tr><tr><td>rosmsg    &emsp;</td><td>★★☆    &emsp;</td><td>ros+msg              &emsp;</td><td>显示ROS消息类型</td></tr><tr><td>rossrv    &emsp;</td><td>★★☆    &emsp;</td><td>ros+srv              &emsp;</td><td>显示ROS服务类型</td></tr><tr><td>rosversion&emsp;</td><td>★☆☆    &emsp;</td><td>ros+version          &emsp;</td><td>显示ROS功能包的版本信息</td></tr><tr><td>roswtf    &emsp;</td><td>☆☆☆    &emsp;</td><td>ros+wtf              &emsp;</td><td>检查ROS系统</td></tr></tbody></table></div><h1 id="ROS-catkin"><a href="#ROS-catkin" class="headerlink" title="ROS catkin"></a>ROS catkin</h1><div class="table-container"><table><thead><tr><th>命令                     &emsp;</th><th>重要度 &emsp;</th><th>详细说明</th></tr></thead><tbody><tr><td>catkin_create_pkg         &emsp;</td><td>★★★     &emsp;</td><td>自动生成功能包</td></tr><tr><td>catkin_make               &emsp;</td><td>★★★     &emsp;</td><td>基于catkin构建系统的构建</td></tr><tr><td>catkin_eclipse            &emsp;</td><td>★★☆     &emsp;</td><td>对于用catkin构建系统生成的功能包进行修改,使其能在 Eclipse环境中使用</td></tr><tr><td>catkin_prepare_release    &emsp;</td><td>★★☆     &emsp;</td><td>发布时用到的日志整理和版本标记</td></tr><tr><td>catkin_generate_changelog &emsp;</td><td>★★☆     &emsp;</td><td>在发布时生成或更新CHANGELOG.rst文件</td></tr><tr><td>catkin_init_workspace     &emsp;</td><td>★★☆     &emsp;</td><td>初始化catkin构建系统的工作目录</td></tr><tr><td>catkin_find               &emsp;</td><td>★☆☆     &emsp;</td><td>搜索catkin</td></tr></tbody></table></div><h1 id="功能包命令"><a href="#功能包命令" class="headerlink" title="功能包命令"></a>功能包命令</h1><div class="table-container"><table><thead><tr><th>命令           &emsp;</th><th>重要度 &emsp;</th><th>命令释义           &emsp;</th><th>详细说明</th></tr></thead><tbody><tr><td>rospack         &emsp;</td><td>★★★     &emsp;</td><td>ros+pack(age)       &emsp;</td><td>查看与ROS功能包相关的信息</td></tr><tr><td>rosinstall      &emsp;</td><td>★★☆     &emsp;</td><td>ros+install         &emsp;</td><td>安装ROS附加功能包</td></tr><tr><td>rosdep          &emsp;</td><td>★★☆     &emsp;</td><td>ros+dep(endencies)  &emsp;</td><td>安装该功能包的依赖性文件</td></tr><tr><td>roslocate       &emsp;</td><td>☆☆☆     &emsp;</td><td>ros+locate          &emsp;</td><td>ROS功能包信息相关命令</td></tr><tr><td>roscreate-pkg   &emsp;</td><td>☆☆☆     &emsp;</td><td>ros+create-pkg      &emsp;</td><td>自动生成ROS功能包（用于旧的rosbuild系统）</td></tr><tr><td>rosmake         &emsp;</td><td>☆☆☆     &emsp;</td><td>ros+make            &emsp;</td><td>构建 ROS功能包（用于旧的rosbuild系统）</td></tr></tbody></table></div><h1 id="rosnode"><a href="#rosnode" class="headerlink" title="rosnode"></a>rosnode</h1><p>关于ROS节点信息相关指令，列表如下</p><div class="table-container"><table><thead><tr><th>命令                         &emsp;</th><th>详细说明</th></tr></thead><tbody><tr><td>rosnode list                 &emsp;</td><td>查看活动的节点列表</td></tr><tr><td>rosnode ping [节点名称]      &emsp;</td><td>与指定的节点进行连接测试</td></tr><tr><td>rosnode info [节点名称]      &emsp;</td><td>查看指定节点的信息</td></tr><tr><td>rosnode machine [PC名称或IP] &emsp;</td><td>查看该PC中运行的节点列表</td></tr><tr><td>rosnode kill [节点名称]      &emsp;</td><td>停止指定节点的运行</td></tr><tr><td>rosnode cleanup              &emsp;</td><td>删除失连节点的注册信息</td></tr></tbody></table></div><h1 id="rostopic"><a href="#rostopic" class="headerlink" title="rostopic"></a>rostopic</h1><p>关于ROS话题相关指令，列表如下</p><div class="table-container"><table><thead><tr><th>命令                                      &emsp;</th><th>详细说明</th></tr></thead><tbody><tr><td>rostopic list                             &emsp;</td><td>显示活动的话题目录</td></tr><tr><td>rostopic echo [话题名称]                  &emsp;</td><td>实时显示指定话题的消息内容</td></tr><tr><td>rostopic find [类型名称]                  &emsp;</td><td>显示使用指定类型的消息的话题</td></tr><tr><td>rostopic type [话题名称]                  &emsp;</td><td>显示指定话题的消息类型</td></tr><tr><td>rostopic bw [话题名称]                    &emsp;</td><td>显示指定话题的消息带宽（bandwidth）</td></tr><tr><td>rostopic hz [话题名称]                    &emsp;</td><td>显示指定话题的消息数据发布周期</td></tr><tr><td>rostopic info [话题名称]                  &emsp;</td><td>显示指定话题的信息</td></tr><tr><td>rostopic pub [话题名称] [消息类型] [参数] &emsp;</td><td>用指定的话题名称发布消息</td></tr></tbody></table></div><h1 id="rosservice"><a href="#rosservice" class="headerlink" title="rosservice"></a>rosservice</h1><p>关于ROS服务相关指令，列表如下</p><div class="table-container"><table><thead><tr><th>命令                              &emsp;</th><th>详细说明</th></tr></thead><tbody><tr><td>rosservice list                   &emsp;</td><td>显示活动的服务信息</td></tr><tr><td>rosservice info [服务名称]        &emsp;</td><td>显示指定服务的信息</td></tr><tr><td>rosservice find [服务类型]        &emsp;</td><td>查找指定服务类型的服务</td></tr><tr><td>rosservice uri [服务名称]         &emsp;</td><td>显示ROSRPC URI服务</td></tr><tr><td>rosservice args [服务名称]        &emsp;</td><td>显示服务参数</td></tr><tr><td>rosservice call [服务名称] [参数] &emsp;</td><td>用输入的参数请求服务</td></tr></tbody></table></div><h1 id="rosparam"><a href="#rosparam" class="headerlink" title="rosparam"></a>rosparam</h1><p>关于ROS参数相关指令，列表如下</p><div class="table-container"><table><thead><tr><th>命令                       &emsp;</th><th>详细说明</th></tr></thead><tbody><tr><td>rosparam list              &emsp;</td><td>查看参数列表</td></tr><tr><td>rosparam get [参数名称]    &emsp;</td><td>获取参数值</td></tr><tr><td>rosparam set [参数名称]    &emsp;</td><td>设置参数值</td></tr><tr><td>rosparam dump [文件名称]   &emsp;</td><td>将参数保存到指定文件</td></tr><tr><td>rosparam load [文件名称]   &emsp;</td><td>获取保存在指定文件中的参数</td></tr><tr><td>rosparam delete [参数名称] &emsp;</td><td>删除参数</td></tr></tbody></table></div><h1 id="rosmsg"><a href="#rosmsg" class="headerlink" title="rosmsg"></a>rosmsg</h1><p>关于ROS消息信息相关指令，列表如下</p><div class="table-container"><table><thead><tr><th>命令                        &emsp;</th><th>详细说明</th></tr></thead><tbody><tr><td>rosmsg list                 &emsp;</td><td>显示所有消息</td></tr><tr><td>rosmsg show [消息名称]      &emsp;</td><td>显示指定消息</td></tr><tr><td>rosmsg md5 [消息名称]       &emsp;</td><td>显示md5sum</td></tr><tr><td>rosmsg package [功能包名称] &emsp;</td><td>显示用于指定功能包的所有消息</td></tr><tr><td>rosmsg packages             &emsp;</td><td>显示使用消息的所有功能包</td></tr></tbody></table></div><h1 id="rossrv"><a href="#rossrv" class="headerlink" title="rossrv"></a>rossrv</h1><p>关于ROS服务信息相关指令，列表如下</p><div class="table-container"><table><thead><tr><th>命令                        &emsp;</th><th>详细说明</th></tr></thead><tbody><tr><td>rossrv list                 &emsp;</td><td>显示所有服务</td></tr><tr><td>rossrv show [服务名称]      &emsp;</td><td>显示指定的服务信息</td></tr><tr><td>rossrv md5 [服务名称]       &emsp;</td><td>显示md5sum</td></tr><tr><td>rossrv package [功能包名称] &emsp;</td><td>显示指定的功能包中用到的所有服务</td></tr><tr><td>rossrv packages             &emsp;</td><td>显示使用服务的所有功能包</td></tr></tbody></table></div><h1 id="rosbag"><a href="#rosbag" class="headerlink" title="rosbag"></a>rosbag</h1><p>rosbag是一个实现生成、播放和压缩等功能的程序，它具有以下几种功能。</p><div class="table-container"><table><thead><tr><th>命令                                          &emsp;</th><th>详细说明</th></tr></thead><tbody><tr><td>rosbag record [选项] [话题名称]                &emsp;</td><td>将指定话题的消息记录到bag文件</td></tr><tr><td>rosbag info [文件名称]                         &emsp;</td><td>查看bag文件的信息</td></tr><tr><td>rosbag play [文件名称]                         &emsp;</td><td>回放指定的bag文件</td></tr><tr><td>rosbag compress [文件名称]                     &emsp;</td><td>压缩指定的bag文件</td></tr><tr><td>rosbag decompress [文件名称]                   &emsp;</td><td>解压指定的bag文件</td></tr><tr><td>rosbag filter [输入文件] [输出文件] [选项]     &emsp;</td><td>生成一个删除了指定内容的新的bag文件</td></tr><tr><td>rosbag reindex bag [文件名称]                  &emsp;</td><td>刷新索引</td></tr><tr><td>rosbag check bag [文件名称]                    &emsp;</td><td>检查指定的bag文件是否能在当前系统中回放</td></tr><tr><td>rosbag fix [输入文件] [输出文件] [选项]        &emsp;</td><td>将由于版本不同而无法回放的bag文件修改成可以回放的文件</td></tr></tbody></table></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《ROS机器人编程—从基本概念到机器人应用程序编程实战》</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年总结与展望</title>
      <link href="/2022/01/04/archived_2021_summary_2022_plan/"/>
      <url>/2022/01/04/archived_2021_summary_2022_plan/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>仿佛刚抬起头望向天空,转身便是一年。2021给我带来太多的欢乐的同时,也学习到了很多新的知识与技能。从伺服环路的设计与测试,深入理解了三个环路之间作用与参数的调节。在精度测试里熟练的掌握了Leica与Faro激光跟踪仪及辨识软件的使用,各种影响轨迹精度的可能原因。从理论及实践过程中知道了如何去标定辨识一台机器人的参数。</p><p>工作上感觉是非常充实且快乐的。最快乐的莫过于和女盆友的相处了,在芜半年的时间里都没有放弃我,一出差就是个把月的,相见着实不易。如今在一起住了,也能有更多的时间去陪伴她,两人一起打了《双人成行》,虽然她很CAI,不过上手游戏倒是挺快的,很好的锻炼了我的耐心。。。。和她在一起学会了很多的生活常识,不得不说,自己的厨艺水平较2020有了巨大的飞跃,自然。。。。身材膨胀了。</p><h1 id="去年挖的坑"><a href="#去年挖的坑" class="headerlink" title="去年挖的坑"></a>去年挖的坑</h1><p><del>1,带上心爱的姑娘,去她想去的地方,哪怕是未知的远方。</del></p><p><del>2,非常熟悉LaTeX类文件的编写,可以独立的自定义想要的样式。</del></p><p><del>3,对程序算法以及机器人运动控制算法以及伺服驱动器有更深入的了解与实际的应用。</del></p><p>4,希望能将机器人的轨迹跟踪精度,做到国内最好(不考虑关节变形等机械影响)。</p><p>5,对ROS的使用,可以做到相对熟悉的程度。</p><p><del>6,进一步进阶VIM。</del></p><p>7,对自己的网页,进行进一步的优化,改善现有加载速度慢,以及其他问题。</p><p><del>8,写至少6个有关技术的博客内容。</del></p><p>9,加强自己的数学以及力学分析等能力,对旋量代数和动力学控制有深入的理解。</p><p>10,通过合理的饮食以及健身,有较好的线条。</p><h1 id="继续挖坑"><a href="#继续挖坑" class="headerlink" title="继续挖坑"></a>继续挖坑</h1><p>看了上面,感觉还不错,至少填了一半的坑了,第四条也是在自己测试过程中深入了解到的,看来想完成,还有。。。还有很长一段距离。。。把上面的部分坑,还是得继续挖。</p><p>1, 对ROS的使用,可以做到相对熟悉的程度。</p><p>2, 加强自己的数学以及力学分析等能力,对旋量代数和动力学控制有深入的理解。</p><p>3, 通过合理的饮食以及健身,有较好的线条。</p><p>4, 用 ADAMS 对一个完整的机器人进行柔性建模与仿真控制,并输出学习文档或博客中。 </p><p>5,深入学习经典控制理论与现代控制理论,并输出到学习文档或博客中。</p><p>6,写两个发明专利。</p><p>7,跑步累积300KM。</p><p>8,骑行累积超5000KM(相当于一个月500KM,很恐怖的量。。。。)。</p><p>9,学习数据结构与算法,尤其是数据结构,并输出到学习文档或博客中。</p><p>10,一整年中,记录的照片及视频超1T。其中照片不少于500张,视频不少于50个。</p>]]></content>
      
      
      <categories>
          
          <category> LIFE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> dots </tag>
            
            <tag> memory </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++/Eigen学习</title>
      <link href="/2021/12/27/archived_Eigen%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/12/27/archived_Eigen%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#子矩阵操作简介">子矩阵操作简介</a></li><li><a href="#块操作的一般使用方法">块操作的一般使用方法</a></li><li><a href="#行子式和列子式">行子式和列子式</a></li><li><a href="#向量的子向量操作">向量的子向量操作</a></li><li><a href="#后记">后记</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="子矩阵操作简介"><a href="#子矩阵操作简介" class="headerlink" title="子矩阵操作简介"></a>子矩阵操作简介</h1><p>子矩阵操作又称块操作,在矩阵运算中,子矩阵的提取和操作应用也十分广泛。因此Eigen中也提供了相关操作的方法。提取的子矩阵在操作过程中既可以用作左值也可以用作右值。</p><h1 id="块操作的一般使用方法"><a href="#块操作的一般使用方法" class="headerlink" title="块操作的一般使用方法"></a>块操作的一般使用方法</h1><p>在Eigen中最基本的快操作运算是用 <code>.block()</code> 完成的。提取的子矩阵同样分为动态大小和固定大小。</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>块操作</strong>           &emsp;</th><th style="text-align:center"><strong>构建动态大小子矩阵</strong></th></tr></thead><tbody><tr><td style="text-align:center">提取块大小为(p,q),起始于(i,j) &emsp;</td><td style="text-align:center"><code>matrix.block(i,j,p,q)</code></td></tr></tbody></table></div><p>同样需要注意的是在Eigen中,索引是从0开始。所有的操作方法都可以适用于Array.同样使用固定大小的操作方式在小型矩阵运算时更加的快,但要求在编译时就要知道矩阵的大小。下面是一个使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Eigen/Dense&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MatrixXf <span class="title">m</span><span class="params">(<span class="number">4</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    m&lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,</span><br><span class="line">        <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,</span><br><span class="line">        <span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,</span><br><span class="line">        <span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Block in the middle&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;m.<span class="built_in">block</span>&lt;<span class="number">2</span>,<span class="number">2</span>&gt;(<span class="number">1</span>,<span class="number">1</span>)&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Block of size &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;x&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;m.<span class="built_in">block</span>(<span class="number">0</span>,<span class="number">0</span>,i,i)&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">执行结果如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">Block</span> <span class="keyword">in</span> the middle</span><br><span class="line"> <span class="number">6</span>  <span class="number">7</span></span><br><span class="line"><span class="number">10</span> <span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Block</span> of <span class="built_in">size</span> <span class="number">1</span>x1</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Block</span> of <span class="built_in">size</span> <span class="number">2</span>x2</span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Block</span> of <span class="built_in">size</span> <span class="number">3</span>x3</span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"> <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line"> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><p>上面的示例中,<code>.block()</code> 被应用为左值操作,即从中读取数据。事实上,它也可以被用作为右值操作,即也可往里面写入数据。下面是一个右值应用实例。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Eigen/Dense&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Array22f m;</span><br><span class="line">    m&lt;&lt; <span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">        <span class="number">3</span>,<span class="number">4</span>;</span><br><span class="line">    Array44f a = Array44f::<span class="built_in">Constant</span>(<span class="number">0.6</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Here is the array a:&quot;</span>&lt;&lt;endl&lt;&lt;a&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">block</span>&lt;<span class="number">2</span>,<span class="number">2</span>&gt;(<span class="number">1</span>,<span class="number">1</span>) = m;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Here is now a with m copied into its central 2x2 block:&quot;</span>&lt;&lt;endl&lt;&lt;a&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">block</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>) = a.<span class="built_in">block</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Here is now a with bottom-right 2x3 block copied into top-left 2x2 block:&quot;</span>&lt;&lt;endl&lt;&lt;a&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Here</span> is the array a:</span><br><span class="line"><span class="attribute">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span></span><br><span class="line"><span class="attribute">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span></span><br><span class="line"><span class="attribute">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span></span><br><span class="line"><span class="attribute">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">Here</span> is now a with m copied into its central <span class="number">2</span>x2 block:</span><br><span class="line"><span class="attribute">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span></span><br><span class="line"><span class="attribute">0</span>.<span class="number">6</span>   <span class="number">1</span>   <span class="number">2</span> <span class="number">0</span>.<span class="number">6</span></span><br><span class="line"><span class="attribute">0</span>.<span class="number">6</span>   <span class="number">3</span>   <span class="number">4</span> <span class="number">0</span>.<span class="number">6</span></span><br><span class="line"><span class="attribute">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">Here</span> is now a with bottom-right <span class="number">2</span>x3 block copied into top-left <span class="number">2</span>x2 block:</span><br><span class="line">  <span class="attribute">3</span>   <span class="number">4</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span></span><br><span class="line"><span class="attribute">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span></span><br><span class="line"><span class="attribute">0</span>.<span class="number">6</span>   <span class="number">3</span>   <span class="number">4</span> <span class="number">0</span>.<span class="number">6</span></span><br><span class="line"><span class="attribute">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span> <span class="number">0</span>.<span class="number">6</span></span><br></pre></td></tr></table></figure><p>.block()方法是一种非常通用的块操作方法。除了这个通用的方法以外,Eigen中还为一些常用的特殊操作提供了特殊的函数。从运行速度的方面来看,你应该在编译阶段尽可能的提供更多的信息。比如,如果你需要操作的块是一个列,那么你可以使用.col()函数。这样Eigen可以得知这个信息以便进行更多的优化。这些特殊操作方法总结如下。</p><h1 id="行子式和列子式"><a href="#行子式和列子式" class="headerlink" title="行子式和列子式"></a>行子式和列子式</h1><p>我们可以使用<code>.col()</code>和<code>.row()</code>方法来操作或者提取一个列或者行。</p><div class="table-container"><table><thead><tr><th style="text-align:center">块操作 &emsp;</th><th style="text-align:center">方法</th></tr></thead><tbody><tr><td style="text-align:center">第i行  &emsp;</td><td style="text-align:center"><code>matrix.row(i)</code></td></tr><tr><td style="text-align:center">第j列  &emsp;</td><td style="text-align:center"><code>matrix.col(j)</code></td></tr></tbody></table></div><p>下面是一个使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Eigen/Dense&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MatrixXf <span class="title">m</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    m&lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line">        <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,</span><br><span class="line">        <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Here is the matrix m:&quot;</span>&lt;&lt;endl&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;2nd Row:&quot;</span>&lt;&lt;m.<span class="built_in">row</span>(<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">    m.<span class="built_in">col</span>(<span class="number">2</span>) += <span class="number">3</span>*m.<span class="built_in">col</span>(<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;After adding 3 times the first column into third column,the matrix m is:\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Here</span> is the matrix m:</span><br><span class="line"><span class="attribute">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="attribute">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="attribute">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="attribute">2nd</span> Row:<span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="attribute">After</span> adding <span class="number">3</span> times the first column into third column,the matrix m is:</span><br><span class="line"> <span class="attribute">1</span>  <span class="number">2</span>  <span class="number">6</span></span><br><span class="line"> <span class="attribute">4</span>  <span class="number">5</span> <span class="number">18</span></span><br><span class="line"> <span class="attribute">7</span>  <span class="number">8</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>Eigen提供了从边角开始提取子矩阵的方法,比如<code>.topLeftCorner()</code>表示从左上角开始提取子矩阵。这些操作总结如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">块操作    &emsp;</th><th>动态矩阵版本                     &emsp;</th><th>固定矩阵版本</th></tr></thead><tbody><tr><td style="text-align:left">左上角pxq &emsp;</td><td><code>matrix.topLeftCorner(p,q);</code>     &emsp;</td><td><code>matrix.topLeftCorner&lt;p,q&gt;();</code></td></tr><tr><td style="text-align:left">左下角pxq &emsp;</td><td><code>matrix.bottomLeftCorner(p,q);</code>  &emsp;</td><td><code>matrix.bbottomLeftCorner&lt;p,q&gt;();</code></td></tr><tr><td style="text-align:left">右上角pxq &emsp;</td><td><code>matrix.topRightCorner(p,q);</code>    &emsp;</td><td><code>matrix.topRightCorner&lt;p,q&gt;();</code></td></tr><tr><td style="text-align:left">右下角pxq &emsp;</td><td><code>matrix.bottomRightCorner(p,q);</code> &emsp;</td><td><code>matrix.bottomRightCorner&lt;p,q&gt;();</code></td></tr><tr><td style="text-align:left">前p行     &emsp;</td><td><code>matrix.topRows(p);</code>             &emsp;</td><td><code>matrix.topRows&lt;p&gt;();</code></td></tr><tr><td style="text-align:left">后p行     &emsp;</td><td><code>matrix.bottomRows(p);</code>          &emsp;</td><td><code>matrix.bottomRows&lt;p&gt;();</code></td></tr><tr><td style="text-align:left">前q列     &emsp;</td><td><code>matrix.leftCols(q);</code>            &emsp;</td><td><code>matrix.leftCols&lt;q&gt;();</code></td></tr><tr><td style="text-align:left">后q列     &emsp;</td><td><code>matrix.rightCols(q);</code>           &emsp;</td><td><code>matrix.rightCols&lt;q&gt;();</code></td></tr></tbody></table></div><p>下面是一个使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Eigen/Dense&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix4f m;</span><br><span class="line">    m&lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,</span><br><span class="line">        <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,</span><br><span class="line">        <span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,</span><br><span class="line">        <span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;m.leftCols(2)=&quot;</span>&lt;&lt;endl&lt;&lt;m.<span class="built_in">leftCols</span>(<span class="number">2</span>)&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;m.bottomRows&lt;2&gt;()=&quot;</span>&lt;&lt;endl&lt;&lt;m.<span class="built_in">bottomRows</span>&lt;<span class="number">2</span>&gt;()&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    m.<span class="built_in">topLeftCorner</span>(<span class="number">1</span>,<span class="number">3</span>) = m.<span class="built_in">bottomRightCorner</span>(<span class="number">3</span>,<span class="number">1</span>).<span class="built_in">transpose</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;After assignment,m=&quot;</span>&lt;&lt;endl&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">m</span>.leftCols(<span class="number">2</span>)=</span><br><span class="line"> <span class="attribute">1</span>  <span class="number">2</span></span><br><span class="line"> <span class="attribute">5</span>  <span class="number">6</span></span><br><span class="line"> <span class="attribute">9</span> <span class="number">10</span></span><br><span class="line"><span class="attribute">13</span> <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">m</span>.bottomRows&lt;<span class="number">2</span>&gt;()=</span><br><span class="line"> <span class="attribute">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line"><span class="attribute">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">After</span> assignment,m=</span><br><span class="line"> <span class="attribute">8</span> <span class="number">12</span> <span class="number">16</span>  <span class="number">4</span></span><br><span class="line"> <span class="attribute">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line"> <span class="attribute">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line"><span class="attribute">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><h1 id="向量的子向量操作"><a href="#向量的子向量操作" class="headerlink" title="向量的子向量操作"></a>向量的子向量操作</h1><p>Eigen中同样也为向量提供了一些子式的操作方法,总结如下：</p><div class="table-container"><table><thead><tr><th>块操作           &emsp;</th><th>固定向量版本        &emsp;</th><th>动态向量版本</th></tr></thead><tbody><tr><td>前n个元素        &emsp;</td><td>vector.head(n);     &emsp;</td><td>vector.head();</td></tr><tr><td>后n个元素        &emsp;</td><td>vector.tail(n);     &emsp;</td><td>vector.tail();</td></tr><tr><td>从i开始取n个元素 &emsp;</td><td>vector.segment(i,n) &emsp;</td><td>vector.segment(i);</td></tr></tbody></table></div><p>再次说明一下,所有对矩阵的操作同样适用于Array,所有对列向量的操作同样适用于行向量。下面是一个使用示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Eigen/Dense&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ArrayXf <span class="title">v</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    v&lt;&lt;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v.head(3)=&quot;</span>&lt;&lt;endl&lt;&lt;v.<span class="built_in">head</span>(<span class="number">3</span>)&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v.tail&lt;3&gt;()=&quot;</span>&lt;&lt;endl&lt;&lt;v.<span class="built_in">tail</span>&lt;<span class="number">3</span>&gt;()&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    v.<span class="built_in">segment</span>(<span class="number">1</span>,<span class="number">4</span>) *= <span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;after &#x27;v.segment(1,4) *= 2&#x27;,v=&quot;</span>&lt;&lt;endl&lt;&lt;v&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">v</span>.head(<span class="number">3</span>)=</span><br><span class="line"><span class="attribute">1</span></span><br><span class="line"><span class="attribute">2</span></span><br><span class="line"><span class="attribute">3</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">v</span>.tail&lt;<span class="number">3</span>&gt;()=</span><br><span class="line"><span class="attribute">4</span></span><br><span class="line"><span class="attribute">5</span></span><br><span class="line"><span class="attribute">6</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">after</span> &#x27;v.segment(<span class="number">1</span>,<span class="number">4</span>) *= <span class="number">2</span>&#x27;,v=</span><br><span class="line"> <span class="attribute">1</span></span><br><span class="line"> <span class="attribute">4</span></span><br><span class="line"> <span class="attribute">6</span></span><br><span class="line"> <span class="attribute">8</span></span><br><span class="line"><span class="attribute">10</span></span><br><span class="line"> <span class="attribute">6</span></span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>1, 时隔两年回头看看自己的这个笔记， 感觉就写了分块矩阵的提取这么点内容。。。。 2023.8.5</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://blog.csdn.net/qq_27251141/article/details/90442072">Eigen子矩阵操作(block)</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> Matrix </tag>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ operator</title>
      <link href="/2021/11/23/archived_cPlusPlusOperator/"/>
      <url>/2021/11/23/archived_cPlusPlusOperator/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#重载运算符和重载函数">重载运算符和重载函数</a><ul><li><a href="#函数重载">函数重载</a></li><li><a href="#运算符重载">运算符重载</a><ul><li><a href="#why">Why</a></li></ul></li></ul></li><li><a href="#vs-eigen-configure">VS Eigen configure</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="重载运算符和重载函数"><a href="#重载运算符和重载函数" class="headerlink" title="重载运算符和重载函数"></a>重载运算符和重载函数</h1><p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义,分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明,但是它们的参数列表和定义(实现)不相同。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载指的是可以有多个同名的函数,因此对名称进行了重载,它们完成相同的工作,但使用不同的参数列表。这个比较容易理解与操作。</p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>重载的运算符是带有特殊名称的函数,函数名是由关键字 <strong>operator</strong> 和其后<strong>要重载的运算符符号</strong>构成的。与其他函数一样,重载运算符有一个返回类型和一个参数列表。</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">Box</span> <span class="keyword">operator</span>+(const <span class="type">Box</span>&amp;);</span><br></pre></td></tr></table></figure><p>声明加法运算符用于把两个 Box 对象相加,返回最终的 Box 对象。大多数的重载运算符可被定义为<strong>普通的非成员函数</strong>或者被定义为<strong>类成员函数</strong>。如果我们定义上面的函数为<strong>类的非成员函数</strong>,那么我们需要为每次操作传递两个参数,如下所示：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="type">Box</span> operator+(<span class="keyword">const</span> <span class="type">Box</span>&amp;, <span class="keyword">const</span> <span class="type">Box</span>&amp;);</span><br></pre></td></tr></table></figure><p>感觉这个例子说的太浅显了，搬运<a href="https://blog.csdn.net/liitdar/article/details/80656156">liitdar</a>对这部分的详细解释</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>首先介绍为什么要对赋值运算符“=”进行重载。某些情况下，当我们编写一个类的时候，并不需要为该类重载“=”运算符，因为编译系统为每个类提供了默认的赋值运算符“=”，使用这个默认的赋值运算符操作类对象时，该运算符会把这个类的所有数据成员都进行一次赋值操作。按如下命令进行复现，首先在命令行中输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> testOperator.cpp</span><br></pre></td></tr></table></figure><p>然后用编辑器，比如用vim写入如下代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ClassA obj1;</span><br><span class="line">    obj<span class="number">1.</span>a = <span class="number">1</span>;</span><br><span class="line">    obj<span class="number">1.</span>b = <span class="number">2</span>;</span><br><span class="line">    obj<span class="number">1.</span>c = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">    ClassA obj2;</span><br><span class="line">    obj2 = obj1;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;obj2.a is: &quot;</span> &lt;&lt; obj<span class="number">2.</span>a &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用<code>g++</code>编译器进行编译后，得到的结果如下所示</p><div align="center"> <img src="/img/postImg/18_CPP/operator/touchOperatorFileStep1.png" width="50%" height="40%"> </div><p>通过上述结果能够知道：通过使用系统默认的赋值运算符“=”，可以让对象 obj2 中的所有数据成员的值与对象 obj1 相同。这种情况下，编译系统提供的默认赋值运算符可以正常使用。 但是，在下面的示例中，使用编译系统提供的默认赋值运算符，就会出现问题了。 示例代码内容如下(在同一个文件里进行修改)：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassA</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">ClassA</span>(<span class="type">const</span> <span class="type">char</span>* pszInputStr)</span><br><span class="line">    &#123;</span><br><span class="line">        pszTestStr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(pszInputStr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strncpy</span>(pszTestStr, pszInputStr, <span class="built_in">strlen</span>(pszInputStr) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ClassA</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pszTestStr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>* pszTestStr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ClassA <span class="title">obj1</span><span class="params">(<span class="string">&quot;liitdar&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    ClassA obj2;</span><br><span class="line">    obj2 = obj1;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;obj2.pszTestStr is: &quot;</span> &lt;&lt; obj<span class="number">2.</span>pszTestStr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;addr(obj1.pszTestStr) is: &quot;</span> &lt;&lt; &amp;obj<span class="number">1.</span>pszTestStr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;addr(obj2.pszTestStr) is: &quot;</span> &lt;&lt; &amp;obj<span class="number">2.</span>pszTestStr &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行上述代码，结果如下：</p><div align="center"> <img src="/img/postImg/18_CPP/operator/testOperatorStep2.png" width="100%" height="40%"> </div><p>上述错误信息表明：当对象 obj1 和 obj2 进行析构时，由于重复释放了同一块内存空间，导致程序崩溃报错。在这种情况下，就需要我们重载赋值运算符”=”了。 修改一下前面出错的示例代码，编写一个包含赋值运算符重载函数的类，修改后的代码内容如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassA</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ClassA</span>(<span class="type">const</span> <span class="type">char</span>* pszInputStr)</span><br><span class="line">    &#123;</span><br><span class="line">        pszTestStr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(pszInputStr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strncpy</span>(pszTestStr, pszInputStr, <span class="built_in">strlen</span>(pszInputStr) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ClassA</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pszTestStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 赋值运算符重载函数</span></span><br><span class="line">    ClassA&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ClassA&amp; cls)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 避免自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;cls)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 避免内存泄露</span></span><br><span class="line">            <span class="keyword">if</span> (pszTestStr != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> pszTestStr;</span><br><span class="line">                pszTestStr = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            pszTestStr = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cls.pszTestStr) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strncpy</span>(pszTestStr, cls.pszTestStr, <span class="built_in">strlen</span>(cls.pszTestStr) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>* pszTestStr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ClassA <span class="title">obj1</span><span class="params">(<span class="string">&quot;liitdar&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    ClassA obj2;</span><br><span class="line">    obj2 = obj1;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;obj2.pszTestStr is: &quot;</span> &lt;&lt; obj<span class="number">2.</span>pszTestStr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;addr(obj1.pszTestStr) is: &quot;</span> &lt;&lt; &amp;obj<span class="number">1.</span>pszTestStr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;addr(obj2.pszTestStr) is: &quot;</span> &lt;&lt; &amp;obj<span class="number">2.</span>pszTestStr &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行上述代码，结果如下：</p><div align="center"> <img src="/img/postImg/18_CPP/operator/testOperatorStep3.png" width="40%" height="40%"> </div><p>对于上述代码，有以下几点需要说明：</p><p>1, 当为一个类的对象赋值（可以用本类对象为其赋值，也可以用其它类型的值为其赋值）时，该对象（如本例的 obj2）会调用该类的赋值运算符重载函数，进行具体的赋值操作。如上述代码中的“obj2 = obj1;”语句，用 obj1 为 obj2 赋值，则会由 obj2 调用 ClassA 类的赋值运算符重载函数；</p><p>2, 下方语句和语句“ClassA obj2 = obj1;”在调用函数上是有区别的：前者第一句是对象 obj2 的声明及定义，调用类 ClassA 的无参构造函数，所以“obj2 = obj1;”一句是在对象 obj2 已经存在的情况下，用 obj1 来为 obj2 赋值，调用的是赋值运算符重载函数；而后者，是用 obj1 来初始化 obj2，调用的是拷贝构造函数。拷贝构造函数的语句样式为“ClassA(const ClassA&amp; cls)”，</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">ClassA obj2<span class="comment">;</span></span><br><span class="line"><span class="attribute">obj2</span> <span class="operator">=</span> obj1<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>3, 当程序没有显式地提供一个以“本类或本类的引用”为参数的赋值运算符重载函数时，编译器会自动生成一个默认的赋值运算符重载函数（即默认赋值运算符）。</p><h1 id="VS-Eigen-configure"><a href="#VS-Eigen-configure" class="headerlink" title="VS Eigen configure"></a>VS Eigen configure</h1><p>打开VS,进入到项目的属性页面, 如下所示</p><p><img src="/img/postImg/18_CPP/eigen_configuration.png" alt=""></p><p>将Eigen3文件包含到里面即可。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://www.runoob.com/cplusplus/cpp-overloading.html">菜鸟教程</a></p><p>[2] <a href="https://blog.csdn.net/liitdar/article/details/80656156">C++编程语言中赋值运算符重载函数(operator=)介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> cpp </tag>
            
            <tag> operator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python GUI学习</title>
      <link href="/2021/06/28/archived_pythonGUI2021/"/>
      <url>/2021/06/28/archived_pythonGUI2021/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#为python-添加类型">为Python 添加类型</a><ul><li><a href="#属性的功能">属性的功能</a></li></ul></li><li><a href="#轻松制作用户界面">轻松制作用户界面</a><ul><li><a href="#定义界面">定义界面</a></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近来写的python脚本比较多,以自己的随意的性格,那些代码迟早会被自己弄丢的,或者是隔了一段时间,都不知道自己写的是啥了,所以打算写个交互式的界面,帮助自己整理那些代码。顺带学习学习python中GUI的编写,有过MATLAB编写GUI的基础,希望上手能快一些。学习到的内容源自于书籍[1], 书很不错,值得去学习,这里就摘抄一部分自己认为重要的内容。</p><h1 id="为Python-添加类型"><a href="#为Python-添加类型" class="headerlink" title="为Python 添加类型"></a>为Python 添加类型</h1><h2 id="属性的功能"><a href="#属性的功能" class="headerlink" title="属性的功能"></a>属性的功能</h2><p>Traits 库为对象的属性增加了类型定义的功能,此外还提供了如下的额外功能(自己感觉还是比较重要的地方)：</p><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">初始化：每个 <span class="keyword">Trait</span> 属性都有自己的默认值。</span><br><span class="line">验证：<span class="keyword">Trait</span> 属性都有明确的类型定义,只有满足定义的值才能赋给属性。</span><br><span class="line">代理：<span class="keyword">Trait</span> 属性值可以代理给其他对象的属性。</span><br><span class="line">监听：<span class="keyword">Trait</span> 属性值发生变化时,可以运行事先指定的函数。</span><br><span class="line">可视化：拥有 <span class="keyword">Trait</span> 属性的对象可以很方便地生成编辑 <span class="keyword">Trait</span> 属性的界面。</span><br></pre></td></tr></table></figure><p>下面的例子展示了 Trait 属性的上述功能(看的中国慕课里讲的也就是这个例子,一模一样)。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Parent</span> ( <span class="symbol">HasTraits</span> ): </span><br><span class="line"> # 初始化: <span class="symbol">last_name</span> 被初始化为&#x27;<span class="symbol">Zhang</span>&#x27; </span><br><span class="line"> <span class="symbol">last_name</span> = <span class="symbol">Str</span>( &#x27;<span class="symbol">Zhang</span>&#x27; ) </span><br><span class="line"><span class="symbol">class</span> <span class="symbol">Child</span> ( <span class="symbol">HasTraits</span> ): </span><br><span class="line">     <span class="symbol">age</span> = <span class="symbol">Int</span> </span><br><span class="line">     # 验证: <span class="symbol">father</span> 属性的值必须是 <span class="symbol">Parent</span> 类的实例</span><br><span class="line">     <span class="symbol">father</span> = <span class="symbol">Instance</span>( <span class="symbol">Parent</span> ) </span><br><span class="line">     # 代理： 将 <span class="symbol">Child</span> 对象的 <span class="symbol">last_name</span> 属性代理给其 <span class="symbol">father</span> 属性的 <span class="symbol">last_name</span> </span><br><span class="line">     <span class="symbol">last_name</span> = <span class="symbol">Delegate</span>( &#x27;<span class="symbol">father</span>&#x27; ) </span><br><span class="line"> # 监听: 当 <span class="symbol">age</span> 属性的值被修改时,下面的函数将被运行</span><br><span class="line"> <span class="symbol">def</span> <span class="symbol">_age_changed</span> ( <span class="symbol">self, <span class="symbol">old</span>, <span class="symbol">new</span></span> ): </span><br><span class="line"> <span class="symbol">print</span> &#x27;<span class="symbol">Age</span> <span class="symbol">changed</span> <span class="symbol">from</span> %<span class="symbol">s</span> <span class="symbol">to</span> %<span class="symbol">s</span> &#x27; % ( <span class="symbol">old, <span class="symbol">new</span></span> )</span><br></pre></td></tr></table></figure><p>当派生类中定义了<strong>init</strong>()时,在其中必须调用其父类的<strong>init</strong>()方法,否则 Trait 属性的一些功能将无效。</p><h1 id="轻松制作用户界面"><a href="#轻松制作用户界面" class="headerlink" title="轻松制作用户界面"></a>轻松制作用户界面</h1><p>希望快速实现一个够用的界面,让用户能够交互式地处理数据,而又不希望在界面制作上花费过多的精力。以 Traits 库为基础、以 MVC 模式为设计思想的 TraitsUI 库就是实现这一理想的最佳方案。</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">MVC 的英文全称为 Model-View-Controller,它的目的是实现一种动态的程序设计,简化程序的修改和扩展工作,并且使程序的各个部分能够充分地被重复利用。</span><br><span class="line"><span class="function"><span class="title">Model</span><span class="params">(模型)</span></span>：程序中存储数据以及对数据进行处理的部分。</span><br><span class="line"><span class="function"><span class="title">View</span><span class="params">(视图)</span></span>：程序的界面部分,实现数据的显示。</span><br><span class="line"><span class="function"><span class="title">Controller</span><span class="params">(控制器)</span></span>：起到视图和模型之间的组织作用,控制程序的流程,例如将界面的</span><br><span class="line">操作转换为对模型的处理。</span><br></pre></td></tr></table></figure><p>这里运行书中给的第一个例子就报了很多错了,是自己没有安装相关的包导致的,可以通过pip 或者conda安装,这里采用pip的方式安装所需的包</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> traits</span><br><span class="line">pip <span class="keyword">install</span> traitsui</span><br></pre></td></tr></table></figure><p>并将书中的例子改为</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">from</span> traits.api <span class="keyword">import</span> HasTraits, Str, Int</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Employee</span>(<span class="type">HasTraits</span>):</span></span><br><span class="line"><span class="class"> name = <span class="type">Str</span></span></span><br><span class="line"><span class="class"> department = <span class="type">Str</span></span></span><br><span class="line"><span class="class"> salary = <span class="type">Int</span></span></span><br><span class="line"><span class="class"> bonus = <span class="type">Int</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="type">Employee</span>().configure_traits()</span></span><br></pre></td></tr></table></figure><p>即可出现书中给出的交互式界面了。</p><p><img src="/img/postImg/9_Python/pythonGUIeg1.png" alt=""></p><p>没有写一行与界面相关的代码,就能得到一个已经够实用的界面,应该还是很令人满意的。如果想手工控制界面的设计和布局,就需要添加自己的代码了。</p><h2 id="定义界面"><a href="#定义界面" class="headerlink" title="定义界面"></a>定义界面</h2><p>HasTraits 的派生类用 Trait 属性保存数据,它相当于 MVC 模式中的模型(Model)。当没有指定界面的显示方式时,Traits 库会自动创建一个默认的界面。可以通过视图(View)对象为模型设计更加实用的界面。当然,用书中给的例子,也是通不过编译的,改成如下形式即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> traits.api <span class="keyword">import</span> HasTraits, Str, Int</span><br><span class="line"><span class="keyword">from</span> traitsui.api <span class="keyword">import</span> View,Item</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>(<span class="title class_ inherited__">HasTraits</span>):</span><br><span class="line"> name = Str</span><br><span class="line"> department = Str</span><br><span class="line"> salary = Int</span><br><span class="line"> bonus = Int</span><br><span class="line"></span><br><span class="line"> view = View(</span><br><span class="line">  Item(<span class="string">&#x27;department&#x27;</span>, label=<span class="string">u&quot;部门&quot;</span>, tooltip=<span class="string">u&quot;在哪个部门干活&quot;</span>),</span><br><span class="line">  Item(<span class="string">&#x27;name&#x27;</span>, label=<span class="string">u&quot;姓名&quot;</span>),</span><br><span class="line">  Item(<span class="string">&#x27;salary&#x27;</span>, label=<span class="string">u&quot;工资&quot;</span>),</span><br><span class="line">  Item(<span class="string">&#x27;bonus&#x27;</span>, label=<span class="string">u&quot;奖金&quot;</span>),</span><br><span class="line">  title=<span class="string">u&quot;员工资料&quot;</span>, width=<span class="number">250</span>, height=<span class="number">150</span>, resizable=<span class="literal">True</span></span><br><span class="line"> )</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  p = Employee()</span><br><span class="line">  p.configure_traits()</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/pythonGUIeg2.png" alt=""></p><p>界面相关的内容都位于 TraitsUI 库中,这里从中载入 View 和 Item。View 是描述界面的视图类,Item 是描述界面中的控件和模型对象的 Trait 属性之间关系的类。除了 Item 之外,TraitsUI 模块还定义了 Item 的几个派生类：Label、Heading 和 Spring。它们只用于辅助界面布局,因此不需要和模型对象的 Trait 属性关联。</p><p>同一个模型对象可以通过多个视图对象用不同的界面显示,下面看一个例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> traits.api <span class="keyword">import</span> HasTraits, Str, Int</span><br><span class="line"><span class="keyword">from</span> traitsui.api <span class="keyword">import</span> View,Item,Group</span><br><span class="line"></span><br><span class="line">g1 = [Item(<span class="string">&#x27;department&#x27;</span>, label=<span class="string">u&quot;部门&quot;</span>, tooltip=<span class="string">u&quot;在哪个部门干活&quot;</span>),</span><br><span class="line">      Item(<span class="string">&#x27;name&#x27;</span>, label=<span class="string">u&quot;姓名&quot;</span>)]</span><br><span class="line">g2 = [Item(<span class="string">&#x27;salary&#x27;</span>, label=<span class="string">u&quot;工资&quot;</span>),</span><br><span class="line">      Item(<span class="string">&#x27;bonus&#x27;</span>, label=<span class="string">u&quot;奖金&quot;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>(<span class="title class_ inherited__">HasTraits</span>):</span><br><span class="line">       name = Str</span><br><span class="line">       department = Str</span><br><span class="line">       salary = Int</span><br><span class="line">       bonus = Int</span><br><span class="line"></span><br><span class="line">       traits_view = View(</span><br><span class="line">       Group(*g1, label=<span class="string">u&#x27;个人信息&#x27;</span>, show_border=<span class="literal">True</span>),</span><br><span class="line">       Group(*g2, label=<span class="string">u&#x27;收入&#x27;</span>, show_border=<span class="literal">True</span>),</span><br><span class="line">       title = <span class="string">u&quot;缺省内部视图&quot;</span>)</span><br><span class="line">       another_view = View(</span><br><span class="line">       Group(*g1, label=<span class="string">u&#x27;个人信息&#x27;</span>, show_border=<span class="literal">True</span>),</span><br><span class="line">       Group(*g2, label=<span class="string">u&#x27;收入&#x27;</span>, show_border=<span class="literal">True</span>),</span><br><span class="line">       title = <span class="string">u&quot;另一个内部视图&quot;</span>)</span><br><span class="line"></span><br><span class="line">global_view = View(</span><br><span class="line">      Group(*g1, label = <span class="string">u&#x27;个人信息&#x27;</span>, show_border = <span class="literal">True</span>),</span><br><span class="line">      Group(*g2, label = <span class="string">u&#x27;收入&#x27;</span>, show_border = <span class="literal">True</span>),</span><br><span class="line">      title = <span class="string">u&quot;外部视图&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = Employee()</span><br><span class="line"><span class="comment"># 使用内部视图 traits_view</span></span><br><span class="line">p.edit_traits()</span><br><span class="line"><span class="comment"># 使用内部视图 another_view</span></span><br><span class="line">p.edit_traits(view=<span class="string">&quot;another_view&quot;</span>)</span><br><span class="line"><span class="comment"># 使用外部视图 view1</span></span><br><span class="line">p.configure_traits(view=global_view)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  p = Employee()</span><br><span class="line">  p.configure_traits()</span><br></pre></td></tr></table></figure><p>edit_traits()和 configure_traits()一样,也被用于生成界面,它们的区别在于：edit_traits()显示界面之后不进入后台界面库的消息循环,因此如果直接运行只调用 edit_traits()的程序,界面将在显示之后立即关闭,程序的运行也随之结束。而对于 configure_traits(),将进入消息循环,直到用户关闭所有窗口。因此通常情况下,主界面窗口或模态对话框使用 configure_traits()显示,而无模态窗口或对话框则使用 edit_traits()显示。</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">用 TraitsUI 库创建的界面可以选择后台界面库<span class="punctuation">,</span>目前支持的有 qt4 和 wx 两种。</span><br><span class="line">在启动程序时添加<span class="string">&quot;-toolkit qt4&quot;</span>或<span class="string">&quot;-toolkit wx&quot;</span>可选择使用何种界面库生成界面。</span><br></pre></td></tr></table></figure><p>在给的例子中,Employee 类用于保存数据,因此它属于 MVC 模式中的模型(Model), 而 View 对象定义了 Employee 的界面显示部分,它属于视图(View)。通过将视图对象传递给模型对象的 configure_traits()方法,将模型对象和视图对象联系起来。在用来定义编辑器的 Item 对象中,不直接引用模型对象的属性,而是通过属性名和模型对象进行联系。这样一来,模型和视图之间的耦合性很弱,只需要属性名匹配,同一个视图对象可以运用到不同的模型对象之上。有时候我们希望模型类知道如何显示它自己,这时可以在模型类的内部定义视图。在模型类中定义的视图可以被其派生类继承,因此派生类能使用父类的视图。在调用 configure_traits()时如果不设置 view 参数,将使用模型对象内部的默认视图对象生成界面。如果在模型类中定义了多个视图对象,默认使用名为 traits_view 的视图对象。</p><p>一个模型可以对应多个视图。同样,使用一个视图可以将多个模型对象的数据显示在一个界面窗口中。下面是用一个视图对象同时显示多个模型对象的例子。对于前面的模型类 Employee,我们可以设计如下的复合视图对象 comp_view,它能同时显示两个 Employee 对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">comp_view = View(</span><br><span class="line">Group( </span><br><span class="line"> Group( </span><br><span class="line"> Item(<span class="string">&#x27;p1.department&#x27;</span>, label=<span class="string">u&quot;部门&quot;</span>), </span><br><span class="line"> Item(<span class="string">&#x27;p1.name&#x27;</span>, label=<span class="string">u&quot;姓名&quot;</span>), </span><br><span class="line"> Item(<span class="string">&#x27;p1.salary&#x27;</span>, label=<span class="string">u&quot;工资&quot;</span>), </span><br><span class="line"> Item(<span class="string">&#x27;p1.bonus&#x27;</span>, label=<span class="string">u&quot;奖金&quot;</span>), </span><br><span class="line"> show_border=<span class="literal">True</span> </span><br><span class="line"> ), </span><br><span class="line"> Group( </span><br><span class="line"> Item(<span class="string">&#x27;p2.department&#x27;</span>, label=<span class="string">u&quot;部门&quot;</span>), </span><br><span class="line"> Item(<span class="string">&#x27;p2.name&#x27;</span>, label=<span class="string">u&quot;姓名&quot;</span>), </span><br><span class="line"> Item(<span class="string">&#x27;p2.salary&#x27;</span>, label=<span class="string">u&quot;工资&quot;</span>), </span><br><span class="line"> Item(<span class="string">&#x27;p2.bonus&#x27;</span>, label=<span class="string">u&quot;奖金&quot;</span>), </span><br><span class="line"> show_border=<span class="literal">True</span> </span><br><span class="line"> ), </span><br><span class="line"> orientation = <span class="string">&#x27;horizontal&#x27;</span> </span><br><span class="line"> ), </span><br><span class="line"> title = <span class="string">u&quot;员工对比&quot;</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>接下来,下面的程序生成组成模型对象的两个 Employee 对象——employee1 和 employee2：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">employee1 = Employee(department = <span class="string">u&quot;开发&quot;</span>, name = <span class="string">u&quot;张三&quot;</span>, salary = <span class="number">3000</span>, bonus = <span class="number">300</span>) </span><br><span class="line">employee2 = Employee(department = <span class="string">u&quot;销售&quot;</span>, name = <span class="string">u&quot;李四&quot;</span>, salary = <span class="number">4000</span>, bonus = <span class="number">400</span>)</span><br></pre></td></tr></table></figure><p>在显示界面时,使用 context 参数将包含两个模型对象的字典传递给 configure_traits()：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">HasTraits</span><span class="params">()</span></span><span class="selector-class">.configure_traits</span>(view=comp_view, context=&#123;<span class="string">&quot;p1&quot;</span>:employee1, <span class="string">&quot;p2&quot;</span>:employee2&#125;)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] 《python 科学计算》—— 张若愚等著</p>]]></content>
      
      
      <categories>
          
          <category> PYTHON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 学习(二)</title>
      <link href="/2021/05/13/archived_python2021/"/>
      <url>/2021/05/13/archived_python2021/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#numpy">Numpy</a><ul><li><a href="#ndarray-对象">ndarray 对象</a></li></ul></li><li><a href="#scipy">SciPy</a><ul><li><a href="#优化optimize">优化——optimize</a><ul><li><a href="#最小二乘拟合">最小二乘拟合</a></li></ul></li></ul></li><li><a href="#pandas">pandas</a><ul><li><a href="#series">Series</a></li></ul></li><li><a href="#类函数的编写">类函数的编写</a></li><li><a href="#处理矩阵经常用到的">处理矩阵经常用到的</a><ul><li><a href="#利用行列向量生成对角阵">利用行列向量生成对角阵</a></li></ul></li><li><a href="#获取xml中的数据">获取xml中的数据</a><pre><code>  * [xml中节点包含的属性：](#xml中节点包含的属性)  * [节点类型](#节点类型)  * [python获取xml节点：](#python获取xml节点)      * [打印标签对之间的数据](#打印标签对之间的数据)</code></pre></li><li><a href="#正则匹配">正则匹配</a><ul><li><a href="#正则表达式">正则表达式</a><ul><li><a href="#recompile-函数">re.compile 函数</a></li></ul></li></ul></li><li><a href="#其他">其他</a><ul><li><a href="#动态生成变量名">动态生成变量名</a></li></ul></li><li><a href="#小技巧">小技巧</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用python有近一年多的时间了,但水平还是很差,闲来无事,记录一些自己感觉有用的东西,仅此而已。</p><h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><h2 id="ndarray-对象"><a href="#ndarray-对象" class="headerlink" title="ndarray 对象"></a>ndarray 对象</h2><p>可以通过给 array()函数传递 Python 的序列 对象来创建数组。数组的形状可以通过其shape 属性获得,它是一个描述数组各个轴长度的元组(tuple)。当设置某个轴的元素个数为-1 时,将自动计算此轴的长度。使用数组的 reshape()方法,可以创建指定形状的新数组,而原数组的形状保持不变。zeros()、ones()、empty()可以创建指定形状和类型的数组。其中：empty()仅仅分配数组所使用的内存,不对数组元素进行初始化操作,因此它的运行速度是最快的。</p><p>fromfunction()的第一个参数为计算每个数组元素的函数,第二个参数指定数组的形状。如生成9*9的乘法序列：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">i,j</span>):</span><br><span class="line">    <span class="keyword">return</span> (i+<span class="number">1</span>) * (j+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(np.fromfunction(fun, (<span class="number">9</span>,<span class="number">9</span>)))</span><br></pre></td></tr></table></figure><p>关于切片,感觉还是利用形象的记忆比较有效,如下图所示</p><p><img src="/img/postImg/9_Python/python切片.png" width="100%" height="100%"></p><p>标准Python 中有比 for 循环更快的方案——使用列表推导式。但是列表推导式将产生一个新的列表,而不是直接修改原来列表中的元素。如</p><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">x</span> = [math.<span class="built_in">sin</span>(t) <span class="keyword">for</span> t in <span class="variable language_">x</span>]</span><br></pre></td></tr></table></figure><h1 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h1><p>SciPy在NumPy的基础上增加了众多的数学、科学以及工程计算中常用的模块,例如线性代数、常微分方程数值求解、信号处理、图像处理、稀疏矩阵,等等。</p><h2 id="优化——optimize"><a href="#优化——optimize" class="headerlink" title="优化——optimize"></a>优化——optimize</h2><h3 id="最小二乘拟合"><a href="#最小二乘拟合" class="headerlink" title="最小二乘拟合"></a>最小二乘拟合</h3><p>最小二乘是自己做参数辨识中最常用的一种方法了,假设有一组实验数据(xi , yi),我们事先知道它们之间应该满足某函数关系yi=f(xi),通过这些已知信息,需要确定函数f的一些参数。例如,如果函数f是线性函数 f(x)=kx+b,那么参数 k和b 就是需要确定的值。如果用p表示函数中需要确定的参数,那么目标就是找到一组p,使得下面的函数S的值最小：</p><script type="math/tex; mode=display">S(p) = \sum_{i=1}^M[y_i - f(x_i,p)]^2</script><p>这种算法被称为最小二乘拟合(Least-square fitting)。在optimize 模块中,可以使用leastsq()对数据进行最小二乘拟合计算。</p><h1 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h1><p>虽然pandas采用了大量的NumPy编码风格,但二者最大的不同是pandas是专门为处理表格和混杂 数据设计的。而NumPy更适合处理统一的数值数组数据。</p><p>默认使用使用下面的方式引入pandas:</p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><p>因为Series和DataFrame用的次数非常 多,所以将其引入本地命名空间中会更方便：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame </span><br></pre></td></tr></table></figure><p>要使用pandas,你首先就得熟悉它的两个主要数据结构：Series和DataFrame。</p><h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p>Series是一种类似于一维数组的对象,它由一组数据(各种NumPy数据类型)以及一组与之相关 的数据标签(即索引)组成。仅由一组数据即可产生最简单的Series：</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">obj</span> = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>Series的字符串表现形式为：索引在左边,值在右边。由于没有为数据指定索引,于是会自动创建一个0到N-1(N为数据的长度)的整数型索引。可以通过Series 的values和index属性获取其数组表示形式和索引对象：</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">obj.<span class="built_in">values</span></span><br></pre></td></tr></table></figure><p>可以通过Series带有可以对各个数据点进行标记的索引：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">obj = pd<span class="selector-class">.Series</span>(<span class="selector-attr">[4, 7, -5, 3]</span>, index=<span class="selector-attr">[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span>)</span><br></pre></td></tr></table></figure><p>这样就可以通过索引的方式选取Series中的单个或一组值, 如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">obj<span class="selector-attr">[<span class="string">&#x27;a&#x27;</span>]</span></span><br></pre></td></tr></table></figure><p>如果数据被存放在一个python字典中,也可以直接通过这个字典来创建Series：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span> = &#123;<span class="string">&#x27;Ohio&#x27;</span>: <span class="number">35000</span>, <span class="string">&#x27;Texas&#x27;</span>: <span class="number">71000</span>, <span class="string">&#x27;Oregon&#x27;</span>: <span class="number">16000</span>, <span class="string">&#x27;Utah&#x27;</span>: <span class="number">5000</span>&#125;</span><br><span class="line"><span class="attr">obj</span> = pd.Series(sdata)</span><br></pre></td></tr></table></figure><p>对于许多应用而言,Series最重要的一个功能是,它会根据运算的索引标签自动对齐数据。</p><h1 id="类函数的编写"><a href="#类函数的编写" class="headerlink" title="类函数的编写"></a>类函数的编写</h1><p>已自己写的简单的串联机器人的运动学为例,</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">robot</span>:</span><br><span class="line">    def __init__(<span class="keyword">self</span>,theta0,alpha,a,d,beta,tool):</span><br><span class="line">        <span class="keyword">self</span>.theta0 = deg2<span class="title class_ inherited__">Rad</span>(np.array(theta0))  #这里引入了其他地方写的函数,不过非常简单,就是将输入角度变成弧度</span><br><span class="line">        <span class="keyword">self</span>.alpha = deg2<span class="title class_ inherited__">Rad</span>(np.array(alpha))</span><br><span class="line">        <span class="keyword">self</span>.a = np.array(a)</span><br><span class="line">        <span class="keyword">self</span>.d = np.array(d)</span><br><span class="line">        <span class="keyword">self</span>.beta = deg2<span class="title class_ inherited__">Rad</span>(np.array(beta))</span><br><span class="line">        <span class="keyword">self</span>.position = []</span><br><span class="line">        <span class="keyword">self</span>.pose = []</span><br><span class="line">        <span class="keyword">self</span>.<span class="title class_ inherited__">Jacobian</span> = []</span><br><span class="line">        <span class="keyword">self</span>.tool =np.array([[1,0,0,tool[0]],[0,1,0,tool[1]],[0,0,1,tool[2]],[0,0,0,1]])</span><br><span class="line">        np.set_printoptions(suppress=<span class="title class_ inherited__">True</span>)</span><br><span class="line"></span><br><span class="line">    def <span class="title class_ inherited__">FK</span>(<span class="keyword">self</span>,th):</span><br><span class="line">        # 这里theta 的格式为 <span class="title class_ inherited__">N</span>*6, 方便一次性处理</span><br><span class="line">        th = np.array(th).reshape(-1,6)   #主要是担心输入形式为 [0,0,0,0,0,0] 这种格式的</span><br><span class="line">        th = deg2<span class="title class_ inherited__">Rad</span>(th)</span><br><span class="line">        alpha = <span class="keyword">self</span>.alpha</span><br><span class="line">        a = <span class="keyword">self</span>.a</span><br><span class="line">        d = <span class="keyword">self</span>.d</span><br><span class="line">        beta = <span class="keyword">self</span>.beta</span><br><span class="line">        #上面这样写不写,都是无所谓的,追求效率的话,这些代码有很多地方可以优化,不过对于自己处理一些文件,足以。</span><br><span class="line">        axis_z = np.array([0,0,1])</span><br><span class="line">        <span class="title class_ inherited__">T0j</span> = []</span><br><span class="line">        <span class="title class_ inherited__">T0j</span>.append(np.eye(4))</span><br><span class="line">        <span class="keyword">for</span> theta <span class="keyword">in</span> th:</span><br><span class="line">            theta = np.array(theta) + <span class="keyword">self</span>.theta0    #以零点作为基准</span><br><span class="line">            <span class="title class_ inherited__">T</span> = np.eye(4)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(6):</span><br><span class="line">                cth = np.cos(theta[i])</span><br><span class="line">                sth = np.sin(theta[i])</span><br><span class="line">                ca = np.cos(alpha[i])</span><br><span class="line">                sa = np.sin(alpha[i])</span><br><span class="line">                cb = np.cos(beta[i])</span><br><span class="line">                sb = np.sin(beta[i])</span><br><span class="line">                tans =  np.array(   [[cth, -sth * ca, sth * sa, a[i] * cth],</span><br><span class="line">                                     [sth, cth * ca, -cth * sa, a[i] * sth],</span><br><span class="line">                                     [0,   sa,       ca,        d[i]],</span><br><span class="line">                                     [0,   0,         0,         1]])</span><br><span class="line">                rot<span class="title class_ inherited__">Beta</span> = np.array([[cb, 0, sb, 0],</span><br><span class="line">                                    [0, 1, 0, 0],</span><br><span class="line">                                    [-sb, 0, cb, 0],</span><br><span class="line">                                    [0, 0, 0, 1]])#标准的<span class="title class_ inherited__">DH参数里面</span>,没有用到beta参数,即绕<span class="title class_ inherited__">Y轴旋转的</span>,根据标定的结果为准。</span><br><span class="line">                <span class="title class_ inherited__">A</span> =  np.dot(tans, rot<span class="title class_ inherited__">Beta</span>)</span><br><span class="line">                <span class="title class_ inherited__">T</span> = np.dot(<span class="title class_ inherited__">T</span>,<span class="title class_ inherited__">A</span>)</span><br><span class="line">                <span class="title class_ inherited__">T0j</span>.append(<span class="title class_ inherited__">T</span>)</span><br><span class="line"></span><br><span class="line">            <span class="title class_ inherited__">T0t</span> = np.dot(<span class="title class_ inherited__">T</span>,<span class="keyword">self</span>.tool)</span><br><span class="line">            <span class="keyword">self</span>.position.append(<span class="title class_ inherited__">T0t</span>[:3,3])</span><br><span class="line">            # 求解雅克比矩阵,雅克比矩阵能用到的地方太多了,也太重要了。</span><br><span class="line">            <span class="title class_ inherited__">J</span> = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(6):</span><br><span class="line">                vec_<span class="title class_ inherited__">Z</span> = np.dot(<span class="title class_ inherited__">T0j</span>[i][:3,:3],axis_z)</span><br><span class="line">                <span class="title class_ inherited__">Tjt</span> = np.dot(np.linalg.inv(<span class="title class_ inherited__">T0j</span>[i]),<span class="title class_ inherited__">T0t</span>)</span><br><span class="line">                vec_<span class="title class_ inherited__">P</span> = np.dot(<span class="title class_ inherited__">T0j</span>[i][:3,:3],<span class="title class_ inherited__">Tjt</span>[:3,3])</span><br><span class="line">                <span class="title class_ inherited__">J</span>.append(np.cross(vec_<span class="title class_ inherited__">Z</span>,vec_<span class="title class_ inherited__">P</span>))</span><br><span class="line">            <span class="keyword">self</span>.<span class="title class_ inherited__">Jacobian</span>.append(np.array(<span class="title class_ inherited__">J</span>).transpose())</span><br></pre></td></tr></table></figure><p>调用的话,就比较简单了：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">dhPar = np.array([[ 0,        154,             0,         -90,           0],</span><br><span class="line">                 [-90,          0,       418.865,           0,           0],</span><br><span class="line">                 [  0,          0,       387.265,           0,           0],</span><br><span class="line">                 [ 90,    144.421,             0,          90,           0],</span><br><span class="line">                 [  0,    122.213,             0,          90,           0],</span><br><span class="line">                 [  0,      107.5,             0,           0,           0]])</span><br><span class="line">                 <span class="comment">#输入标定里面的结果</span></span><br><span class="line">theta0 = [0,0,0,0,0,0]  <span class="comment"># 根据具体的标定,去选择修正。 </span></span><br><span class="line">theta0 = dhPar[:,0] - np.array(theta0)</span><br><span class="line">d = dhPar[:,1]</span><br><span class="line">a = dhPar[:,2]</span><br><span class="line">alpha = dhPar[:,3]</span><br><span class="line">beta =  dhPar[:,4]</span><br><span class="line">toolOffset=[44.927,-21.859,62.138]    <span class="comment">#工具坐标系</span></span><br><span class="line">yourRobot = robot(theta0,alpha,a,d,beta,toolOffset)  <span class="comment">#实例的时候,就会初始化给那些成员函数,和C++非常相似</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thetaTest = [[-18.417,22.954,97.427,-125.640,108.328,-87.907]]  <span class="comment">#可以写入 N*6 行的关节角,方便一次性在函数体内进行计算</span></span><br><span class="line">ECR5.FK(thetaTest)                                              <span class="comment">#通过正解,可以算出很多结果。</span></span><br><span class="line">print(ECR5.position)<span class="comment">#输出结果,或者是将结果做下一部的转化、或给其他函数做输入等等。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="处理矩阵经常用到的"><a href="#处理矩阵经常用到的" class="headerlink" title="处理矩阵经常用到的"></a>处理矩阵经常用到的</h1><h2 id="利用行列向量生成对角阵"><a href="#利用行列向量生成对角阵" class="headerlink" title="利用行列向量生成对角阵"></a>利用行列向量生成对角阵</h2><p>这个问题的引入是在自己做辨识的时候用上的,需要将力矩向量变成对角矩阵,然后进行辨识。</p><p>大致有三种方法,<code>np.array</code> + <code>np.diag</code>,<code>np.array</code> + <code>np.identity</code>,<code>np.matrix</code> + <code>np.diagflat</code>。其中最快的属于第一种,下面给出第一种的使用：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">tau = np<span class="selector-class">.array</span>(tau)</span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tau))</span><br><span class="line">tor = np<span class="selector-class">.diag</span>(tau<span class="selector-attr">[i]</span>)</span><br></pre></td></tr></table></figure><h1 id="矩阵的合并"><a href="#矩阵的合并" class="headerlink" title="矩阵的合并"></a>矩阵的合并</h1><p>矩阵合并用的最多的是<code>np.append</code>, 比如<code>np.append(m1,m2,axis = 0)</code> 表示合并列,和matlab <code>[a;b]</code>, 很相似,类似的,<code>np.append(m1,m2,axis=1)</code>和 matlab <code>[a,b]</code> 类似,为列合并。</p><h1 id="获取xml中的数据"><a href="#获取xml中的数据" class="headerlink" title="获取xml中的数据"></a>获取xml中的数据</h1><p>这个是为了方便自己在读取DH参数的时候用到的。</p><h3 id="xml中节点包含的属性："><a href="#xml中节点包含的属性：" class="headerlink" title="xml中节点包含的属性："></a>xml中节点包含的属性：</h3><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>, nodeName——节点名称</span><br><span class="line"><span class="number">2</span>, nodeValue——节点值</span><br><span class="line"><span class="number">3</span>, <span class="keyword">nodeType</span>——节点类型</span><br><span class="line">   <span class="keyword">nodeType</span>为<span class="number">1</span>说明是元素节点,<span class="keyword">nodeType</span>为<span class="number">2</span>说明是属性节点。</span><br></pre></td></tr></table></figure><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">1, 元素节点</span><br><span class="line">2, 文本节点</span><br><span class="line">3, 属性节点</span><br></pre></td></tr></table></figure><h3 id="python获取xml节点："><a href="#python获取xml节点：" class="headerlink" title="python获取xml节点："></a>python获取xml节点：</h3><p>DH.xml文件 (简单的例子)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DH</span>&gt;</span>            </span><br><span class="line">        <span class="tag">&lt;<span class="name">Axis1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">theta</span>&gt;</span>0<span class="tag">&lt;/<span class="name">theta</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">d</span>&gt;</span>154.0<span class="tag">&lt;/<span class="name">d</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span>&gt;</span>-0.631<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">alpha</span>&gt;</span>-90.045<span class="tag">&lt;/<span class="name">alpha</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">beta</span>&gt;</span>0<span class="tag">&lt;/<span class="name">beta</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Axis1</span>&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">DH</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import lsqyRobot as lR</span><br><span class="line">from xml<span class="selector-class">.dom</span> import minidom</span><br><span class="line"></span><br><span class="line">xmlFile = lR<span class="selector-class">.askFileWhere</span>()</span><br><span class="line">dom=minidom<span class="selector-class">.parse</span>(xmlFile)</span><br><span class="line">root=dom<span class="selector-class">.documentElement</span>       #获取dom对象元素</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(root.nodeName)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(root.nodeValue)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(root.nodeType)</span></span></span><br></pre></td></tr></table></figure><p>其中 askFilewhere() 在 <code>lsqyRobot.py</code> (为方便自己写的函数包)代码如下</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">def <span class="built_in">askFileWhere</span>():</span><br><span class="line">    root = tk.<span class="built_in">Tk</span>()</span><br><span class="line">    root.<span class="built_in">withdraw</span>()</span><br><span class="line">    file_path = filedialog.<span class="built_in">askopenfilename</span>()</span><br><span class="line">    return file_path</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="/img/postImg/9_Python/xmlEx1.png" alt=""></p><p>这里如果想在打开文件的时候给予提示,可将 <code>askFileWhere()</code>改写为：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">def <span class="built_in">askFileWhere</span>(tit):</span><br><span class="line">    root = tk.<span class="built_in">Tk</span>()</span><br><span class="line">    root.<span class="built_in">withdraw</span>()</span><br><span class="line">    file_path = filedialog.<span class="built_in">askopenfilename</span>(title = <span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(tit))</span><br><span class="line">    return file_path</span><br></pre></td></tr></table></figure><h4 id="打印标签对之间的数据"><a href="#打印标签对之间的数据" class="headerlink" title="打印标签对之间的数据"></a>打印标签对之间的数据</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">node</span>.firstChild.<span class="class"><span class="keyword">data</span></span></span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">import lsqyRobot as lR</span><br><span class="line">from xml.dom import minidom</span><br><span class="line"></span><br><span class="line"><span class="attribute">xmlFile</span> <span class="operator">=</span> lR.askFileWhere()</span><br><span class="line"><span class="attribute">dom</span><span class="operator">=</span>minidom.parse(xmlFile)</span><br><span class="line"><span class="attribute">thetaValue</span> <span class="operator">=</span> dom.getElementsByTagName(<span class="string">&quot;theta&quot;</span>)</span><br><span class="line"><span class="attribute">dValue</span><span class="operator">=</span> dom.getElementsByTagName(<span class="string">&quot;d&quot;</span>)</span><br><span class="line"><span class="attribute">aValue</span><span class="operator">=</span> dom.getElementsByTagName(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="attribute">alphaValue</span> <span class="operator">=</span> dom.getElementsByTagName(<span class="string">&quot;alpha&quot;</span>)</span><br><span class="line"><span class="attribute">betaValue</span> <span class="operator">=</span> dom.getElementsByTagName(<span class="string">&quot;beta&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下(调试状态,其实都可以看到值,感兴趣的自己去尝试下,并不难)</p><p><img src="/img/postImg/9_Python/xmlEx2.png" alt=""></p><p>目前就记录到这,用到再记了。</p><h1 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h1><p>事情的起因是要筛选标定程序里的一些点的,由于在标定的时候,自动生成的点位(一般是朝着一个方向,即姿态不怎么发生变化),需要实际去跑这些点位,可有的时候自动生成的点位无法保证是安全的,这样就需要手动去调整,这个时候需要筛选出调整后的点位。比如最后调整好的文件可能是长成这样的：</p><p><img src="/img/postImg/9_Python/targetPoint1.png" alt=""></p><p>不过只需要里面的数字,就是画黄线那部分,还需要将<code>,</code>,变成<code>Tab</code>, 或者是<code>\t</code>,用 vim 的正则等可以非常快的(大概一分钟)就能解决这个问题, 第一步,除了选中部分,其他部分均删除：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">:v /<span class="tag">&lt;<span class="name">target</span>&gt;</span>/d</span><br></pre></td></tr></table></figure><p>通过这一步就差不多把需要的给筛选出来了</p><p><img src="/img/postImg/9_Python/targetPoint2.png" alt=""></p><p>剩下的就是简单的vim正则替换了:</p><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">:<span class="variable">%s</span> /&lt;target&gt;POINTJ&lt;<span class="regexp">//g</span>|<span class="variable">%s</span> /)&lt;\/target&gt;<span class="regexp">//g</span>|<span class="variable">%s</span> /,<span class="regexp">/\t/g</span></span><br></pre></td></tr></table></figure><p><img src="/img/postImg/9_Python/targetPoint3.png" alt=""></p><p><img src="/img/postImg/9_Python/targetPoint4.png" alt=""></p><p>这个前提是对 <code>vim</code> 的正则替换有些熟悉,哪怕几百万行,替换的时间也是非常短的,当然,这种核心思想在于正则替换,使用python一样可以做。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式提供了一种灵活的在文本中搜索或匹配(通常比前者复杂)字符串模式的方式。正则表 达式,常称作regex,是根据正则表达式语言编写的字符串。Python内置的re模块负责对字符串应 用正则表达式。</p><p>re模块的函数可以分为三个大类：模式匹配、替换以及拆分。当然,它们之间是相辅相成的。一个 regex描述了需要在文本中定位的一个模式,它可以用于许多目的。</p><h3 id="re-compile-函数"><a href="#re-compile-函数" class="headerlink" title="re.compile 函数"></a>re.compile 函数</h3><p>compile 函数用于编译正则表达式,生成一个正则表达式( Pattern )对象,供 match() 和 search() 这两个函数使用。语法格式为：</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">re.compile(pattern[, flags])</span><br><span class="line">pattern : 一个字符串形式的正则表达式</span><br><span class="line">flags : 可选,表示匹配模式,比如忽略大小写,多行模式等,具体参数为：</span><br><span class="line">re.I 忽略大小写</span><br><span class="line">re.L 表示特殊字符集 <span class="string">\w,</span> <span class="string">\W,</span> <span class="string">\b,</span> <span class="string">\B,</span> <span class="string">\s,</span> <span class="string">\S</span> 依赖于当前环境</span><br><span class="line">re.M 多行模式</span><br><span class="line">re.S 即为 . 并且包括换行符在内的任意字符(. 不包括换行符)</span><br><span class="line">re.U 表示特殊字符集 <span class="string">\w,</span> <span class="string">\W,</span> <span class="string">\b,</span> <span class="string">\B,</span> <span class="string">\d,</span> <span class="string">\D,</span> <span class="string">\s,</span> <span class="string">\S</span> 依赖于 Unicode 字符属性数据库</span><br><span class="line">re.X 为了增加可读性,忽略空格和 <span class="comment"># 后面的注释</span></span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="动态生成变量名"><a href="#动态生成变量名" class="headerlink" title="动态生成变量名"></a>动态生成变量名</h2><p>在我的收藏夹吃灰了好久，收藏的具体原因给忘了，应该不怎么常用</p><p>如果你想生成v1,v2…v100这一百个变量，使用其他静态编译语言只能在代码中手动写出这100个变量名，但是在python中可以使用循环方便地动态生成。 python中有一个函数locals()，定义是：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">locals</span>(...)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">locals</span>() -&gt; dictionary</span><br></pre></td></tr></table></figure><p>即返回当前作用域的所有变量, 所以可以用这个函数来创建变量</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    name=<span class="string">&#x27;v&#x27;</span>+<span class="built_in">str</span>(i)</span><br><span class="line">    <span class="built_in">locals</span>()<span class="selector-attr">[<span class="string">&#x27;v&#x27;</span>+str(i)]</span>=<span class="selector-tag">i</span></span><br><span class="line"></span><br><span class="line">print v1,v2,v3</span><br></pre></td></tr></table></figure><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><p>1, 在使用np.array的时候,默认是以科学计数法来显示的,在写机器人代码的时候与示教器上的数值进行核对时,会有些费事,使其正常显示可以设置为</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">np.set_printoptions(<span class="attribute">suppress</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>2, 保存高清图像,指定 <code>dpi</code> 与设置bbox_inches=‘tight’,这里dpi越大,越清晰,当然,导出的时间也越慢。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;./yourPic.jpg&#x27;</span>,<span class="attribute">dpi</span>=500,bbox_inches = <span class="string">&#x27;tight&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] 《python 科学计算》—— 张若愚等著</p><p>[2] 《利用 Python 进行数据分析》——Mckinney Wes</p><p>[3] <a href="https://blog.csdn.net/hju22">龟的小号</a></p><p>[4] (Python 动态生成变量名)(<a href="https://blog.csdn.net/Baoli1008/article/details/47980779">https://blog.csdn.net/Baoli1008/article/details/47980779</a>)</p>]]></content>
      
      
      <categories>
          
          <category> PYTHON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ODEs</title>
      <link href="/2021/03/21/archived_ODEs/"/>
      <url>/2021/03/21/archived_ODEs/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#刚性问题">刚性问题</a></li><li><a href="#解算刚性-ode">解算刚性 ODE</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>了解常微分方程的数值求解,有利于进行数值仿真。这部分是自己读研时候,自学《数值分析》与在进行机器人的动力学仿真时经常接触到的一项内容,简单的来说,对机器人进行动力学仿真的时候(不考虑柔性等),是求解常微分方程<strong>组</strong>(ODES)的过程(对于二阶乃至于高阶问题,都可以化成一阶来求解),有很多有趣的东西在里面。正好今天在<a href="https://ww2.mathworks.cn/help/matlab/math/solve-stiff-odes.html">MATLAB官网</a>上看到了一些当年了解过的东西,想简要的对数值积分这部分内容做一点初步的介绍。</p><h1 id="刚性问题"><a href="#刚性问题" class="headerlink" title="刚性问题"></a>刚性问题</h1><p>对于一些 ODE 问题,求解器采用的步长被强制缩小为与积分区间相比过小的级别,甚至在解曲线平滑的区域亦如此。这些步长可能过小,以至于遍历很短的时间区间都可能需要数百万次计算。这可能导致求解器积分失败,即使积分成功也需要花费很长时间。导致 ODE 求解器出现此行为的方程称为<em>刚性</em>方程。刚性 ODE 造成的问题是,显式求解器(例如 <code>ode45</code>)获取解的速度慢得令人无法忍受。这是将 <code>ode45</code> 与 <code>ode23</code> 和 <code>ode113</code> 一同归类为<em>非刚性求解器</em>的原因所在。专用于刚性 ODE 的求解器称为<em>刚性求解器</em>,它们通常在每一步中完成更多的计算工作。这样做的好处是,它们能够采用大得多的步长,并且与非刚性求解器相比提高了数值稳定性。</p><h1 id="解算刚性-ODE"><a href="#解算刚性-ODE" class="headerlink" title="解算刚性 ODE"></a>解算刚性 ODE</h1><p>MATLAB拥有四个专用于刚性 ODE 的求解器,分别是：ode15s、ode23s、ode23t、ode23tb,对于大多数刚性问题,<code>ode15s</code> 的性能最佳。但如果问题允许较宽松的误差容限,则 <code>ode23s</code>、<code>ode23t</code> 和 <code>ode23tb</code> 可能更加高效。在对机器人进行动力学等数值仿真的时候,大多数情况下会选择ode45或者是ode15s, 视问题的复杂度来看。数值仿真可以理解为自己写程序,得到数值解。</p>]]></content>
      
      
      <categories>
          
          <category> MATLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> math </tag>
            
            <tag> simulation </tag>
            
            <tag> ODE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FCPX 学习</title>
      <link href="/2021/03/05/archived_FCPX/"/>
      <url>/2021/03/05/archived_FCPX/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#创建项目">创建项目</a><ul><li><a href="#导入素材快捷键">导入素材快捷键</a></li><li><a href="#剪切视频时的快捷键">剪切视频时的快捷键</a></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用FCPX已经有大半年的时间了,中间陆陆续续学到了一点点技巧,像任何一门技术一样,都没能够好好的进行整理,时间不知不觉,就过去了,每每想到,就感觉有些可惜,因此,结合着自己的使用经历,记录一份自己认为有用的点,最快的方式就是去练习,有问题再去找相关的解决办法,无论是通过看视频,还是搜索博客,这些都是很快能够达到自己目的的一种方式,像极了学其他技术的样子,当然,想用好还是需要时间的,所以说呢,时间是非常非常珍贵的。记录的很多内容是从网上获取得到的。</p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>首先要建立“资源库“,此时软件会自动新建一个以当前日期命名的”事件“,事件中可以新建”项目“。”资源库“可以理解为一级文件夹,事件是其下面的二级文件夹,项目依托于事件,为事件中的文件(也就是后面剪视频时的一条时间线)。</p><h2 id="导入素材快捷键"><a href="#导入素材快捷键" class="headerlink" title="导入素材快捷键"></a>导入素材快捷键</h2><p>比较方便导入素材的方式就是使用快捷键了,在导入素材的时候,主要有六个快捷键,将鼠标放待拖入的视频或图片,开始处按I,结束处按O,再拖入时间线。</p><p>E：把所选素材片段放置到时间线的最后,不覆盖其他片段；</p><p>Q：把所选素材片段放置到当前时间轴的位置,不覆盖其他片段；</p><p>W：把所选素材片段插入到当前时间轴的位置,其他片段会(被)自动切割开来；</p><p>D：把所选素材片段覆盖到当前时间轴的位置,其他片段位置不变 但会被覆盖和裁剪；</p><h2 id="剪切视频时的快捷键"><a href="#剪切视频时的快捷键" class="headerlink" title="剪切视频时的快捷键"></a>剪切视频时的快捷键</h2><p>B(切割) 对时间线上视频直接切割,切割完后按A(选择)切换回来,接着进行位置的拖动；</p><p>T(修剪) 为按住左右拖动修剪素材,拖到红线表示到头；</p><p>P(直接移动片段),中间空挡处自动添加黑场；</p><p>R(范围选择),可在时间线上选择一段范围,比如先选范围,再让此范围素材音量降低；</p><p>Z(放大时间线),可用触控板缩放代替,或Command+”+/-“ ；按住Shift + Z：在一个页面中看到全部时间线的内容,自动缩放时间线到合适大小全部显示；</p><p>H(手),可拖动整个时间线移动</p><p>N(吸附),也是右边第四个按钮,开启吸附后片段与片段之间就会吸附；不同轨道也会上下吸附对齐；</p><p>注： 怎么才记录这点东西。。。。好久没用这个软件都忘的差不多了</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://huhong12345.github.io/2020/02/15/Final%20Cut%20Pro%20%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">MaximeHu</a></p>]]></content>
      
      
      <categories>
          
          <category> LIFE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FCPX </tag>
            
            <tag> Life </tag>
            
            <tag> Interest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 及 Ros 配置</title>
      <link href="/2021/03/05/archived_Ubuntu/"/>
      <url>/2021/03/05/archived_Ubuntu/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#关掉sudo的密码">关掉sudo的密码</a></li><li><a href="#oh-my-zsh">Oh-My-Zsh</a></li><li><a href="#ros-的安装">ROS 的安装</a></li><li><a href="#关闭ubuntu开机时输入密码">关闭Ubuntu开机时输入密码</a></li><li><a href="#dpkg-frontend-lock">dpkg frontend lock</a></li><li><a href="#查看根文件磁盘空间使用情况">查看根文件磁盘空间使用情况</a></li><li><a href="#删除桌面图标">删除桌面图标</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>简要的记录配置 <code>Ubuntu</code> 与 <code>ROS</code> 的过程,感觉在Docker 里面运行 ROS 还是不舒服的,因此在自己的windows电脑里安装了 VirtualBox(主要是开源免费), 进而安装了 Ubuntu 2020版本的。几年之前把实验室那台电脑配置的好好的,但是很多东西都忘记了,感觉还是有记录的必要性的。</p><p>下面的内容是参考了 <a href="https://yangbingdong.com/2017/ubuntu-todo-after-install/">yangbingdong</a>的博客进行配置的。</p><h1 id="关掉sudo的密码"><a href="#关掉sudo的密码" class="headerlink" title="关掉sudo的密码"></a>关掉sudo的密码</h1><p>先修改默认编辑器为vim(默认为nano):</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo <span class="keyword">update</span><span class="operator">-</span>alternatives <span class="comment">--config editor</span></span><br></pre></td></tr></table></figure><p>输入vim对应的序号回车即可。</p><p>打开 <code>visudo</code> </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> visudo</span><br></pre></td></tr></table></figure><p>找到</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># Allow members <span class="keyword">of</span> <span class="keyword">group</span> sudo <span class="keyword">to</span> <span class="keyword">execute</span> <span class="keyword">any</span> command</span><br><span class="line">%sudo   <span class="keyword">ALL</span>=(<span class="keyword">ALL</span>:<span class="keyword">ALL</span>) <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">%sudo   <span class="keyword">ALL</span>=(<span class="keyword">ALL</span>:<span class="keyword">ALL</span>) NOPASSWD:<span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><p>这样所有sudo组内的用户使用sudo时就不需要密码了。</p><p>如果不小心输入错了且保存退出了,再用 <code>sudo visudo</code> 可能就进不去了,这时候可通过 <code>pkexec visudo</code> 来修复这一问题。</p><h1 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh-My-Zsh"></a>Oh-My-Zsh</h1><p>首先, 安装 <code>Zsh</code></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install zsh</span><br></pre></td></tr></table></figure><p>接下来需要下载 <code>oh-my-zsh</code> 项目来帮我们配置 <code>zsh</code>, 采用<code>wget</code>安装(需要先安装<code>git</code>)</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install git -y</span><br></pre></td></tr></table></figure><p>然后输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>更换shell,运行以下命令将默认shell更改为Zsh：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">chsh -s $(which zsh)</span><br></pre></td></tr></table></figure><h1 id="ROS-的安装"><a href="#ROS-的安装" class="headerlink" title="ROS 的安装"></a>ROS 的安装</h1><p>这个维基百科说的太详细了,可参考网址 <code>wiki.ros.org/noetic/installnation/Ubuntu</code>,下面就简要的说一部分。首先先设置好Ubuntu 软件更新那部分,需要将允许 “restricted”,”universe”和“multiverse”,可参考网址 <code>https://help.ubuntu.com/community/Repositories/Ubuntu</code> </p><p>然后添加ROS源</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sudo sh -c &#x27;<span class="keyword">echo</span> <span class="string">&quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot;</span> &gt; <span class="string">/etc/apt/sources.list.d/ros-latest.list</span>&#x27;</span><br></pre></td></tr></table></figure><p>和密钥</p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">sudo</span> <span class="string">apt-key</span> <span class="string">adv</span> <span class="built_in">--keyserver</span> <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> <span class="built_in">--recv-key</span> <span class="string">C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span></span><br></pre></td></tr></table></figure><p>添加结束后,刷新下 <code>sudo apt-get update</code>, 安装即可(我这里都安装了)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install ros-noetic-desktop-full</span><br></pre></td></tr></table></figure><p>如果不想每次打开命令行都 <code>souce /opt/ros/noetic/setup.bash</code>, 可以将此内容加到bash或zsh中,看自己用的shell了,自己的是zsh,所以直接加进去即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;souce /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><p>这样每次打开一个命令行的时候,都会运行。</p><h1 id="关闭Ubuntu开机时输入密码"><a href="#关闭Ubuntu开机时输入密码" class="headerlink" title="关闭Ubuntu开机时输入密码"></a>关闭Ubuntu开机时输入密码</h1><p>主要是每次登陆虚拟机都要输入开机密码,比较烦, 有个简单的办法可以关闭, 在设置里找到下图所示的位置, 点击自动登陆即可</p><div align="center"> <img src="/img/postImg/38_ubuntu/automaticLogin.png" width="100%" height="40%"> </div><h1 id="dpkg-frontend-lock"><a href="#dpkg-frontend-lock" class="headerlink" title="dpkg frontend lock"></a>dpkg frontend lock</h1><p>常见报错了。。。。</p><p>Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /var/lib/dpkg/lock-frontend</span><br><span class="line"><span class="built_in">sudo</span> dpkg --configure -a</span><br></pre></td></tr></table></figure><h1 id="查看根文件磁盘空间使用情况"><a href="#查看根文件磁盘空间使用情况" class="headerlink" title="查看根文件磁盘空间使用情况"></a>查看根文件磁盘空间使用情况</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -h | grep <span class="string">&#x27;/$&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="删除桌面图标"><a href="#删除桌面图标" class="headerlink" title="删除桌面图标"></a>删除桌面图标</h1><p>个人问题， 喜欢桌面的清洁，除非非常非常重要的东西，一般不会把任何文件放置在桌面上的，下面主要是针对不容易删除的图标进行的操作</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">gsettings set org<span class="selector-class">.gnome</span><span class="selector-class">.shell</span><span class="selector-class">.extensions</span><span class="selector-class">.desktop-icons</span> show-trash false</span><br><span class="line">gsettings set org<span class="selector-class">.gnome</span><span class="selector-class">.shell</span><span class="selector-class">.extensions</span><span class="selector-class">.desktop-icons</span> show-home false</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 的使用</title>
      <link href="/2021/02/25/archived_GIT/"/>
      <url>/2021/02/25/archived_GIT/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#基本操作">基本操作</a><ul><li><a href="#初始化仓库">初始化仓库</a></li><li><a href="#查看仓库的状态">查看仓库的状态</a></li><li><a href="#向暂存区中添加文件">向暂存区中添加文件</a></li><li><a href="#保存仓库的历史记录">保存仓库的历史记录</a><ul><li><a href="#记述一行提交信息">记述一行提交信息</a></li><li><a href="#记述详细提交信息">记述详细提交信息</a></li><li><a href="#中止提交">中止提交</a></li></ul></li><li><a href="#查看提交日志">查看提交日志</a><ul><li><a href="#只显示提交信息的第一行">只显示提交信息的第一行</a></li><li><a href="#只显示指定目录文件的日志">只显示指定目录、文件的日志</a></li><li><a href="#显示文件的改动">显示文件的改动</a></li></ul></li></ul></li><li><a href="#分支的操作">分支的操作</a><ul><li><a href="#分支查看与切换">分支查看与切换</a></li><li><a href="#新建分支并切换">新建分支并切换</a></li><li><a href="#合并分支">合并分支</a></li><li><a href="#图表形式查看分支">图表形式查看分支</a></li></ul></li><li><a href="#更改提交的操作">更改提交的操作</a><ul><li><a href="#回溯历史版本">回溯历史版本</a></li><li><a href="#修复未提交文件中的错误重置">修复未提交文件中的错误(重置)</a></li><li><a href="#修复已提交文件中的错误">修复已提交文件中的错误</a><ul><li><a href="#没有-add没有添加到暂存区">没有 add（没有添加到暂存区）</a></li><li><a href="#创建新提交来修复错误">创建新提交来修复错误</a></li><li><a href="#修改提交来修复错误">修改提交来修复错误</a></li></ul></li></ul></li><li><a href="#乱码解决办法">乱码解决办法</a></li><li><a href="#常用指令的具体介绍">常用指令的具体介绍</a><ul><li><a href="#git-clean">git clean</a><ul><li><a href="#删除-untracked-files">删除 untracked files</a></li><li><a href="#删除-untracked-文件和目录">删除 untracked 文件和目录</a></li><li><a href="#连-gitignore-的-untracked-文件和目录也一起删掉">连 gitignore 的 untracked 文件和目录也一起删掉</a></li></ul></li><li><a href="#git-diff">git diff</a></li><li><a href="#git-tag">git tag</a><ul><li><a href="#创建标签">创建标签</a></li><li><a href="#创建一个带有注释的标签">创建一个带有注释的标签</a></li><li><a href="#查看标签">查看标签</a></li><li><a href="#查看特定标签的详细信息">查看特定标签的详细信息</a></li><li><a href="#推送标签到远程仓库">推送标签到远程仓库</a></li><li><a href="#删除标签">删除标签</a><ul><li><a href="#删除本地标签">删除本地标签</a></li><li><a href="#删除远程标签">删除远程标签</a></li></ul></li><li><a href="#切换到标签对应的提交">切换到标签对应的提交</a></li><li><a href="#检出标签的特定文件版本">检出标签的特定文件版本</a></li><li><a href="#在标签上创建新分支">在标签上创建新分支</a></li><li><a href="#对以前提交的信息打标签">对以前提交的信息打标签</a></li></ul></li></ul></li><li><a href="#代码冲突检测">代码冲突检测</a><ul><li><a href="#检查是否存在冲突">检查是否存在冲突</a></li><li><a href="#查看冲突文件">查看冲突文件</a></li></ul></li><li><a href="#遇到的问题">遇到的问题</a><ul><li><a href="#无法推送">无法推送</a></li><li><a href="#提交中文字符乱码问题">提交中文字符乱码问题</a></li></ul></li><li><a href="#fatal-lf-would-be-replace-by-crlf">fatal: LF would be replace by CRLF</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用了好几年的工具了,主要被我用来记录更新时候的点滴,有时回过头看看,一路上不太容易。对于以后日益复杂的项目, 会一点简单的 Git 指令显然是不能满足要求的,所以打算记录一些笔记,留给自己日后查阅使用。</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mkdir</span> <span class="keyword">file</span></span><br><span class="line"><span class="keyword">cd</span> <span class="keyword">file</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure><p>如果初始化成功,执行了git init命令的目录下就会生成 .git 目录。这个 <code>.git</code> 目录里存储着管理当前目录内容所需的仓库数据。 在 Git 中,将这个目录的内容称为“附属于该仓库的工作树”。 文件的编辑等操作在工作树中进行,然后记录到仓库中,以此管理文件的历史快照。如果想将文件恢复到原先的状态,可以从仓库中调取之前的快照,在工作树中打开。</p><h2 id="查看仓库的状态"><a href="#查看仓库的状态" class="headerlink" title="查看仓库的状态"></a>查看仓库的状态</h2><p><code>git status</code> 命令用于显示 Git 仓库的状态。</p><h2 id="向暂存区中添加文件"><a href="#向暂存区中添加文件" class="headerlink" title="向暂存区中添加文件"></a>向暂存区中添加文件</h2><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span></span><br></pre></td></tr></table></figure><p>如果只是用 Git 仓库的工作树创建了文件,那么该文件并不会被记<br>入 Git 仓库的版本管理对象当中。因此我们用 git status命令查看 README.md 文件时,它会显示在 Untracked files 里。要想让文件成为 Git 仓库的管理对象,就需要用<code>git add</code>命令将其 加入暂存区(Stage 或者 Index)中。暂存区是提交之前的一个临时区域。如果提交有错误,想强制提交的话,可用如下指令</p><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">git add</span> <span class="literal">--</span><span class="comment">ignore</span><span class="literal">-</span><span class="comment">errors</span> <span class="literal">--</span><span class="comment">force</span> <span class="string">.</span></span><br></pre></td></tr></table></figure><h2 id="保存仓库的历史记录"><a href="#保存仓库的历史记录" class="headerlink" title="保存仓库的历史记录"></a>保存仓库的历史记录</h2><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git commit</span></span><br></pre></td></tr></table></figure><p><code>git commit</code> 命令可以将当前暂存区中的文件实际保存到仓库的历 史记录中。通过这些记录,就可以在工作树中复原文件。</p><h3 id="记述一行提交信息"><a href="#记述一行提交信息" class="headerlink" title="记述一行提交信息"></a>记述一行提交信息</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">&quot;First commit&quot;</span></span><br></pre></td></tr></table></figure><p>-m 参数后的 “First commit”称作提交信息,是对这个提交的 记述详细提交信息概述。</p><h3 id="记述详细提交信息"><a href="#记述详细提交信息" class="headerlink" title="记述详细提交信息"></a>记述详细提交信息</h3><p>如果想要记述得更加详细,请不加 -m,直接执行git commit命令。执行后编辑器就会启动,并显示如下结果。下面的代码前面都有#号,因为在我这编译的时候会有问题,所以就没加上去。</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Please enter <span class="keyword">the</span> commit message <span class="keyword">for</span> your changes. Lines starting</span><br><span class="line"><span class="keyword">with</span> <span class="string">&#x27;#&#x27;</span> will be ignored, <span class="keyword">and</span> <span class="keyword">an</span> <span class="literal">empty</span> message aborts <span class="keyword">the</span> commit.</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes <span class="built_in">to</span> be committed:</span><br><span class="line">       <span class="built_in">new</span> <span class="built_in">file</span>:   readme.md</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在编辑器中记述提交信息的格式如下。 </p><p>第一行：用一行文字简述提交的更改内容 </p><p>第二行：空行</p><p>第三行以后：记述更改的原因和详细内容</p><p>只要按照上面的格式输入,今后便可以通过确认日志的命令或工具看到这些记录。在以 # 标为注释的 <code>Changes to be committed</code>(要提交的更改)栏中,可以查看本次提交中包含的文件。将提交信息按格式 记述完毕后,请保存并关闭编辑器,以 #(井号)标为注释的行不必删除。随后,刚才记述的提交信息就会被提交。</p><h3 id="中止提交"><a href="#中止提交" class="headerlink" title="中止提交"></a>中止提交</h3><p>如果在编辑器启动后想中止提交,请将提交信息留空并直接关闭编辑器,随后提交就会被中止。</p><h2 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h2><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>git log命令可以查看以往仓库中提交的日志。包括可以查看什么人在什么时候进行了提交或合并,以及操作前后有怎样的差别。</p><h3 id="只显示提交信息的第一行"><a href="#只显示提交信息的第一行" class="headerlink" title="只显示提交信息的第一行"></a>只显示提交信息的第一行</h3><p>如果只想让程序显示第一行简述信息,可以在 git log命令后加上 <code>--pretty=short</code>。这样一来开发人员就能够更轻松地把握多个提交。</p><h3 id="只显示指定目录、文件的日志"><a href="#只显示指定目录、文件的日志" class="headerlink" title="只显示指定目录、文件的日志"></a>只显示指定目录、文件的日志</h3><p>只要在git log命令后加上目录名,便会只显示该目录下的日志。 如果加的是文件名,就会只显示与该文件相关的日志。</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> README.md</span><br></pre></td></tr></table></figure><h3 id="显示文件的改动"><a href="#显示文件的改动" class="headerlink" title="显示文件的改动"></a>显示文件的改动</h3><p>如果想查看提交所带来的改动,可以加上-p参数,文件的前后差 别就会显示在提交信息之后。<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="punctuation">-</span>p</span><br></pre></td></tr></table></figure></p><h1 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h1><p>在进行多个并行作业时,我们会用到分支。在这类并行开发的过程中,往往同时存在多个最新代码状态。从 master 分支创 建 A 分支和 B 分支后,每个分支中都拥有自己的最新代码。 master 分支是 Git 默认创建的分支,因此基本上所有开发都是以这个分支为中心进行的</p><p>不同分支中,可以同时进行完全不同的作业。等该分支的作业完成之后再与 master 分支合并。如下所示</p><div align="center"> <img src="/img/postImg/6_Git/Git1.png" width="100%" height="40%"> </div><h2 id="分支查看与切换"><a href="#分支查看与切换" class="headerlink" title="分支查看与切换"></a>分支查看与切换</h2><p>查看所有分支<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">git branch -<span class="selector-tag">a</span></span><br></pre></td></tr></table></figure></p><p>查看当前使用分支<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git branch</span></span><br></pre></td></tr></table></figure></p><p>切换分支<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> checkout 分支名</span><br></pre></td></tr></table></figure></p><p>切换回上一个分支</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> checkout -</span><br></pre></td></tr></table></figure><h2 id="新建分支并切换"><a href="#新建分支并切换" class="headerlink" title="新建分支并切换"></a>新建分支并切换</h2><p>想要新建一个分支并同时切换到那个分支上,可使用如下命令(如创建dev并切换):</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git</span> checkout -<span class="keyword">b</span> dev</span><br></pre></td></tr></table></figure><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>假设 A 已经实现完毕,想要将它合并到主干分支 master 中。首先切换到 master 分支。</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git checkout <span class="literal">master</span></span><br></pre></td></tr></table></figure><p>然后合并 feature-A 分支。为了在历史记录中明确记录下本次分支合并,需要创建合并提交。因此,在合并时加上 —no-ff参数。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">git merge <span class="attr">--no-ff</span> <span class="selector-tag">A</span></span><br></pre></td></tr></table></figure><h2 id="图表形式查看分支"><a href="#图表形式查看分支" class="headerlink" title="图表形式查看分支"></a>图表形式查看分支</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--graph</span></span><br></pre></td></tr></table></figure><p>用 <code>git log --graph</code> 命令进行查看的话,能很清楚地看到分支A提交的内容已被合并。</p><h1 id="更改提交的操作"><a href="#更改提交的操作" class="headerlink" title="更改提交的操作"></a>更改提交的操作</h1><h2 id="回溯历史版本"><a href="#回溯历史版本" class="headerlink" title="回溯历史版本"></a>回溯历史版本</h2><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git reset</span></span><br></pre></td></tr></table></figure><h2 id="修复未提交文件中的错误-重置"><a href="#修复未提交文件中的错误-重置" class="headerlink" title="修复未提交文件中的错误(重置)"></a>修复未提交文件中的错误(重置)</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard HEAD</span></span><br></pre></td></tr></table></figure><p>这条件命令会把你工作目录中所有未提交的内容清空。</p><h2 id="修复已提交文件中的错误"><a href="#修复已提交文件中的错误" class="headerlink" title="修复已提交文件中的错误"></a>修复已提交文件中的错误</h2><p>1, 创建一个新的提交(commit),在新的提交里撤消老的提交所作的修改。</p><p>2, 也可以去修改你的老提交(old commit)。但是如果你已经把代码发布了,那么千万别这么做；Git 不会处理项目的历史会改变的情况,如果一个分支的历史被改变了那以后就不能正常的合并。</p><h3 id="没有-add（没有添加到暂存区）"><a href="#没有-add（没有添加到暂存区）" class="headerlink" title="没有 add（没有添加到暂存区）"></a>没有 add（没有添加到暂存区）</h3><p>撤销全部文件修改：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git checkout <span class="comment">-- .</span></span><br></pre></td></tr></table></figure><p>这个是我在犯傻后用<code>argdo %s /old/new/g</code>，发现修改的东西太多了，发现的一个有用的功能；</p><h3 id="创建新提交来修复错误"><a href="#创建新提交来修复错误" class="headerlink" title="创建新提交来修复错误"></a>创建新提交来修复错误</h3><p>创建一个新的,撤消(revert)了前期修改的提交(commit)是很容易的；只要把出错的提交(commit)的名字(reference)做为参数传给命令：git revert就可以了；</p><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">revert</span> HEAD</span><br></pre></td></tr></table></figure><p>撤消“上上次”(next-to-last)的提交：</p><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">revert</span> HEAD^</span><br></pre></td></tr></table></figure><p>git revert其实不会直接创建一个提交(commit),把撤消后的文件内容放到索引(index)里,你需要再执行git commit命令,它们才会成为真正的提交(commit)。</p><h3 id="修改提交来修复错误"><a href="#修改提交来修复错误" class="headerlink" title="修改提交来修复错误"></a>修改提交来修复错误</h3><p>git commit现在支持一个叫—amend的参数,它能让你修改刚才的这个提交(<code>HEAD commit</code>)。这项机制能让你在代码发布前,添加一些新的文件或是修改你的提交注释(commit message)。</p><p>如果你在老提交(older commit)里发现一个错误,但是现在还没有发布到代码服务器上。你可以使用<code>git rebase</code>命令的交互模式,<code>git rebase -i</code>会提示你在编辑中做相关的修改。这样其实就是让你在 rebase 的过程来修改提交。</p><h1 id="乱码解决办法"><a href="#乱码解决办法" class="headerlink" title="乱码解决办法"></a>乱码解决办法</h1><p>在git bash查看日志的时候发现乱码,需要更改一下相关设置即可,在窗口点击右键,选择 <code>Options -&gt; Text</code>, 找到 <code>Locale,Charector set</code>, 并进行如下设置。</p><div align="center"> <img src="/img/postImg/6_Git/gitbash乱码设置.png" width="50%" height="40%"> </div><p>然后在命令窗口中输入如下设置命令即可</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global i18n.commitencoding utf-8</span><br><span class="line">git<span class="built_in"> config </span>--global i18n.logoutputencoding utf-8</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">LESSCHARSET</span>=utf-8</span><br></pre></td></tr></table></figure><h1 id="常用指令的具体介绍"><a href="#常用指令的具体介绍" class="headerlink" title="常用指令的具体介绍"></a>常用指令的具体介绍</h1><h2 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h2><p>要取消已经track过的文件的修改，可以使用git checkout xxx，但是如果要取消 untracked 文件的修改，除了手动删除，还可以用 git clean 命令实现</p><h3 id="删除-untracked-files"><a href="#删除-untracked-files" class="headerlink" title="删除 untracked files"></a>删除 untracked files</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git clean -f</span></span><br></pre></td></tr></table></figure><h3 id="删除-untracked-文件和目录"><a href="#删除-untracked-文件和目录" class="headerlink" title="删除 untracked 文件和目录"></a>删除 untracked 文件和目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git clean -<span class="built_in">df</span></span><br></pre></td></tr></table></figure><h3 id="连-gitignore-的-untracked-文件和目录也一起删掉"><a href="#连-gitignore-的-untracked-文件和目录也一起删掉" class="headerlink" title="连 gitignore 的 untracked 文件和目录也一起删掉"></a>连 gitignore 的 untracked 文件和目录也一起删掉</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git clean -xdf</span></span><br></pre></td></tr></table></figure><p>建议加上-n参数来看看会删掉哪些文件，防止重要文件被误删。</p><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clean</span> -nf</span><br><span class="line">git <span class="built_in">clean</span> -ndf</span><br><span class="line">git <span class="built_in">clean</span> -nxdf</span><br></pre></td></tr></table></figure><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>git diff 命令可以对比两个版本的差异,具体来说包括：</p><p>1, 本地工作区和暂存区的diff信息：git diff 或者 git diff file<br>2, 暂存区和版本库的diff信息（使用git add 将工作区修改保存到了暂存区后）：git diff —cached<br>3, 版本库中不同commit、分支的diff信息（使用git commit 将暂存区修改提交到了版本库）：git diff commit1 commit2 或 git diff branch1 branch2<br>4, 技巧：一般将要对比的分支/commitID名字放到第二个参数,这样对比起来比较直观。</p><p>1）基本操作</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">diff</span> branch1 branch2 --stat //--stat参数,显示两分支简单<span class="built_in">diff</span>信息</span><br><span class="line">git <span class="built_in">diff</span> branch1 branch2 //显示两分支详细的<span class="built_in">diff</span>信息</span><br><span class="line">git <span class="built_in">diff</span> branch1 branch2 path //显示两分支指定路径下文件的详细<span class="built_in">diff</span>信息</span><br><span class="line">git <span class="built_in">diff</span> branch1 branch2 <span class="built_in">file_name</span>(带路径) //显示两分支指定文件的详细<span class="built_in">diff</span>信息</span><br></pre></td></tr></table></figure><p>注：这里的分支可以是本地的,也可以是远程的（git diff branch1 origin/branch2）</p><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><p>Git 标签（Tag）是用于在代码库中标记某个特定提交（commit）的方式。标签通常用于标识发布版本或重要的里程碑，以便于追踪和管理代码库的发展历史。下面详细介绍了 Git 中标签的常用操作：</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>创建一个轻量级标签：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">tag_name</span></span><br></pre></td></tr></table></figure><h3 id="创建一个带有注释的标签"><a href="#创建一个带有注释的标签" class="headerlink" title="创建一个带有注释的标签"></a>创建一个带有注释的标签</h3><p>个人最喜欢的方式创建标签：<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-a</span> tag_name -m <span class="string">&quot;Tag message&quot;</span></span><br></pre></td></tr></table></figure></p><h3 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h3><p>查看所有标签：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span></span><br></pre></td></tr></table></figure><h3 id="查看特定标签的详细信息"><a href="#查看特定标签的详细信息" class="headerlink" title="查看特定标签的详细信息"></a>查看特定标签的详细信息</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">show</span> tag_name</span><br></pre></td></tr></table></figure><h3 id="推送标签到远程仓库"><a href="#推送标签到远程仓库" class="headerlink" title="推送标签到远程仓库"></a>推送标签到远程仓库</h3><p>推送单个标签：</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> tag_name</span><br></pre></td></tr></table></figure><p>推送所有标签：</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> --tags</span><br></pre></td></tr></table></figure><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><h4 id="删除本地标签"><a href="#删除本地标签" class="headerlink" title="删除本地标签"></a>删除本地标签</h4><p>删除一个本地标签：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-d</span> tag_name</span><br></pre></td></tr></table></figure><h4 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h4><p>首先删除本地标签：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-d</span> tag_name</span><br></pre></td></tr></table></figure><p>然后删除远程标签：</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">git push origin <span class="symbol">:refs/tags/tag_name</span></span><br></pre></td></tr></table></figure><h3 id="切换到标签对应的提交"><a href="#切换到标签对应的提交" class="headerlink" title="切换到标签对应的提交"></a>切换到标签对应的提交</h3><p>创建一个新分支并切换到标签对应的提交：</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git</span> checkout -<span class="keyword">b</span> new_branch_name tag_name</span><br></pre></td></tr></table></figure><h3 id="检出标签的特定文件版本"><a href="#检出标签的特定文件版本" class="headerlink" title="检出标签的特定文件版本"></a>检出标签的特定文件版本</h3><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git checkout tag_name <span class="comment">-- file_path</span></span><br></pre></td></tr></table></figure><h3 id="在标签上创建新分支"><a href="#在标签上创建新分支" class="headerlink" title="在标签上创建新分支"></a>在标签上创建新分支</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git</span> checkout -<span class="keyword">b</span> new_branch_name tag_name</span><br></pre></td></tr></table></figure><p>列出与标签相关的提交：</p><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">log</span> <span class="keyword">tag_name</span>^..<span class="keyword">tag_name</span></span><br></pre></td></tr></table></figure><h3 id="对以前提交的信息打标签"><a href="#对以前提交的信息打标签" class="headerlink" title="对以前提交的信息打标签"></a>对以前提交的信息打标签</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--pretty=oneline</span></span><br></pre></td></tr></table></figure><p>上面这条命令显示了全部的commit id信息，简短点的commit 信息，看下面的命令:</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--pretty=oneline --abbrev-commit</span></span><br></pre></td></tr></table></figure><h1 id="代码冲突检测"><a href="#代码冲突检测" class="headerlink" title="代码冲突检测"></a>代码冲突检测</h1><p>在多人同时修改同一个文件或者同一个代码库时，就可能出现冲突。如果有人在本地已经修改了某个文件并提交了，但另一个人在远程也修改了这个文件并提交了，这时候就会出现冲突。</p><h2 id="检查是否存在冲突"><a href="#检查是否存在冲突" class="headerlink" title="检查是否存在冲突"></a>检查是否存在冲突</h2><p>通过以下命令检查当前文件是否存在冲突：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git status</span></span><br></pre></td></tr></table></figure><p>如果出现类似如下输出，则说明当前文件存在冲突：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">On branch <span class="keyword">master</span></span><br><span class="line"><span class="title">You</span> have unmerged paths.</span><br><span class="line">(fix conflicts run <span class="string">&quot;git commit&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="查看冲突文件"><a href="#查看冲突文件" class="headerlink" title="查看冲突文件"></a>查看冲突文件</h2><p>在检查出存在冲突后，我们需要查看具体哪些文件存在冲突，可以通过以下命令查看：</p><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">git diff</span> <span class="literal">--</span><span class="comment">name</span><span class="literal">-</span><span class="comment">only</span> <span class="literal">--</span><span class="comment">diff</span><span class="literal">-</span><span class="comment">filter=U</span></span><br></pre></td></tr></table></figure><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="无法推送"><a href="#无法推送" class="headerlink" title="无法推送"></a>无法推送</h2><p> 已明确账号密码输入无误,在 <code>git bash</code> 里面无法推送自己的代码,其报错如下：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Logon failed, use ctrl+c <span class="keyword">to</span> cancel basic credential prompt.</span><br><span class="line">remote: Support <span class="keyword">for</span> <span class="keyword">password</span> authentication was removed <span class="keyword">on</span> August <span class="number">13</span>, <span class="number">2021.</span> Please use a personal <span class="keyword">access</span> token <span class="keyword">instead</span>.</span><br></pre></td></tr></table></figure><p>有一种可能,由于git 升级,执行 <code>git update-git-for-windows</code>, 更新后推送报了一个新的错误</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">SSL certificate problem: unable <span class="keyword">to</span> <span class="keyword">get</span> <span class="keyword">local</span> issuer certificate</span><br></pre></td></tr></table></figure><p>解决方式,输入如下指令</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="提交中文字符乱码问题"><a href="#提交中文字符乱码问题" class="headerlink" title="提交中文字符乱码问题"></a>提交中文字符乱码问题</h2><p>这个问题主要是在Windows下使用<code>git bash</code>时候遇到的, 从以下几个步骤可以解决这个问题</p><p>1, 确认本地git配置</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">config</span> <span class="comment">--global -l</span></span><br></pre></td></tr></table></figure><p>看输出的结果里面有没有包含下面两条信息</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">core.quotepath</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">i18n.commitencoding</span>=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>2, 若不存在,输入如下指令</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">config</span> <span class="comment">--global core.quotepath false</span></span><br><span class="line">git <span class="built_in">config</span> <span class="comment">--global i18n.commitencoding UTF-8</span></span><br></pre></td></tr></table></figure><p>3, 将文件字符集设置为UTF-8,可以保证中文字符在git提交后不会乱码。</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">config</span> <span class="comment">--global core.autocrlf true</span></span><br><span class="line">git <span class="built_in">config</span> <span class="comment">--global core.safecrlf true</span></span><br><span class="line">git <span class="built_in">config</span> <span class="comment">--global core.quotepath false</span></span><br><span class="line">git <span class="built_in">config</span> <span class="comment">--global i18n.commitencoding UTF-8</span></span><br><span class="line">git <span class="built_in">config</span> <span class="comment">--global i18n.logoutputencoding UTF-8</span></span><br></pre></td></tr></table></figure><h1 id="fatal-LF-would-be-replace-by-CRLF"><a href="#fatal-LF-would-be-replace-by-CRLF" class="headerlink" title="fatal: LF would be replace by CRLF"></a>fatal: LF would be replace by CRLF</h1><p>这个问题会导致往仓库推的时候推不上去，解决办法如下，在shell中输入如下指令</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">git config --local core.<span class="built_in">auto</span>crlf <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>可根据自己的需要，将<code>local</code>替换成<code>global</code>;</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]《GitHub 入门》</p><p>[2] <a href="https://www.web3.xin/code/3055.html">web3</a></p><p>[3] <a href="https://www.cnblogs.com/yanzige/p/9810333.html">GIT使用log命令显示中文乱码</a></p><p>[4] <a href="https://pythonjishu.com/egsjerugrbprzdt/">Python 技术站</a></p><p>[5] <a href="https://blog.csdn.net/liuxiao723846/article/details/109689069">git diff</a></p><p>[6] chatGPT 的回答</p>]]></content>
      
      
      <categories>
          
          <category> GIT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> Git </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bode 图</title>
      <link href="/2021/02/25/archived_bode/"/>
      <url>/2021/02/25/archived_bode/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#简介">简介</a></li><li><a href="#波德图手绘的规则">波德图手绘的规则</a><ul><li><a href="#直线近似的增益图">直线近似的增益图</a></li><li><a href="#在系统稳定性的应用">在系统稳定性的应用</a></li></ul></li><li><a href="#系统的稳定性及稳态裕度">系统的稳定性及稳态裕度</a></li><li><a href="#参考内容">参考内容</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对身为控制小白的我,由于工作的需要,不得不学经典控制理论里面的东西,进而对控制系统进行相关的设计,心里一直有个苦恼的地方就是怎么看懂Bode图,以及如何根据经典控制理论来设计控制器。同时也很想了解Bode图的绘制过程,以及如何从图中获取有用的信息,将从网络以及书本里获取到的有助于自己理解的内容,记录如下。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>伯德图是线性非时变系统的传递函数对频率的半对数座标图,其横轴频率以对数尺度表示,利用波德图可以看出系统的频率响应。</p><p>波德图幅频图的频率用对数尺度表示,增益部分一般都用功率的分贝值来表示,也就是将增益取对数后再乘以20。由于增益用对数来表示,因此一传递函数乘以一常数,在波德增益图只需将图形的纵向移动即可,二传递函数的相乘,在波德幅频图就变成图形的相加。幅频图纵轴0分贝以下具有正增益裕度、属稳定区,反之属不稳定区：</p><div align="center"> <img src="/img/postImg/4_bode/equation/loga_cdot_b.png" width="30%" height="30%"> </div><p>伯德图相频图的频率也用对数尺度表示,而相位部分的单位一般会使用度。配合波德相频图可以估算一信号进入系统后,输出信号及原始信号的比例关系及相位。例如一个A*sin(ω*t) 的信号进入系统后<strong>振幅变原来的k倍</strong>,<strong>相位落后原信号Φ</strong>,则其输出信号则为(A*k) sin(ω*t − Φ),其中的k和Φ都是<a href="https://zh.wikipedia.org/wiki/頻率">频率</a>的函数。<strong>相频图纵轴-180度以上具有正相位裕度、属稳定区,反之属不稳定区</strong></p><p>开环传递函数的典型环节分解可将开环系统表示为若干个典型环节的串联形式</p><div align="center"> <img src="/img/postImg/4_bode/equation/开环传递函数串联形式.png" width="20%" height="20%"> </div><p>设典型环节的频率特性为</p><div align="center"> <img src="/img/postImg/4_bode/equation/典型环节的频率特性.png" width="20%" height="20%"> </div><p>则系统开环频率特性</p><div align="center"> <img src="/img/postImg/4_bode/equation/系统开环频率特性.png" width="20%" height="20%"> </div><p>系统开环幅频特性和开环相频特性</p><div align="center"> <img src="/img/postImg/4_bode/equation/系统开环幅频特性和开环相频特性.png" width="20%" height="20%"> </div><p>系统开环对数幅频特性</p><div align="center"> <img src="/img/postImg/4_bode/equation/系统开环对数幅频特性.png" width="30%" height="30%"> </div><p>上面两个式子表明,系统开环频率特性表现为组成开环系统的典型环节频率特性的合成;而系统开环对数频率特性,则表现为典型环节对数频率特性叠加这一更为简单的形式。</p><p>若将系统的增益以复数表示,则复数增益取对数后的虚部即为相位,因此二传递函数的相乘,在波德相位图上也是图形的相加。若转换函数是有理函数,其零点及极点均为实数,则其波德图可以用几条渐近线的直线来近似,利用简单的规则即可以徒手绘制。若近似的波德图再修正每个截止频率时的增益值,则其近似值会更接近实际值。</p><h1 id="波德图手绘的规则"><a href="#波德图手绘的规则" class="headerlink" title="波德图手绘的规则"></a>波德图手绘的规则</h1><p>波德图的前提就是可以处理以下型式函数的对数值：</p><div align="center"> <img src="/img/postImg/4_bode/equation/伯德图绘制前提以及处理何种类型函数的对数值.png" width="20%" height="20%"> </div><p>上述函数的对数值可以转换为极点及零点对数的和：</p><div align="center"> <img src="/img/postImg/4_bode/equation/极点及零点对数和.png" width="30%" height="30%"> </div><p>在绘制波德相位图时直接使用了上述的概念。增益图的绘制时则是以此概念为基础,因为每个极点或零点其增益的对数均从0开始,而且其渐近线只有一个转折点,因此绘制时可以再作简化。</p><h2 id="直线近似的增益图"><a href="#直线近似的增益图" class="headerlink" title="直线近似的增益图"></a>直线近似的增益图</h2><p>波德图增益分贝值一般都利用<img src="/img/postImg/4_bode/equation/20_log_10_x.png" width="5%" height="5%"> 的公式。考虑以下的转换函数：</p><div align="center"> <img src="/img/postImg/4_bode/equation/转换函数的一般形式.png" width="20%" height="20%"> </div><p>其中xn,yn 是常数, s=j<img src="/img/postImg/mathSym/omega.png" width="1%" height="1%"> ,an,bn&gt;0, 而H是转换函数。</p><p>1)在每个对应<img src="/img/postImg/mathSym/omega.png" width="1%" height="1%"> = xn (零点)的位置,将直线的斜率增加20an/dB 十倍频</p><p>2)在每个对应<img src="/img/postImg/mathSym/omega.png" width="1%" height="1%"> = yn (极点)的位置,将直线的斜率减少20bn/dB 十倍频</p><p>3)图在起始点时的增益值,可以依照图中的角频率下限,计算其对应的 |H(j<img src="/img/postImg/mathSym/omega.png" width="1%" height="1%">)| </p><p>4)图在起始点时的斜率则依照有多少零点及极点低于角频率下限,再依上述二个方式计算斜率,若所有点及极点均高于角频率下限,起始点时的斜率为零。</p><h2 id="在系统稳定性的应用"><a href="#在系统稳定性的应用" class="headerlink" title="在系统稳定性的应用"></a>在系统稳定性的应用</h2><p>波德图可用来计算负反馈系统的增益裕度(gain margin)及相位裕度,进而确认系统的稳定性。先定义以下的符号：</p><div align="center"> <img src="/img/postImg/4_bode/equation/A_FB.png" width="20%" height="20%"> </div><p>其中, A<em>{FB} 是考虑反馈时的放大器增益(闭环增益),<img src="/img/postImg/mathSym/beta.png" width="1%" height="1%"> 是反馈系数, A</em>{OL} 是不考虑反馈时的放大器增益(开环增益)</p><p>在开环增益 A<em>{OL}远大于1时,闭环增益A</em>{FB} 可以用以下方式近似</p><div align="center"> <img src="/img/postImg/4_bode/equation/闭环增益近似值.png" width="20%" height="20%"> </div><p>在开环增益 A<em>{OL} 远小于1时,闭环增益 A</em>{FB} 可以用以下方式近似</p><div align="center"> <img src="/img/postImg/4_bode/equation/开环增益远小于1下的闭环增益近似.png" width="20%" height="20%"> </div><p>增益 A_{OL} 是频率的复变函数,有大小及相位。</p><p>上述的式子中,若<img src="/img/postImg/mathSym/beta.png" width="1%" height="1%"> A_{OL} 乘积=−1时,可能会出现增益无穷大(即为不稳定)的情形。(若用大小和相位来表示,此时<em>A</em>的大小为1,相位为-180度,此条件即称为巴克豪森稳定性准则。配合波德图,不但可以判断系统是否稳定,也可以判断系统接近以上不稳定条件的程度。</p><h1 id="系统的稳定性及稳态裕度"><a href="#系统的稳定性及稳态裕度" class="headerlink" title="系统的稳定性及稳态裕度"></a>系统的稳定性及稳态裕度</h1><p>稳定是控制系统的重要性能, 也是系统能够正常运行的首要条件。对于设计人员来说, 花费大量精力的重点在于测量系统有多稳定, 或者准确地说在于测量系统所拥有的稳定性裕度有多大。无论是在工程应用中, 还是在理论研究上, 这里推荐大家使用相位裕度 (Phase Margin, PM) 和增益裕度 (Gain Margin, GM) 来作为系统稳定程度的度量。 这是因为： </p><p>① PM 和 GM 是系统稳定性最直观的量度； </p><p>② 开环设计法是数字的, 适合于计算机； </p><p>③ 这种方法不需要对控制系统进行任何的简化性假设。</p><p>如果控制系统结构如下图所示,断开反馈回路, 得到该系统开环传递函数的对数频率特性曲线如图右所示,图中, 相位裕度 (PM) (通常也称为相角裕度) 定义为 180°加开环幅相曲线幅值为 1 时的相位：</p><div align="center"> <img src="/img/postImg/4_bode/equation/相位裕度.png" width="20%" height="20%"> </div><p>式中 ωc———系统的截止角频率。</p><p>增益裕度 (GM, 通常也称为幅值裕度) 定义为幅相曲线上, 相位为 - 180°时对应幅值的倒数：</p><div align="center"> <img src="/img/postImg/4_bode/equation/增益裕度.png" width="20%" height="20%"> </div><p>式中 ωg———相角交界角频率。 通常幅值裕度用分贝值 dB 表示, 上式可修改写为：</p><div align="center"> <img src="/img/postImg/4_bode/equation/增益裕度的常见形式.png" width="30%" height="30%"> </div><p>虽然目标是测量 PM和 GM的值,但是确定这两个量度的期望值需要判断。其原因之一是裕度大小随应用要求的变化而变化。例如,有些必须跟随指令信号,如阶跃指令信号的场合,除了极稳定的系统外都会产生超调。相对于响应变化柔和的指令信号来说,这样的应用需要更高的稳定裕度。此外,与其他应用相比,有些应用可以承受更大的超调量。最后,对于同样的响应,有些控制方法需要比其他方法更大的相位裕度或者增益裕度。例如,对于一个阶跃响应来说, 要获得相同的超调量, PI 调节器需要一定的相位裕度, 而对于 PID 调节器来说, 较小的相位裕度就可能消除所有超调。 经验表明, 增益裕度 (GM) 应为 10 ～ 25dB, 而相位裕度 (PM) 应为 35° ～ 80°, 这取决于具体应用及控制器类型。 一般情况下, 幅值裕度越大越好, 同样, 相角裕度也是越大越好。</p><h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p>[1] <a href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E5%BE%B7%E5%9C%96">维基百科——伯德图</a></p><p>[2] 《交流伺服系统设计指南》——孙宇等编著</p>]]></content>
      
      
      <categories>
          
          <category> CONTROL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> control </tag>
            
            <tag> bode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2021/02/25/archived_docker/"/>
      <url>/2021/02/25/archived_docker/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#初识">初识</a><ul><li><a href="#镜像">镜像</a></li><li><a href="#容器">容器</a></li><li><a href="#仓库">仓库</a></li></ul></li><li><a href="#安装ubuntu-和-debian">安装Ubuntu 和 Debian</a></li><li><a href="#使用-docker-镜像">使用 Docker 镜像</a><ul><li><a href="#运行">运行</a></li><li><a href="#列出镜像">列出镜像</a><ul><li><a href="#列出部分镜像">列出部分镜像</a></li></ul></li></ul></li><li><a href="#利用-commit-理解镜像构成">利用 commit 理解镜像构成</a></li><li><a href="#运行windows-下">运行(windows 下)</a></li><li><a href="#保存修改后的镜像">保存修改后的镜像</a></li><li><a href="#使用-dockerfile-定制镜像">使用 Dockerfile 定制镜像</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不想换个电脑重新配置下参数,这个配置可以说是相当的繁琐,比如说各种软件的配置,模块的兼容等等,以及交互式的界面对于提高自己的编程水平感觉并不高,因此有时需要一个无界面的命令行,强迫自己去使用纯命令行,简而言之,就是自虐。。。。。后来在学习过程中发现了个有意思的工具,没错,就是本文打算入坑的一个虚拟机。是一个属于<strong>Linux 容器的一种封装</strong>。不同操作系统的安装不太一样,这个过程比较简单,可以自行搜索。由于 Docker 确保了执行环境的一致性,使得应用的迁移更加容易。在很多平台上运行,无论是物理机、虚拟机、公有云、私有云,甚至是笔记本,其运行结果是一致的,不用担心运行环境的变化导致应用无法正常运行的情况,就像后来为什么喜欢上了overleaf那样。。。。。,另外一点,这种虚拟机的性能,接近于原生,这就很爽了。。。</p><h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>Docker 包括三个基本概念,镜像(<code>Image</code>) 容器(<code>Container</code>) 仓库(<code>Repository</code>)</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>Docker 镜像是一个特殊的文件系统,除了提供容器运行时所需的程序、库、资 源、配置等文件外,还包含了一些为运行时准备的一些配置参数(如匿名卷、环境 变量、用户等)。镜像不包含任何动态数据,其内容在构建之后也不会被改变。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像(Image)和容器(Container)的关系,就像是面向对象程序设计中的类和实例 一样,镜像是静态的定义,容器是镜像运行时的实体。容器可以被 创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程,但与直接在宿主执行的进程不同,容器进程运行于属于自己的<code>独立的</code>命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、 自己的进程空间,甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环 境里,使用起来,就好像是在一个独立于宿主的系统下操作一样。这种特性使得容 器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性,很多人初学 Docker 时常常会把容器和虚拟机搞混。容器存储层的生存周期和容器一样,容器消亡时,容器存储层也随之消亡。因此, 任何保存于容器存储层的信息都会随容器删除而丢失。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>一个 Docker Registry 中可以包含多个仓库(Repository)；每个仓库可以包含多 个标签(Tag)；每个标签对应一个镜像。通常,一个仓库会包含同一个软件不同版本的镜像,而标签就常用于对应该软件的 各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版 本的镜像。如果不给出标签,将以 latest 作为默认标签。仓库名经常以 两段式路径 形式出现,比如 jwilder/nginx-proxy ,前者往往意 味着 Docker Registry 多用户环境下的用户名,后者则往往是对应的软件名。但这 并非绝对,取决于所使用的具体 Docker Registry 的软件或服务。</p><h1 id="安装Ubuntu-和-Debian"><a href="#安装Ubuntu-和-Debian" class="headerlink" title="安装Ubuntu 和 Debian"></a>安装Ubuntu 和 Debian</h1><p>官方为了简化安装流程,提供了一套安装脚本,Ubuntu 和 Debian 系统可 以使用这套脚本安装：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">curl -sSL https://<span class="built_in">get</span>.docker.<span class="keyword">com</span>/ | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>由于墙的原因,可能会存在安装不上的原因,可使用阿里云来进行安装</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">curl -sSL http://acs-public-mirror.oss-<span class="keyword">cn</span>-hangzhou.aliyuncs.<span class="keyword">com</span>/ docker-engine/internet | <span class="keyword">sh</span> -</span><br></pre></td></tr></table></figure><h1 id="使用-Docker-镜像"><a href="#使用-Docker-镜像" class="headerlink" title="使用 Docker 镜像"></a>使用 Docker 镜像</h1><p>Docker 运行容器前需要本地存在对应的镜像,如果镜像不存在本地,Docker 会从 镜像仓库下载(默认是 Docker Hub 公共注册服务器中的仓库)。</p><p>从 Docker Registry 获取镜像的命令是 <code>docker pull</code> 。其命令格式为：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry地址]<span class="tag">&lt;<span class="name">仓库名</span>&gt;</span>:<span class="tag">&lt;<span class="name">标签</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Docker Registry地址：地址的格式一般是 &lt;域名/IP&gt;[端口号]。默认地址是 Docker Hub。仓库名是两段式名称,既 &lt;用户名&gt;/&lt;软件名&gt; 。 对于 Docker Hub,如果不给出用户名,则默认为 library ,也就是官方镜像。</p><p>比如</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> pull ubuntu:<span class="number">14</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>有了镜像后,我们就可以以这个镜像为基础启动一个容器来运行。以上面的 ubuntu:14.04 为例,如果我们打算启动里面的 bash 并且进行交互式操作的话,可以执行下面的命令。</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> <span class="comment">--rm ubuntu:14.04 bash</span></span><br></pre></td></tr></table></figure><p><code>docker run</code> 就是运行容器的命令,-it ：这是两个参数,一个是-i：交互式操作,一个是 -t:终端。—rm ：这个参数是说容器退出后随之将其删除。默认情况下,为了排障需<br>求,退出的容器并不会立即删除,除非手动 docker rm 。</p><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>要想列出已经下载下来的镜像,可以使用<code>docker images</code>命令</p><h3 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h3><p>不加任何参数的情况下, docker images 会列出所有顶级镜像,但是有时候我们 只希望列出部分镜像。 docker images 有好几个参数可以帮助做到这个事情。 根据仓库名列出镜像</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker images ubuntu</span></span><br></pre></td></tr></table></figure><p>列出特定的某个镜像,也就是说指定仓库名和标签</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> images ubuntu:<span class="number">16</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure><h1 id="利用-commit-理解镜像构成"><a href="#利用-commit-理解镜像构成" class="headerlink" title="利用 commit 理解镜像构成"></a>利用 commit 理解镜像构成</h1><p>镜像是容器的基础,每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运 行的基础。在之前的例子中,我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求,而当这些镜像无法直接满足需求时,我们就需要定制这些镜像。镜像是多层存储,每一层是在前一层的基础上进行的修改；而容器同样也是多层存储,是在以镜像为基础层,在其基础上加一层作为容器运行时的存储层。</p><p>定制一个 Web 服务器为例子,来讲解镜像是如何构建的。</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> run --name webserver -d -p <span class="number">80</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure><p>这条命令会用 <code>nginx</code> 镜像启动一个容器,命名为 webserver ,并且映射了 80 端口,这样我们可以用浏览器去访问这个 nginx 服务器。</p><p>如果是在 Linux 本机运行的 Docker,或者如果使用的是 Docker for Mac、Docker for Windows,那么可以直接访问：<a href="http://localhost；如果使用的是">http://localhost；如果使用的是</a> Docker Toolbox,或者是在虚拟机、云服务器上安装的 Docker,则需要将 localhost 换为虚拟机地址或者实际云服务器地址。</p><p>当运行一个容器的时候(如果不使用卷的话),做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令,可以将容器的存储层保存下来成为镜像。换句话说,就是在原有镜像的基础上,再叠加上容器的存储层,并构成新的镜像。以后我们运行这个新镜像的时候,就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker commit [选项] <span class="tag">&lt;<span class="name">容器ID或容器名</span>&gt;</span> [<span class="tag">&lt;<span class="name">仓库名</span>&gt;</span>[:<span class="tag">&lt;<span class="name">标签</span>&gt;</span>]]</span><br></pre></td></tr></table></figure><p>可以在 docker images 中看到这个新定制的镜像,新的镜像定制好后,可以来运行这个镜像。</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> run --name web2 -d -p <span class="number">81</span>:<span class="number">80</span> nginx:v2</span><br></pre></td></tr></table></figure><p>这里命名为新的服务为 web2 ,并且映射到 81 端口。如果是 Docker for Mac/Windows 或 Linux 桌面的话,我们就可以直接访问 <a href="http://localhost:81">http://localhost:81</a> 看到结果,其内容应该和之前修改后的 webserver 一样。</p><p>除当前层外,之前的每一层都是不会发生改变的,换句话说,任何修改的结果仅仅是在当前层进行标记、添 加、修改,而不会改动上一层。如果使用 docker commit 制作镜像,以及后期修改的话,每一次修改都会让镜像更加臃肿一次,所删除的上一层的东西并不会丢失,会一直如影随形的跟着这个镜像,即使根本无法访问到。这会让镜像更加臃肿。</p><p>docker commit 命令除了学习之外,还有一些特殊的应用场合,比如被入侵后保存现场等。但是,不要使用 docker commit 定制镜像,定制行为应该使用 Dockerfile 来完成。</p><h1 id="运行-windows-下"><a href="#运行-windows-下" class="headerlink" title="运行(windows 下)"></a>运行(windows 下)</h1><p>如何在Windows下运行,可以首先使用docker images看看自己的镜像,然后在powershell里面输入类似的语法即可：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">docker run -it lsqy_ubuntu:laster <span class="comment">//bin/bash</span></span><br></pre></td></tr></table></figure><p>对于喜欢linux风格的,可以在git bash 下输入</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">winpty docker <span class="built_in">run</span> -<span class="keyword">it</span> lsqy_ubuntu:latest bash</span><br></pre></td></tr></table></figure><p>一开始也想通过powershell的方式,输入的,结果报了这样的错误<code>the input device is not a TTY.  If you are using mintty, try prefixing the comma</code></p><h1 id="保存修改后的镜像"><a href="#保存修改后的镜像" class="headerlink" title="保存修改后的镜像"></a>保存修改后的镜像</h1><p>一开始很费解,为什么在里面安装了一些软件后,比如配置好了一些环境变量,再次打开的时候,发现之前修改的都不存在了。可以将容器打包成镜像,需要指定要提交保存容器的ID,类似于</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> commit <span class="number">214</span>e52618d54 lsqyrobot/lsqy_ubuntu:latest</span><br></pre></td></tr></table></figure><p>这里的<code>214e52618d54</code>就是制定要提交保存的容器ID, 当然,从上面所说的 <code>利用 commit 理解镜像构成</code> 那部分内容,也容易理解为什么做了些修改后,再次重启就不复存在了,这当然有很多好处,比如自己在机器人上开发一些功能,开发后与开发前提升了哪些性能,当然是与开发前相比了,所以每次开机都会恢复成最初的状态,以便于对比和检查更新前后的差别,反复确保没有问题后,方可更新。</p><h1 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h1><p>从  <code>docker commit</code> 的学习可以了解到,镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作 的命令都写入一个脚本,用这个脚本来构建、定制镜像,那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。Dockerfile 是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,因此每一条指令的内容,就是描述该层应当如何构建。以 nginx 镜像为例,使用 Dockerfile 来定制。 在一个空白目录中,建立一个文本文件,并命名为 Dockerfile ：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> mynginx</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> mynginx</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> Dockerfile</span></span><br></pre></td></tr></table></figure><p>其内容为：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx <span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index .html</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]  <a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程——阮一峰</a></p><p>[2] 《docker 从入门到实践》—杨宝华等</p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三环控制系统</title>
      <link href="/2021/02/16/archived_threeLoopControl/"/>
      <url>/2021/02/16/archived_threeLoopControl/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#三闭环系统构成">三闭环系统构成</a></li><li><a href="#系统的基本研究内容">系统的基本研究内容</a><ul><li><a href="#典型系统">典型系统</a><ul><li><a href="#典型型系统">典型Ⅰ型系统</a></li><li><a href="#典型型系统-1">典型<strong>Ⅱ</strong>型系统</a></li></ul></li></ul></li><li><a href="#手动调整速度环增益和位置环增益">手动调整速度环增益和位置环增益</a></li><li><a href="#增益调整与机械刚性的关系">增益调整与机械刚性的关系</a><ul><li><a href="#提高机械刚性">提高机械刚性</a></li></ul></li><li><a href="#机器人关节带宽和测量">机器人关节带宽和测量</a><ul><li><a href="#如何影响带宽"><strong>如何影响带宽</strong></a></li><li><a href="#带宽的测量"><strong>带宽的测量</strong></a><ul><li><a href="#确定幅值"><strong>确定幅值</strong></a></li><li><a href="#32-生成扫频信号"><strong>3.2 生成扫频信号</strong></a></li><li><a href="#实验装置及数据整理"><strong>实验装置及数据整理</strong></a></li></ul></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前记录的一部分笔记里,有关于运动控制的简单说明,这部分的内容还是非常吸引自己的,于是就查阅了相关的书本资料,做进一步的学习,下面很多内容/笔记是出自于孙宇等人编著的《交流伺服系统设计指南》,里面的内容让人眼前一亮,会让人对经典控制理论产生极大的兴趣,非常值得去好好的学习下。内容仅作为学习使用,会穿插一些自己对内容的理解以及相关的代码演示等。</p><h1 id="三闭环系统构成"><a href="#三闭环系统构成" class="headerlink" title="三闭环系统构成"></a>三闭环系统构成</h1><p>高性能交流伺服控制系统通常具有位置反馈、 转速反馈和电流反馈的三闭环结构形式, 如图所示。 图中, 虚线框内表示电源、 电动机及编码器模型, 其中 APR 表示位置调节器, ASR 表示转速调节器, ACR 表示电流调节器。</p><div align="center"> <img src="/img/postImg/37_threeLoopControlSystem/threeLoopControl.png" width="80%" height="40%"> </div><p>三个环路调节器都由 P 和 I 组成, 虽然结构相似, 但是完成的功能却各自不同：</p><p>① 电流环 ACR 的作用是改造内核控制对象的传递函数, 提高系统的快速性； 及时抑制电流环内部的干扰； 限制最大电流, 使系统有足够大的加速度转矩, 并且保障系统安全运行。</p><p>② 速度环 ASR 的作用是增强系统抗负载扰动的能力； 抑制转速波动。 </p><p>③ 位置环 APR 的作用是保证系统静态准确度、 刚度和动态跟踪的性能； 它是反馈的主要通道。 </p><p>通常把电流环称为内环, 三个环的设计步骤由内到外, 即依次是电流环, 速度环和位置环。 针对各个闭环的具体作用和要求, 采取相应的控制策略。 首要考虑系统的稳定性, 此外, 系统的跟随性、 扰动性、 误差以及稳态裕度等性能也是考虑的基本内容。 </p><p>机械系统是指系统负载和负载与电动机连接的机械传动机构的总称。 通常假设电动机与机械系统的连接特性为理想化的刚性,如下图所示</p><div align="center"> <img src="/img/postImg/37_threeLoopControlSystem/oneMotorSim.png" width="60%" height="30%"> </div><p>系统转动惯量 J 即是电动机转动惯量 JM 与负载转动惯量 JL 之和由它建立的系统一般称为单惯性系统。实际上,机械传动连接特性并非理想化的刚性,它存在一定的柔性,如下图所示,由它建立的系统称为两惯性系统。在该物理模型中,连接特性具有柔性耦合特性,存在弹性常数 Ks ,它使得系统转动惯量 J 不再是电动机转动惯量 JM 与负载转动惯量 JL 之和。 更复杂的是,这种柔性耦合通常会在系统中引发机械振动,机械振动除了发出声学噪声形成噪声污染外,还会对机械传动装置造成严重的损害,影响其使用寿命。另外,甚至还会引发控制系统中的控制量振荡,使得闭环控制的稳定性以及可调整性受到制约。</p><div align="center"> <img src="/img/postImg/37_threeLoopControlSystem/oneMotorReal.png" width="60%" height="30%"> </div><p>由经验可以得出, 虽然三闭环控制策略是在单惯性系统物理模型下分析得出的, 但它同样适用于振动负载模型, 其结论对实际应用中的伺服控制系统同样是有效的。 因此主动式解决振动的方法多数也是在三闭环控制系统的基础上展开研究的。 调整伺服系统就是通过调整各个环路的增益与滤波以使伺服控制器匹配机械特性,从而达到减小振动、快速跟踪指令并且消除异常噪音的目的。</p><h1 id="系统的基本研究内容"><a href="#系统的基本研究内容" class="headerlink" title="系统的基本研究内容"></a>系统的基本研究内容</h1><p>稳定是控制系统的重要性能, 也是系统能够正常运行的首要条件。 在交流伺服控制系统设计中, 分析三闭环结构是否稳定并不重要, 因为工业中即使是临界稳定的系统也是没有用的。 对于设计人员来说, 花费大量精力的重点在于测量系统有多稳定, 或者准确地说在于测 量系统所拥有的稳定性裕度有多大。 无论是在工程应用中, 还是在理论研究上, 这里推荐大家使用<strong>相位裕度</strong> (Phase Margin,PM) 和<strong>增益裕度</strong> (Gain Margin, GM) 来作为系统稳定程度的度量。 这是因为： </p><p>① PM 和 GM 是系统稳定性最直观的量度； </p><p>② 开环设计法是数字的, 适合于计算机； </p><p>③ 这种方法不需要对控制系统进行任何的简化性假设。 </p><p>若统开环传递函数的对数频率特性曲线如下所示。图中,相位裕度(PM)(通常也称为相角裕度)定义为 180°加开环幅相曲线幅值为 1时的相位∶</p><div align="center"> <img src="https://latex.codecogs.com/png.latex?\gamma = 180^\circ + G(j\omega_c)H(j\omega_c)"/> </div><p>式中 <img src="https://latex.codecogs.com/png.latex?  \omega_c "/> 为系统的截止角频率。增益裕度 (GM, 通常也称为幅值裕度) 定义为幅相曲线上, 相位为 -180°时对应幅值的倒数：</p><div align="center"> <img src="https://latex.codecogs.com/png.latex?h=\frac{1}{|G(j\omega_g)H(j\omega_g)|}"/> </div><p>通常幅值裕度用分贝值 dB 表示, 将上面的式修改为 </p><div align="center"> <img src="https://latex.codecogs.com/png.latex?h=20lg\frac{1}{|G(j\omega_g)H(j\omega_g)|} = -20lg|G(j\omega_g)H(j\omega_g)|"/> </div><p>虽然目标是测量 PM和 GM的值,但是确定这两个量度的期望值需要判断。其原因之一是裕度大小随应用要求的变化而变化。例如,有些必须跟随指令信号,如阶跃指令信号的场合,除了极稳定的系统外都会产生超调。相对于响应变化柔和的指令信号来说,这样的应用需要更高的稳定裕度。此外,与其他应用相比,有些应用可以承受更大的超调量。最后,对于同样的响应,有些控制方法需要比其他方法更大的相位裕度或者增益裕度。例如,对于一个阶跃响应来说,要获得相同的超调量,PI 调节器需要一定的相位裕度,而对于PID 调节器来说,较小的相位裕度就可能消除所有超调。经验表明,增益裕度(GM)应为10～ 25dB,而相位裕度(PM)应为35°~80°,这取决于具体应用及控制器类型。一般情况下,幅值裕度越大越好,同样,相角裕度也是越大越好。由于增益穿越处及其附近的相位滞后降低了相位裕度, 于是在整个控制回路中的每个噪 声滤波器、 反馈装置以及功率变换器均带来了相位滞后, 每个相位滞后都侵蚀相位裕度, 没必要的相位滞后限制了调节器的最终性能。 因此, 一条最基本的控制法则是： 消除没必要的相位滞后。 </p><h2 id="典型系统"><a href="#典型系统" class="headerlink" title="典型系统"></a>典型系统</h2><p>一般来说, 系统的开环传递函数都可表示为</p><div align="center"> <img src="https://latex.codecogs.com/png.latex?W(s) = \frac{K(\tau_1s+1)(\tau_2s+1)}{s^r(T_1s+1)(T_2s+1)}"/> </div><p>式中,分子和分母上都可能含有复数零点和复数极点诸项。分母中的s’项表示系统在原点处有r重极点,或者说,系统含有r个积分环节。根据r=0,1,2,…不同值,分别称为0型、Ⅰ型、Ⅱ型、…系统。自动控制理论证明,0型系统在稳态时是有差的,而Ⅲ型和Ⅲ型以上的系统很难稳定。因此,通常为保证稳定性和一定的稳态准确度,多用I型和Ⅱ型系统。</p><h3 id="典型Ⅰ型系统"><a href="#典型Ⅰ型系统" class="headerlink" title="典型Ⅰ型系统"></a>典型Ⅰ型系统</h3><p>作为典型Ⅰ型系统, 其开环传递函数选择为</p><div align="center"> <img src="https://latex.codecogs.com/png.latex?W(s) = \frac{K}{s(Ts+1)}"/> </div><p>它的闭环系统结构如下所示,</p><div align="center"> <img src="/img/postImg/37_threeLoopControlSystem/req1.png" width="60%" height="30%"> </div><p> 图 b 表示它的开环对数频率特性。 选择它作为典型系统不仅因为其机构简单, 而且对数幅频特性的中频段以 - 20dB / dec 的斜率穿越零分贝线。 只要参数的选择能保证有足够的中频带宽度,系统就一定是稳定的, 且有足够的稳定裕量。 显然要做到这一点, 应有</p><div align="center"> <img src="https://latex.codecogs.com/png.latex?\begin{cases}\omega_c<\frac{1}{T}\\ arctan \omega_cT<45^\circ\end{cases}"/> </div><p>则相位稳定裕度有</p><div align="center"> <img src="https://latex.codecogs.com/png.latex?\gamma = 180^\circ - 90^\circ - arctan \omega_cT>45^\circ"/> </div><h3 id="典型Ⅱ型系统"><a href="#典型Ⅱ型系统" class="headerlink" title="典型Ⅱ型系统"></a>典型<strong>Ⅱ</strong>型系统</h3><p>在Ⅱ型系统中,选择一种最简单而稳定的机构作为典型的Ⅱ型系统,其开环传递函数为</p><div align="center"> <img src="https://latex.codecogs.com/png.latex?W(s) = \frac{K(\tau s + 1)}{s^2(Ts+1)}"/> </div><p>它的闭环系统结构和开环对数频率特性如图所示, </p><div align="center"> <img src="/img/postImg/37_threeLoopControlSystem/req2.png" width="60%" height="30%"> </div><p>其中频段也是以 - 20dB / dec 的斜率穿越零分贝线。由于分母中已经有s²,对应的相频特性是-180°,后面还有一个惯性环节(这是实际系统必定有的),如果在分子上不添加一个比例微分环节 <img src="https://latex.codecogs.com/png.latex? (\tau s+1)"/> ,就无法把相频特性抬到-180°线以上去,也就无法保证系统稳定。要实现图b这样的特性,显然应有</p><div align="center"> <img src="https://latex.codecogs.com/png.latex?\begin{cases}\frac{1}{\tau}<\omega_c<\frac{1}{T}\\ \tau>T\end{cases}"/> </div><p>则相位稳定裕度为</p><div align="center"> <img src="https://latex.codecogs.com/png.latex?\gamma = arctan \omega_c \tau - arctan \omega_cT"/> </div><p>由上式可得到,<img src="https://latex.codecogs.com/png.latex?\tau"/> 比T大得越多,则稳定裕度越大。</p><h1 id="手动调整速度环增益和位置环增益"><a href="#手动调整速度环增益和位置环增益" class="headerlink" title="手动调整速度环增益和位置环增益"></a>手动调整速度环增益和位置环增益</h1><p>这部分的内容,松下的伺服驱动器手册说的是非常的详细的,结合着自己查阅相关驱动器手册,对其进行一点归纳。</p><p> 伺服驱动器首要的性能参数调整有三个：<strong>1.速度环增益；2.速度环积分时间常数;3.位置环增益</strong>。</p><h1 id="增益调整与机械刚性的关系"><a href="#增益调整与机械刚性的关系" class="headerlink" title="增益调整与机械刚性的关系"></a>增益调整与机械刚性的关系</h1><h2 id="提高机械刚性"><a href="#提高机械刚性" class="headerlink" title="提高机械刚性"></a>提高机械刚性</h2><p>1,应将机械牢固的置于地基上,使之不产生晃动。</p><p>2,应使用刚性高的伺服联轴器。</p><p>3, 使用宽幅的同步带。此外,张力应在电机容许轴向的过负载范围内。</p><p>4, 使用齿隙小的齿轮。机械部相关的固有振动 (共振频率) 会极大影响伺服机械的增益调整。共振频率低的机械 (=机械刚性低) ,伺服相关的响应性不可以设定过高。</p><h1 id="机器人关节带宽和测量"><a href="#机器人关节带宽和测量" class="headerlink" title="机器人关节带宽和测量"></a><a href="https://zhuanlan.zhihu.com/p/493958760">机器人关节带宽和测量</a></h1><p>文章写的很好，就直接搬运，下面为搬运的内容；</p><p>电机的伺服驱动器通常包括三种控制环——位置环、速度环和电流环。虽然每种控制环的目的是控制电机性能的不同方面，但它们都有一个共同的参数：带宽。在伺服驱动器中，带宽定义为闭环频率响应幅度大于 -3dB 的频率范围。此时，输出增益约为幅值的70.7%，输出功率等于输入功率的50%。定性地讲，系统的带宽可以衡量它对不断变化的输入命令的响应速度，因此对机器人的控制性能至关重要。</p><p>在协作机械臂和腿足式机器人中，位置带宽和力矩带宽已经成为衡量其伺服关节性能的重要指标：</p><ul><li><p>位置带宽：描述执行器可以有效跟踪期望轨迹的最大频率，单位Hz，通常以峰值最大速度为指标来评价。</p></li><li><p>力矩带宽：描述执行器可以有效跟踪期望力矩的最大频率，单位Hz，通常以峰值最大扭矩为指标来评价。</p></li></ul><p>一些典型的力控关节带宽指标如下表所示。</p><div class="table-container"><table><thead><tr><th>关节</th><th>力矩带宽 （Hz）</th><th>测试负载 (Nm)</th><th>力检测方式</th></tr></thead><tbody><tr><td>ETH ANYdrive [1]</td><td>＞60</td><td>1 Nm</td><td>SEA</td></tr><tr><td>iit WALK-MAN actuator [2]</td><td>14.24</td><td>35 Nm</td><td>SEA</td></tr><tr><td>iit WALK-MAN actuator [2]</td><td>28.05</td><td>35 Nm</td><td>Torque sensor</td></tr><tr><td>Blue Module [3]</td><td>13.8</td><td>10 Nm</td><td>QDD+电流检测</td></tr></tbody></table></div><h2 id="如何影响带宽"><a href="#如何影响带宽" class="headerlink" title="如何影响带宽"></a><strong>如何影响带宽</strong></h2><p>关节都可以<strong>近似</strong>看成一个二阶质量-弹簧-阻尼系统，因此这三者会对系统力矩带宽产生影响。下面是我以<strong>JTS-based</strong>关节的闭环传递函数为例，分析这三个参数对力矩带宽影响的仿真结果。</p><ul><li><strong>关节整体刚度</strong>：刚度越高，带宽越高</li><li><strong>传动系统惯量：</strong>惯量越小，带宽越高</li><li><strong>负载端阻尼：</strong>阻尼越大，带宽越高</li></ul><p>由于传动系统惯量和负载端阻尼很难在设计关节时人为设定，因此大多数工作都是从关节刚度入手来改变力矩带宽。</p><h2 id="带宽的测量"><a href="#带宽的测量" class="headerlink" title="带宽的测量"></a><strong>带宽的测量</strong></h2><h3 id="确定幅值"><a href="#确定幅值" class="headerlink" title="确定幅值"></a><strong>确定幅值</strong></h3><p>由于力矩带宽的具体大小由关节输出端负载决定，因此在测量时需要根据你的期望力矩幅值来测量相应带宽。</p><h3 id="3-2-生成扫频信号"><a href="#3-2-生成扫频信号" class="headerlink" title="3.2 生成扫频信号"></a><strong>3.2 生成扫频信号</strong></h3><p>实验时需要根据实际经验大致定义关节力矩带宽的范围，比如0-60Hz，然后在规定时间内给控制器输入频率随时间变化的力矩信号。下面代码是以Matlab语言为例，在0-10s内生成0-60Hz，幅值为A的信号，具体使用时转换为相应的控制器程序语言写入控制器即可</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 使用数学函数式生成啁啾信号</span></span><br><span class="line">fs = <span class="number">1000</span>;              <span class="comment">% 控制器采样频率，1KHz</span></span><br><span class="line">f_ini = <span class="number">0</span>;              <span class="comment">% 初始频率,单位Hz</span></span><br><span class="line">f_fin = <span class="number">60</span>;             <span class="comment">% 终止频率,单位Hz</span></span><br><span class="line">dT = <span class="number">10</span>;                <span class="comment">% 采样周期,单位s</span></span><br><span class="line">t1= <span class="number">0</span>:<span class="number">1</span>/fs:dT;          <span class="comment">% 采样间隔</span></span><br><span class="line">K= A*(f_fin-f_ini)/dT;  <span class="comment">% 频率线性增长率, A为信号幅值</span></span><br><span class="line">track = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*(f_ini.*t1+<span class="number">0.5</span>.*K.*t1.*t1));</span><br></pre></td></tr></table></figure><p>Matlab有自带的chirp函数可以生成余弦扫频信号，但是无法写入控制器，所以可以把chirp函数当作验证工具来来验证你的扫频信号。</p><h3 id="实验装置及数据整理"><a href="#实验装置及数据整理" class="headerlink" title="实验装置及数据整理"></a><strong>实验装置及数据整理</strong></h3><p>1）实验开始前，需要通过机械装置锁住关节输出端；</p><p>2）实验时，关节工作在力矩模式（closed-loop），力矩环输入命令为扫频信号；</p><p>3）实验过程中实时记录当前信号频率和对应力矩幅值；</p><p>4）最后根据数据画bode图，找出-3dB对应的频率点，即为关节力矩带宽的截止频率。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] 松下驱动器手册</p><p>[2] <a href="https://zhuanlan.zhihu.com/p/493958760">机器人关节带宽的理解和测量</a></p>]]></content>
      
      
      <categories>
          
          <category> ROBOTICS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> control </tag>
            
            <tag> motor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年总结与展望</title>
      <link href="/2021/01/27/archived_2020_summary_2021_plan/"/>
      <url>/2021/01/27/archived_2020_summary_2021_plan/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#回首">回首</a><ul><li><a href="#毕业前六个月">毕业前六个月</a></li><li><a href="#总结">总结</a></li><li><a href="#毕业后六个月">毕业后六个月</a></li><li><a href="#总结-1">总结</a></li></ul></li><li><a href="#展望">展望</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看了<a href="https://lixuan.xyz/blog/2020-12-31/2435.html">宣哥</a>的2020年年终总结,又想起了几年前经常逛博客的情景,看看自己写或者是记录下来的内容,难免唏嘘。总的来说失落比收获要多得多,是出自于精神上的倦怠吧,总以事多搪塞过去,笔记也不成体系,怕是长期以往,应文正所言,以一惰字致败。</p><h1 id="回首"><a href="#回首" class="headerlink" title="回首"></a>回首</h1><h2 id="毕业前六个月"><a href="#毕业前六个月" class="headerlink" title="毕业前六个月"></a>毕业前六个月</h2><p>1, 2020年初的时候,还在EFORT实习(上海),受疫情影响,在家办公,在家时的懒惰被无限放大,大多数事情都是在深夜完成的。实习结束后(三月初),着手自己毕业论文的编写,最后写的也是非常的糟糕,临近交论文前十天不到才完成的初稿,也是压力带来的动力吧。</p><p>2, 在四月初成为第一批到学校的人,那时学校人非常的少,很多时间只身一人在实验室内,多少感受到了些苍凉,那时论文已经提交,一个人在实验室里看看书,深入学习了MATLAB/GUI,最后用纯M文件写了毕业答辩用于展示的GUI,了解了不少关于设计以及其他有意思的内容。</p><p>3,朋友陆续回来后,就热闹了许多,少不了喝酒的日子,答辩后几乎每天都在豪饮,畅谈心事与向好友告别。最后的最后,将心事述衷,已无遗憾可言。曾因性格原因伤害过人,代价太大,太大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽是对2020年的回首,但更想做一个总结,知道三年的时光过得很快,也知道这来之不易的学习生活,虽说不上辛苦,但多少有些对未来的生活充满迷茫与忧虑。有过把酒言欢,有过孤寂,有过冲动,有过。。。。。不枉三年！</p><h2 id="毕业后六个月"><a href="#毕业后六个月" class="headerlink" title="毕业后六个月"></a>毕业后六个月</h2><p>1, 刚进入EFORT,认识了很多有趣的小伙伴,也难忘在制造部拧螺丝以及在芜湖期间天天健身的日子(虽然冬天又给吃回来了)。</p><p>2, 来到了上海,学会了一个人的生活,也是自己想要的生活,会做饭了,也会简单的剪辑了,对于生活,有了更多的了解,也逐渐的知道各种蔬菜以及肉食品的价格了,开始简单的学做烘焙了。</p><p>3, 当然,最最重要的,也是最最不可思议的,是和最想在一起的人,在一起了,让我至今,仍然感觉不可思议,仿佛在梦境一般,会好好的努力,因为你,而变成一个有价值的人。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>人生有时就是那么的不可思议,当初感觉不可能的事情,都慢慢的变成了现实,这一路上始终有幸运相伴,你所承受过的孤独,都会以另一种方式回报,苦与甜本是同义词,就像舍与得一般。知道自己的无知,以便轻装上阵；将往事串起来,你看,那些曾以为毫不相关的事,真的毫无关联吗？命运的错综复杂,却又如此直白,仿佛冥冥中自有注定。</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>先挖个坑,希望能在2021年,能实现以下十件事情：</p><p>1,带上心爱的姑娘,去她想去的地方,哪怕是未知的远方。</p><p>2,非常熟悉LaTeX类文件的编写,可以独立的自定义想要的样式。</p><p>3,对程序算法以及机器人运动控制算法以及伺服驱动器有更深入的了解与实际的应用。</p><p>4,希望能将机器人的轨迹跟踪精度,做到国内最好(不考虑关节变形等机械影响)。</p><p>5,对ROS的使用,可以做到相对熟悉的程度。</p><p>6,进一步进阶VIM。</p><p>7,对自己的网页,进行进一步的优化,改善现有加载速度慢,以及其他问题。</p><p>8,写至少6个有关技术的博客内容。</p><p>9,加强自己的数学以及力学分析等能力,对旋量代数和动力学控制有深入的理解。</p><p>10,通过合理的饮食以及健身,有较好的线条。</p>]]></content>
      
      
      <categories>
          
          <category> LIFE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> dots </tag>
            
            <tag> memory </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex 学习笔记(二)</title>
      <link href="/2021/01/17/archived_latex_2021/"/>
      <url>/2021/01/17/archived_latex_2021/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#图片及子图排版">图片及子图排版</a></li><li><a href="#与段落有关的距离">与段落有关的距离</a><ul><li><a href="#首行缩进">首行缩进</a></li><li><a href="#段落间距">段落间距</a></li><li><a href="#字母上加小箭头">字母上加小箭头</a></li></ul></li><li><a href="#listings-宏包使用说明">listings 宏包使用说明</a><ul><li><a href="#预设">预设</a></li><li><a href="#环境参数">环境参数</a></li><li><a href="#框架">框架</a></li><li><a href="#背景颜色">背景颜色</a></li><li><a href="#更多的指令">更多的指令</a></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>距离上次记录LaTex已经有好长一段时间了,大概有大半年的时间都没有更新,而上一次的记录的内容,大多数是出自于自己的需要,确实,想把技能变成肌肉记忆,还是得需要长时间的去练习的,后面会给出一些实用的东西,经常用,自然而然的就知道怎么回事了。这次做笔记,就事无巨细了,基础的还是很重要的,毕竟是给自己看的,不必那么多奇技淫巧。</p><h1 id="图片及子图排版"><a href="#图片及子图排版" class="headerlink" title="图片及子图排版"></a>图片及子图排版</h1><p>在学生时代写论文的时候,很多图都是通过matlab绘制的,而matlab导出的图最清晰地就属eps格式了,这里感兴趣的可以去了解下矢量图与位图,这里就不做阐述了,但是对于日常的记录而言,其实png或者其他位图都是可以满足阅读要求的,而在写论文的时候,会经常使用到多个子图的排版问题,这里就简要的记录下,因为实现的方式太多了,</p><p>graphicx 提供了一组控制命令,其中最常用的是插图命令如下(以eps为例,假设在文件夹imgs下的图片名字为your.eps)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">includegraphics[opts]&#123;imgs/your.eps&#125;</span><br></pre></td></tr></table></figure><p>下表为常用选项(opts)：</p><table id='hor-zebra' summary='Employee Pay Sheet'><thead><tr><th scope='col'>选项</th><th scope='col'>说明</th></tr></thead><tbody><tr class='odd'><td>angle</td><td>图形旋转角度,正值表示逆时针旋转</td></tr><tr><td>height</td><td>图形高度</td></tr></thead><tbody><tr class='odd'><td>width</td><td>图形宽度</td></tr><tr><td>scale</td><td>图形缩放因数</td></tr></tbody></table><p>插入图片一般可以分为两种情况,一种是只有一个图,一个标题；另一种是有多个图,每个图有个子标题,然后有个总的大标题。第一种情况就不做介绍了,第二种情况的命令如下(需要subfigure宏包):</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\begin</span><span class="template-variable">&#123;figure&#125;</span><span class="language-xml"> [!htbp]</span></span><br><span class="line"><span class="language-xml">\begin</span><span class="template-variable">&#123;minipage&#125;</span><span class="language-xml">[t]</span><span class="template-variable">&#123;0.5\textwidth&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\centering</span></span><br><span class="line"><span class="language-xml">\includegraphics[width=2.7in]</span><span class="template-variable">&#123;imgs/your1.eps&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\caption</span><span class="template-variable">&#123;fig1&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\end</span><span class="template-variable">&#123;minipage&#125;</span><span class="language-xml">%</span></span><br><span class="line"><span class="language-xml">\begin</span><span class="template-variable">&#123;minipage&#125;</span><span class="language-xml">[t]</span><span class="template-variable">&#123;0.5\textwidth&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\centering</span></span><br><span class="line"><span class="language-xml">\includegraphics[width=2.7in]</span><span class="template-variable">&#123;imgs/your1.eps&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\caption</span><span class="template-variable">&#123;fig2&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\end</span><span class="template-variable">&#123;minipage&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\end</span><span class="template-variable">&#123;figure&#125;</span></span><br></pre></td></tr></table></figure><p>如果不想让其显示caption,删除或者置空即可。</p><h1 id="与段落有关的距离"><a href="#与段落有关的距离" class="headerlink" title="与段落有关的距离"></a>与段落有关的距离</h1><h2 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h2><p>段落首行缩进的距离由长度\parindent决定,用户可如下改变这个值∶</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\setlength</span><span class="template-variable">&#123;\parindent&#125;</span><span class="template-variable">&#123;长度&#125;</span></span><br></pre></td></tr></table></figure><p>当上述长度不是零时,段落的首行会自动缩进由长度指定的距离。对于中文文章,命令</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\setlength</span><span class="template-variable">&#123;\parindent&#125;</span><span class="template-variable">&#123;2em&#125;</span><span class="language-xml"> 或在 CJK环境中写上 \CJKindent</span></span><br></pre></td></tr></table></figure><p>就会使其后段落首行缩进两个汉字的距离.需要注意的是上述两种首行缩进的距离等于当前字体两个汉字的宽度,若改变了字体尺寸,需重新再写一次上述命令,才会使后继段落首行缩进两个新字体汉字的宽度。若想使某段首行不缩进,可在该段开始放上命令<code>\noindent</code>。需要注意的是每一节的第一段的首行并不会缩进,为了使第一段能像其他段一样会首行缩进,可在第一段的开始放上命令</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\hspace*</span><span class="template-variable">&#123;\parindent&#125;</span></span><br></pre></td></tr></table></figure><h2 id="段落间距"><a href="#段落间距" class="headerlink" title="段落间距"></a>段落间距</h2><p>两段之间的距离 等于行 间 隔(也称为行 隙)(\lineskip)加上 长 度\parskip的值,如果重设这个值,通常应设置成弹性长度并使用ex作单位,以便它随着字体尺寸的改变而变化。中文书籍段落之间的距离通常与行间隔相同,为达到这种效果,可在导言区放上命令</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\setlength</span><span class="template-variable">&#123;\parskip&#125;</span><span class="template-variable">&#123;0pt&#125;</span></span><br></pre></td></tr></table></figure><h2 id="字母上加小箭头"><a href="#字母上加小箭头" class="headerlink" title="字母上加小箭头"></a>字母上加小箭头</h2><p>遇到一些矢量需要加箭头,短的箭头可用比如 \vec 去表示,想用长箭头去表示,可用指令\overrightarrow 来实现。</p><h1 id="listings-宏包使用说明"><a href="#listings-宏包使用说明" class="headerlink" title="listings 宏包使用说明"></a>listings 宏包使用说明</h1><p>listings 可以自定义一些特定风格的代码,在自己写文档的时候经常能够用的上,比如给matlab代码块配色等等,总之是挺好用的一个宏包,在网上可以查阅到很多的用法,下面的内容来自于知乎用户 <a href="https://www.zhihu.com/people/liu-zhi-yu-17-91">Lluvio Liu</a></p><h2 id="预设"><a href="#预设" class="headerlink" title="预设"></a>预设</h2><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\lstset&#123;</span> </span><br><span class="line">basicstyle=<span class="string">\small,</span> %环境中的代码字体变小 [在结尾要加逗号！]</span><br><span class="line">basicstyle=<span class="string">\tt,</span> %使用teletype字体(一种等宽字体)</span><br><span class="line">basicstyle=<span class="string">\it,</span> %使用罗马斜体</span><br><span class="line">%其他可选的还有：<span class="string">\bf,</span> <span class="string">\sc,</span> <span class="string">\st,</span> <span class="string">\sl,</span> <span class="string">\em,</span> <span class="string">\nocorr等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">\lstset&#123; </span><br><span class="line"><span class="attribute">keywordstyle</span>=\color&#123;black&#125;, %设置关键字颜色为黑色</span><br><span class="line"><span class="attribute">keywordstyle</span>=\color&#123;blue&#125;, %设置关键字颜色为蓝色</span><br><span class="line"><span class="attribute">keywordstyle</span>=\bfseries, %不改变当前字体的族与形状,但转变成bold加粗序列</span><br><span class="line"><span class="attribute">keywordstyle</span>=\mdseries, %不改变当前字体的族与形状,但转变成中等粗细medium序列</span><br><span class="line"><span class="attribute">keywordstyle</span>=\underbar, %添加下划线</span><br><span class="line"><span class="attribute">keywordstyle</span>=\color&#123;black&#125;\bfseries\underbar, %添加下划线的加粗黑色关键字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">\lstset&#123;</span><br><span class="line"><span class="attribute">identifierstyle</span>=\color&#123;red&#125;,</span><br><span class="line">identifierstyle= , %不设置 &#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">showstringspaces</span>=<span class="literal">false</span> %去掉空格时产生的下划的空格标志, 设置为<span class="literal">true</span>则出现</span><br><span class="line"><span class="attribute">showtabs</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">\lstset&#123; [公式]</span><br><span class="line"><span class="attribute">commentstyle</span>=\it\color[RGB]&#123;100,100,100&#125;, &#125;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">\lstset&#123;</span><br><span class="line"><span class="attribute">numbers</span>=left, %在左侧显示行数</span><br><span class="line"><span class="attribute">numbers</span>=right %在右侧显示行数</span><br><span class="line"><span class="attribute">numbers</span>=none, %去掉行数显示</span><br><span class="line"><span class="attribute">numberstyle</span>=\tiny\color&#123;red&#125;, %数字大小,颜色调整</span><br><span class="line"><span class="attribute">numberstyle</span>=\it, %数字字体调整</span><br><span class="line"><span class="attribute">stepnumber</span>=2 , %每两行标号一次</span><br><span class="line"><span class="attribute">numbersep</span>=5pt, %数字右端(若为左侧显示数字)水平距离代码5pt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">\lstset&#123;</span><br><span class="line"><span class="attribute">tabsize</span>=2; %此时一个tab键=2个空格</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\lstset&#123;</span><br><span class="line"><span class="attribute">xleftmargin</span>=2em, %整体距左侧边线的距离为2em</span><br><span class="line"><span class="attribute">xrightmargin</span>=2em,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">也可以使用</span><br><span class="line"><span class="attribute">linewidth</span>=1.2\linewidth 改变长度</span><br><span class="line"></span><br><span class="line">\lstset&#123;</span><br><span class="line"><span class="attribute">columns</span>=fixed, %改变字母间的空隙大小</span><br><span class="line"><span class="attribute">columns</span>=flexible,</span><br><span class="line"><span class="attribute">columns</span>=fullflexible,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环境参数"><a href="#环境参数" class="headerlink" title="环境参数"></a>环境参数</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">\begin&#123;lstlisting&#125;</span><br><span class="line">[<span class="attribute">firstline</span>=2, lastline =5] 只排版2-5行的代码</span><br><span class="line">[<span class="attribute">language</span>=C] %代码为C语言(会自动识别C语言关键字)</span><br><span class="line">[<span class="attribute">language</span>=Java] %代码为Java语言</span><br><span class="line">[float] %设置为浮动题</span><br><span class="line">[<span class="attribute">float</span>=t] %在页面上方</span><br><span class="line">[<span class="attribute">float</span>=!h] %在此处</span><br><span class="line">[<span class="attribute">firstnumber</span>=100] %第一个数字为100 [<span class="attribute">firstnumber</span>=last] %起始行数为上一段lstlisting环境结尾的行数 [caption=&#123;MyCode1&#125;] %说明 [caption=&#123;[Code2] An very important code&#125;] %可分别添加一个短的和长的caption [<span class="attribute">label</span>=Code1] % 标签 [<span class="attribute">title</span>=Code1] %可以去掉label产生的Listings 1</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[<span class="attribute">name</span>=MyCode1] %使用<span class="attribute">name</span>=***为代码环境取名,同名的环境代码行数会延续</span><br><span class="line">[<span class="attribute">aboveskip</span>=5pt] %与代码环境上一行的垂直间距为5pt</span><br><span class="line">[<span class="attribute">belowskip</span>=4pt] %与代码环境下一行的垂直间距为4pt</span><br></pre></td></tr></table></figure><p>当然,它们也可以在 lstset 中设置</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">[emph=</span><span class="template-variable">&#123;printf&#125;</span><span class="language-xml">, emphstyle=</span><span class="template-variable">&#123;\underbar&#125;</span><span class="language-xml">] %强调printf,在它下面加下划线</span></span><br><span class="line"><span class="language-xml">[emph=</span><span class="template-variable">&#123;for,while&#125;</span><span class="language-xml">, emphstyle=\color</span><span class="template-variable">&#123;red&#125;</span><span class="language-xml">]</span></span><br><span class="line"><span class="language-xml">[emph=</span><span class="template-variable">&#123;strlen&#125;</span><span class="language-xml">, emphstyle=\color</span><span class="template-variable">&#123;red&#125;</span><span class="language-xml">,</span></span><br><span class="line"><span class="language-xml">emph=</span><span class="template-variable">&#123;[2]strcpy&#125;</span><span class="language-xml">, emphstyle=</span><span class="template-variable">&#123;[2]\color&#123;blue&#125;</span><span class="language-xml">&#125;,</span></span><br><span class="line"><span class="language-xml">emph=</span><span class="template-variable">&#123;[3]strcmp&#125;</span><span class="language-xml">,emphstyle=</span><span class="template-variable">&#123;[3]\underbar&#125;</span><span class="language-xml">] %强调多个,并且强调方式不同</span></span><br></pre></td></tr></table></figure><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[<span class="attribute">frame</span>=none] %无框</span><br><span class="line">[<span class="attribute">frame</span>=leftline,topline,rightline, bottomline] %分别对应只在左侧,上方,右侧,下方有竖线</span><br><span class="line">[<span class="attribute">frame</span>=trb] %t-top,r-right,b-bottom,l-left. 这是为框架只在上,右,下方</span><br><span class="line">[<span class="attribute">frame</span>=trBL] %大写表示双重线</span><br><span class="line">在预设中可设置框的拐角处为圆弧：</span><br><span class="line">\lstset&#123;</span><br><span class="line">\frameround = fttt,</span><br><span class="line">&#125;</span><br><span class="line">\frameround后必须有四个字母。第一个字母表示右上角的拐角,然后顺时针地依次代表各个拐角。f表示方形,t表示弧形。</span><br><span class="line"><span class="attribute">frame</span>=shadowbox, %设置阴影</span><br><span class="line"><span class="attribute">framexleftmargin</span>=4mm, %框架左边界延长(frame是不会考虑到左边的行数栏的)</span><br><span class="line"><span class="attribute">rulecolor</span>=\color&#123;gray&#125;, %框架颜色设置</span><br><span class="line"><span class="attribute">rulesepcolor</span>=\color&#123;gray&#125;, %框架阴影颜色设置</span><br></pre></td></tr></table></figure><h2 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h2><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">\lstset&#123;</span><br><span class="line"><span class="attribute">backgroundcolor</span><span class="operator">=</span>\color&#123;yellow&#125; %背景颜色为黄色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多的指令"><a href="#更多的指令" class="headerlink" title="更多的指令"></a>更多的指令</h2><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\lstdefinestyle 可以预设多个不同的style。 \lstdefinestyle</span><span class="template-variable">&#123;numbers1&#125;</span><span class="template-variable">&#123;numbers=left, stepnumber=1, numberstyle=\tiny, numbersep=10pt&#125;</span><span class="language-xml"> \lstdefinestyle</span><span class="template-variable">&#123;numbers2&#125;</span><span class="template-variable">&#123;numbers=none&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\begin</span><span class="template-variable">&#123;lstlisting&#125;</span><span class="language-xml">[style=numbers1] 即可选择numbers1作为style</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\lstdefinelanguage 定义一个新的语言.</span></span><br><span class="line"><span class="language-xml">\lstdefinelanguage</span><span class="template-variable">&#123;SDU&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="template-variable">&#123;morekeywords=&#123;ShiYidDa, CheapCafeteria&#125;</span><span class="language-xml">, %定义关键字</span></span><br><span class="line"><span class="language-xml">sensitive=false, %是否大小写敏感</span></span><br><span class="line"><span class="language-xml">morecommet=[l]</span><span class="template-tag">&#123;//&#125;</span><span class="language-xml">,</span></span><br><span class="line"><span class="language-xml">morecomment=[s]</span><span class="template-tag">&#123;/*&#125;</span><span class="template-variable">&#123;*/&#125;</span><span class="language-xml">,</span></span><br><span class="line"><span class="language-xml">morecomment=[n]</span><span class="template-variable">&#123;(*&#125;</span><span class="template-variable">&#123;*)&#125;</span><span class="language-xml">,</span></span><br><span class="line"><span class="language-xml">morestring=[b]&quot;,</span></span><br><span class="line"><span class="language-xml">morestring=[d]&#x27;,&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">**morecomment**指令用于定义书写注释的标识符。</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">[l] 表示标识符后至该行末尾</span></span><br><span class="line"><span class="language-xml">[s] 表示定义的第一个和第二个标识符之间</span></span><br><span class="line"><span class="language-xml">[n] 表示从第一个定义的标识符开始,直至出现第二个标识符。</span></span><br><span class="line"><span class="language-xml">[il] [is] [in] 编译时不显示注释</span></span><br></pre></td></tr></table></figure><p>也可以定义不同颜色的注释(要先定义好普通注释/**/)</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\lstset</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">morecomment=[s][\color&#123;blue&#125;</span><span class="language-xml">]</span><span class="template-tag">&#123;/*+&#125;</span><span class="template-variable">&#123;*/&#125;</span><span class="language-xml">,</span></span><br><span class="line"><span class="language-xml">morecomment=[s][\color</span><span class="template-variable">&#123;red&#125;</span><span class="language-xml">]</span><span class="template-tag">&#123;/*<span class="name">-</span>&#125;</span><span class="template-variable">&#123;*/&#125;</span><span class="language-xml">, &#125;</span></span><br></pre></td></tr></table></figure><p><strong>\lstlistoflistings</strong> 添加过 caption 的代码段可以通过此命令全部被列出来,并且按顺序标号和标注页码。 添加过 name 的代码段也会通过此命令被列出来,且不会参与标号。此时对该代码段再添加caption就会覆盖name。 对于caption{[<short>]<long>}只会打出其短名。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]  《LaTex 入门与提高》——陈志杰等。</p><p>[2] <a href="https://zhuanlan.zhihu.com/p/261667944">LaTeX listings 宏包使用说明</a></p>]]></content>
      
      
      <categories>
          
          <category> LATEX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉角</title>
      <link href="/2020/10/04/archived_robot_Euler_Angle/"/>
      <url>/2020/10/04/archived_robot_Euler_Angle/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#欧拉角">欧拉角</a></li></ul><!-- vim-markdown-toc --><h1 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h1><p>欧拉角来描述刚体在三维欧几里德空间的姿态。对于任何参考系,一个刚体的姿态,在使用欧拉角的描述下可用三个基本旋转矩阵来决定。可用两个坐标系来解释,其中不动的坐标系作为参考,另外一个坐标系固定于刚体,随着刚体的旋转而旋转,就像下面所展示的那样</p><div align="center"> <img src="/img/postImg/36_somethingElse/EulerAngle.gif" width="30%" height="40%"> </div><p>参考下图,设定xyz-轴为参考系的参考轴。称xy-平面与XY-平面的相交为交点线,用英文字母(N)代表。</p><div align="center"> <img src="/img/postImg/36_somethingElse/Eulerangles.svg" width="20%" height="20%"> </div><p>zxz顺规的欧拉角可以静态地这样定义： <img src="/img/postImg/mathSym/alpha.png" width="1%" height="1%"> 是x-轴与交点线的夹角, <img src="/img/postImg/mathSym/beta.png" width="1%" height="1%"> 是z-轴与Z-轴的夹角, <img src="/img/postImg/mathSym/gamma.png" width="1%" height="1%"> 是交点线与X-轴的夹角。</p><p>很可惜地,对于夹角的顺序和标记,夹角的两个轴的指定,并没有任何常规。科学家对此从未达成共识。每当用到欧拉角时,我们必须明确的表示出夹角的顺序,指定其参考轴。 实际上,有许多方法可以设定两个坐标系的相对取向。欧拉角(共有12组组合)方法只是其中的一种。此外,不同的作者会用不同组合的欧拉角来描述,或用不同的名字表示同样的欧拉角。因此,使用欧拉角前,必须先做好明确的定义。</p><p>在RTB上默认采用的是横滚一俯仰一偏航角这种情况,其旋转矩阵为(需要注意的是rpy定义有多种,比如zyx,xyz等等, 常用的为ZYX欧拉角)</p><p><img src="/img/postImg/32_robotics/EulerAngle/EulerAngle.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> ROBOTICS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> robotics </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未归类</title>
      <link href="/2020/10/04/doNothingButConnect/"/>
      <url>/2020/10/04/doNothingButConnect/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#欧拉角">欧拉角</a></li><li><a href="#驱动器">驱动器</a></li><li><a href="#香农采样定理">香农采样定理</a><ul><li><a href="#docker-安装-ubuntu">docker 安装 ubuntu</a></li><li><a href="#信号带宽">信号带宽</a></li></ul></li><li><a href="#频率">频率</a></li><li><a href="#绘制功率谱图">绘制功率谱图</a></li><li><a href="#陷波器参数">陷波器参数</a></li><li><a href="#excelword-中对号代码">Excel/word 中对号代码</a><ul><li><a href="#知识点">知识点</a></li></ul></li><li><a href="#windows-命令行对启动盘进行合并">windows 命令行对启动盘进行合并</a></li><li><a href="#windows局域网文件共享的使用">windows局域网文件共享的使用</a></li><li><a href="#typora中公式无法正常显示">Typora中公式无法正常显示</a></li><li><a href="#谷歌浏览器截取长屏幕全屏截图">谷歌浏览器截取长屏幕(全屏截图)</a></li><li><a href="#取名神器">取名神器</a></li><li><a href="#conda创建python虚拟环境">conda创建python虚拟环境</a><ul><li><a href="#1查看安装了哪些包">1)查看安装了哪些包</a></li><li><a href="#2查看当前存在哪些虚拟环境">2)查看当前存在哪些虚拟环境</a></li><li><a href="#检查更新当前conda">检查更新当前conda</a></li></ul></li><li><a href="#关闭显示更多选项">关闭显示更多选项</a><ul><li><a href="#步骤一">步骤一</a></li><li><a href="#步骤二">步骤二</a></li><li><a href="#步骤三">步骤三</a></li></ul></li><li><a href="#github-shell使用不需要验证身份macos-操作">GitHub shell使用不需要验证身份(macOs 操作)</a></li><li><a href="#大文件分割">大文件分割</a></li><li><a href="#connection-refused">Connection refused</a></li><li><a href="#mac-中安装ros">MAC 中安装ROS</a></li><li><a href="#vim修改权限-e45-已设定选项-readonly-请加--强制执行">vim修改权限： E45: 已设定选项 ‘readonly’ (请加 ! 强制执行)</a></li><li><a href="#mac-网络故障-ping-can-not-resolve-的问题">MAC 网络故障 ping: can not resolve 的问题</a></li><li><a href="#macparallels-desktop-windows-11-卡死在开机界面问题">MAC/Parallels Desktop Windows 11 卡死在开机界面问题</a></li><li><a href="#awk-相关使用">AWK 相关使用</a></li><li><a href="#sed-的使用">SED 的使用</a></li><li><a href="#vim-对于python3第三方库的自动补全">VIM 对于Python3第三方库的自动补全</a></li><li><a href="#frf-频率响应函数">FRF 频率响应函数</a></li><li><a href="#报错解决attributeerror-module-lib-has-no-attribute-openssl_add_all_algorithms">报错解决：AttributeError: module ‘lib’ has no attribute ‘OpenSSL_add_all_algorithms’</a></li><li><a href="#提示某程序已损坏">提示某程序已损坏</a></li><li><a href="#ifconfig">ifconfig</a></li><li><a href="#tensorflow-install-macos">tensorflow install (MacOs)</a></li><li><a href="#mac-终端多个标签切换">mac 终端多个标签切换</a></li><li><a href="#unique_ptr独占型智能指针">unique_ptr独占型智能指针</a><ul><li><a href="#初始化方式">初始化方式</a></li><li><a href="#使用场景">使用场景</a></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>零零碎碎平常学习或偶尔了解到的一点小的知识点,收录其中。</p><h1 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h1><p>欧拉角来描述刚体在三维欧几里德空间的姿态。对于任何参考系,一个刚体的姿态,在使用欧拉角的描述下可用三个基本旋转矩阵来决定。可用两个坐标系来解释,其中不动的坐标系作为参考,另外一个坐标系固定于刚体,随着刚体的旋转而旋转,就像下面所展示的那样</p><div align="center"> <img src="/img/postImg/36_somethingElse/EulerAngle.gif" width="30%" height="40%"> </div><p>参考下图,设定xyz-轴为参考系的参考轴。称xy-平面与XY-平面的相交为交点线,用英文字母(N)代表。</p><div align="center"> <img src="/img/postImg/36_somethingElse/Eulerangles.svg" width="20%" height="20%"> </div><p>zxz顺规的欧拉角可以静态地这样定义： <img src="/img/postImg/mathSym/alpha.png" width="1%" height="1%"> 是x-轴与交点线的夹角, <img src="/img/postImg/mathSym/beta.png" width="1%" height="1%"> 是z-轴与Z-轴的夹角, <img src="/img/postImg/mathSym/gamma.png" width="1%" height="1%"> 是交点线与X-轴的夹角。</p><p>很可惜地,对于夹角的顺序和标记,夹角的两个轴的指定,并没有任何常规。科学家对此从未达成共识。每当用到欧拉角时,我们必须明确的表示出夹角的顺序,指定其参考轴。 实际上,有许多方法可以设定两个坐标系的相对取向。欧拉角(共有12组组合)方法只是其中的一种。此外,不同的作者会用不同组合的欧拉角来描述,或用不同的名字表示同样的欧拉角。因此,使用欧拉角前,必须先做好明确的定义。</p><p>在RTB上默认采用的是横滚一俯仰一偏航角这种情况,其旋转矩阵为(需要注意的是rpy定义有多种,比如zyx,xyz等等)</p> <div align="center"> <img src="https://latex.codecogs.com/png.latex?  R = R_x(\alpha)R_y(\beta)R_z(\gamma)= \left [  \begin{array}{ccc} \cos (\alpha ) \cos (\beta ) & \sin (\alpha ) (-\cos (\beta )) & \sin (\beta ) \\ \cos (\alpha ) \sin (\beta ) \sin (\gamma )+\sin (\alpha ) \cos (\gamma ) & \cos (\alpha ) \cos (\gamma )-\sin (\alpha ) \sin (\beta ) \sin (\gamma ) & -\cos (\beta ) \sin (\gamma ) \\ \sin (\alpha ) \sin (\gamma )-\cos (\alpha ) \sin (\beta ) \cos (\gamma ) & \sin (\alpha ) \sin (\beta ) \cos (\gamma )+\cos (\alpha ) \sin (\gamma ) & \cos (\beta ) \cos (\gamma ) \\\end{array} \right] "/> </div><p>这样很容易找到机器人运动学正解的角度与姿态之间的对应关系</p><h1 id="驱动器"><a href="#驱动器" class="headerlink" title="驱动器"></a>驱动器</h1><p>大多数实验室和工业机器人是用电机驱动的。电机可以通过电流或电压控制,这里考虑电流控制的情况。假设电机驱动器或放大器提供的电流为</p><div align="center"> <img src="https://latex.codecogs.com/png.latex?i = K_au"/> </div><p>它与所施加的控制电压是线性相关的,其中 <img src="https://latex.codecogs.com/png.latex?  K_a "/>是放大器的跨导,单位为 A/V。由电机产生的转矩与电流成正比</p><div align="center"> <img src="https://latex.codecogs.com/png.latex?\tau  = K_mi"/> </div><p>其中, <img src="https://latex.codecogs.com/png.latex?K_m "/> 是电机的扭矩常数,不同的书籍会用不同的符号去表示,自己见的比较多的是用符号 <img src="https://latex.codecogs.com/png.latex?K_t "/> 去表示,单位为Nm/A。电机动力模型由下式描述:</p><div align="center"> <img src="https://latex.codecogs.com/png.latex?J_m\dot{\omega} + B \omega + \tau_c(\omega)  = K_m K_a u"/> </div><p>其中, <img src="https://latex.codecogs.com/png.latex?  J_m "/> 是电机的总惯量,B 是黏性摩擦系数, <img src="https://latex.codecogs.com/png.latex?  \tau_c "/> 是库仑摩擦力矩。</p><h1 id="香农采样定理"><a href="#香农采样定理" class="headerlink" title="香农采样定理"></a>香农采样定理</h1><p>香农采样定理：设 <img src="https://latex.codecogs.com/png.latex? f(t) "/> 是一个有限带宽的信号,其上限频率为 <img src="https://latex.codecogs.com/png.latex? \omega_m "/>, <img src="https://latex.codecogs.com/png.latex? \omega_s "/>为采样频率, 当 <img src="https://latex.codecogs.com/png.latex? \omega_s \ge 2\omega_m "/> 时,经采样得到的信号 f’(t)能够不失真地恢复原信号。在满足, <img src="https://latex.codecogs.com/png.latex?\omega_s > 2\omega_m  "/>条件时,连续信号f(t)可以由采样值 <img src="https://latex.codecogs.com/png.latex?f(kT) (k =0, \pm 1, \pm 2 \cdots)  "/> 唯一确定,其插值公式为</p><div align="center"><img src="https://latex.codecogs.com/png.latex?  f(t) = \sum_{k = -\infty}^{\infty} f(kT) \frac{\sin\left[ \frac{\omega_s(t - kT)}{2}\right]}{\frac{\omega_s(t - kT)}{2}} "/></div><p>matlab中butter函数是butterworth滤波器,调用句式为</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[b,a]</span> = <span class="built_in">butter</span>(n,\omega_n)</span><br></pre></td></tr></table></figure><p>其中n为滤波器的阶数,n=6就代表6阶butterworth滤波器。 <img src="https://latex.codecogs.com/png.latex?  \omega_n "/> 代表截止频率,即信号幅值将为原来的0.707时所对应的频率,对应bode图中幅值为-3dB所对应的频率；n和 <img src="https://latex.codecogs.com/png.latex?  \omega_n "/> 的选取是根据你自己的需求来确定的。假如说你想得到 <img src="https://latex.codecogs.com/png.latex?  f<3800\times f_s/(6000\times 2)Hz "/> 的信号,那么就可以设计滤波器的截止频率 <img src="https://latex.codecogs.com/png.latex?  \omega_n = 2f/f_s$, $f_s "/><br>为采样频率</p><figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Fs=<span class="number">125</span>;<span class="comment">%采样频率</span></span><br><span class="line">wb=<span class="number">40</span>;<span class="comment">%截止频率</span></span><br><span class="line">Wn = (<span class="number">2</span>*wb)/Fs;</span><br><span class="line"><span class="comment">% to normalized frequency: 0.4*pi rad/sample</span></span><br><span class="line">[B,A] = butter(<span class="number">5</span>,Wn,<span class="string">&#x27;low&#x27;</span>);</span><br><span class="line">filter_y = filtfilt(B,A,y);<span class="comment">%滤波 </span></span><br></pre></td></tr></table></figure><h2 id="docker-安装-ubuntu"><a href="#docker-安装-ubuntu" class="headerlink" title="docker 安装 ubuntu"></a>docker 安装 ubuntu</h2><p>先在docker 输入如下指令</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker pull ubuntu</span></span><br></pre></td></tr></table></figure><p>安装好后,通过指令</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">docker run -t -i ubuntu:latest <span class="comment">//bin/bash</span></span><br></pre></td></tr></table></figure><p>即可在Windows/powershell下愉快的玩耍了。关于docker有很多知识是可以学习的,正因为如此,打算另写一份笔记。</p><h2 id="信号带宽"><a href="#信号带宽" class="headerlink" title="信号带宽"></a>信号带宽</h2><p>一个信号所包含谐波的最高频率与最低频率之差,即该信号所拥有的频率范围,定义为该信号的带宽。 譬如,一个由数个正弦波叠加成的方波信号,其最低频率分量是其基频,假定为f=2kHz,其最高频率分量是其7次谐波频率,即7f =7×2=14kHz,因此该信号带宽为7f - f =14-2=12kHz。信道带宽则限定了允许通过该信道的信号下限频率和上限频率,也就是限定了一个频率通带。比如一个信道允许的通带为1.5kHz至15kHz,其带宽为13.5kHz,上面这个方波信号的所有频率成分当然能从该信道通过,如果不考虑衰减、时延以及噪声等因素,通过此信道的该信号会毫不失真。然而,如果一个基频为1kHz的方波,通过该信道肯定失真会很严重；方波信号若基频为2kHz,但最高谐波频率为18kHz,带宽超出了信道带宽,其高次谐波会被信道滤除,通过该信道接收到的方波没有发送的质量好；那么,如果方波信号基频为500Hz,最高频率分量是11次谐波的频率为5.5kHz,其带宽只需要5kHz,远小于信道带宽,是否就能很好地通过该信道呢？其实,该信号在信道上传输时,基频被滤掉了,仅各次谐波能够通过,信号波形一定是不堪入目的。</p><p>3dB带宽：3dB带宽通常指功率谱密度的最高点下降到1/2时界定的频率范围。</p><h1 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h1><p>频率(英语：Frequency),又称周波数。是单位时间内某事件重复发生的次数,在物理学中通常以符号f或<img src="https://latex.codecogs.com/png.latex? \nu "/> 表示。采用国际单位制,其单位为赫兹(英语：Hertz,简写为Hz)。设<img src="https://latex.codecogs.com/png.latex? \tau "/>\时间内某事件重复发生n次,则此事件发生的频率为<img src="https://latex.codecogs.com/png.latex? f = \frac{n}{\tau} "/>赫兹。又因为周期定义为重复事件发生的最小时间间隔,故频率也可以表示为周期的倒数：</p><div align="center"> <img src="https://latex.codecogs.com/png.latex?f = \frac{1}{T}"/> </div><p>对于震荡和波动,角频率 <img src="https://latex.codecogs.com/png.latex?  \omega "/>定义为正弦波相位的变率。角频率的单位为弧度每秒。角频率与频率(循环次数每秒)的关系为<br><img src="https://latex.codecogs.com/png.latex?  \omega = 2 \pi f "/>。</p><h1 id="绘制功率谱图"><a href="#绘制功率谱图" class="headerlink" title="绘制功率谱图"></a>绘制功率谱图</h1><p>在MATLAB中有信号分析工具箱可以直接绘制,若使用python,直接调用 <code>matplotlib.pyplot.psd</code> 即可,如果想返回实际值,可用 </p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pxx</span>,fre = plt.psd(yourData,NFFT=<span class="number">200</span>, Fs = <span class="number">1000</span>,opts)</span><br></pre></td></tr></table></figure><p>这里yourData是自己采样的数据,nfft表示长度段(Welch’s average periodogram method),Fs是采样周期,看了很多博客在写PSD的时候,Fs好像并没有包含在内,也没有时间去验证他们写的是不是对的,不过可以直接用Python绘制出PSD图,就没有那个心思去验证了。可以参考<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.psd.html">官方网站</a>去设置一些选项或者是将一些分析整合在自己的代码当中。</p><h1 id="陷波器参数"><a href="#陷波器参数" class="headerlink" title="陷波器参数"></a>陷波器参数</h1><p>有的驱动器是用陷波器的中心频率和带宽来进行陷波的,有的则是使用陷波Q值、宽度、深度来表示,这里对后面所提及的概念进行说明。陷波Q值、宽度、深度的关系如下：</p><p>陷波滤波器Q值 = 陷波中心频率 / 陷波宽度。</p><p>陷波滤波器的宽度指的是当陷波深度为0,陷波中心频率两边功率谱下降3dB所对应的两个频率差值(品质因数越大,滤波频带越窄)。</p><p>陷波滤波器的深度,表示输入与输出的比值。</p><h1 id="Excel-word-中对号代码"><a href="#Excel-word-中对号代码" class="headerlink" title="Excel/word 中对号代码"></a>Excel/word 中对号代码</h1><p>这种方法在很多地方可以适用,也就是按住Alt键,再输入对号√对应的字母,这个对号√符号就出来了,对号√对应的字母数字是41420。</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>1, 一般的,阻抗控制是直接控制力(电流)的方式；导纳控制是通过控制位置来控制力；</p><p>2, 瞬态响应主要取决于其极点分布。</p><h1 id="windows-命令行对启动盘进行合并"><a href="#windows-命令行对启动盘进行合并" class="headerlink" title="windows 命令行对启动盘进行合并"></a>windows 命令行对启动盘进行合并</h1><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">diskpart</span><br><span class="line">list diskpart <span class="comment">#记住U盘数字编号</span></span><br><span class="line">select disk <span class="comment">#是上面记住的数字</span></span><br><span class="line">clean</span><br><span class="line">create partition primary</span><br><span class="line">select partition <span class="number">1</span></span><br><span class="line">active</span><br><span class="line">format quick fs=fat32</span><br><span class="line">assign </span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><h1 id="windows局域网文件共享的使用"><a href="#windows局域网文件共享的使用" class="headerlink" title="windows局域网文件共享的使用"></a>windows局域网文件共享的使用</h1><p>主要在工作之中使用到的比较多,采用共享文件的形式,即可读取另一台电脑里的文件,方便进行一些操作与整理。首先在需要共享的文件夹上右击选择“共享”</p><p><img src="/img/postImg/20_doNothing/share1.png" alt=""></p><p>点击高级共享</p><p><img src="/img/postImg/20_doNothing/share2.png" alt=""></p><p>然后点击权限</p><p><img src="/img/postImg/20_doNothing/share3.png" alt=""></p><p>由于共享的文件一般不是虚拟机就是自己的另一台主机,所以都选上,方便自己整理和操作。快捷键win+R,输入：cmd, 然后输入:<code>ipconfig</code>,即可获取本机的局域网的网段。再另一台电脑上,输入如 </p><figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">\\<span class="number">172.19.100.15</span></span><br></pre></td></tr></table></figure><p>然后输入账号密码即可共享此文件。</p><h1 id="Typora中公式无法正常显示"><a href="#Typora中公式无法正常显示" class="headerlink" title="Typora中公式无法正常显示"></a>Typora中公式无法正常显示</h1><p>可用通过 <code>偏好设置</code> 中的 <code>Markdown</code>将其扩展语法全部打开即可</p><p><img src="/img/postImg/20_doNothing/markdown无法正常显示行内公式的解决办法.png" alt=""></p><h1 id="谷歌浏览器截取长屏幕-全屏截图"><a href="#谷歌浏览器截取长屏幕-全屏截图" class="headerlink" title="谷歌浏览器截取长屏幕(全屏截图)"></a>谷歌浏览器截取长屏幕(全屏截图)</h1><p>1、打开目标网站</p><p>2、按下键盘上 “F12” 或者 “Ctrl + Shift + L”  打开调试页面</p><p>3、按下键盘上  “Ctrl+Shift+P”</p><p>4、键入内容“ Capture full size screenshot ” 后,按下回车</p><p>5、此时会下载图片</p><p>6、打开文件</p><p>7、可以看到截图的结果 </p><h1 id="取名神器"><a href="#取名神器" class="headerlink" title="取名神器"></a>取名神器</h1><p>在写程序的时候,变量名的命名是非常重要的一环,要不是英语水平不过关,要不就是词不达意,可以考虑一下 <a href="https://unbug.github.io/codelf/"><strong><code>CODEIF</code></strong> </a>这个在线网页</p><h1 id="conda创建python虚拟环境"><a href="#conda创建python虚拟环境" class="headerlink" title="conda创建python虚拟环境"></a>conda创建python虚拟环境</h1><h2 id="1-查看安装了哪些包"><a href="#1-查看安装了哪些包" class="headerlink" title="1)查看安装了哪些包"></a>1)查看安装了哪些包</h2><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">conda list</span></span><br></pre></td></tr></table></figure><h2 id="2-查看当前存在哪些虚拟环境"><a href="#2-查看当前存在哪些虚拟环境" class="headerlink" title="2)查看当前存在哪些虚拟环境"></a>2)查看当前存在哪些虚拟环境</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">conda</span> env list </span><br><span class="line">conda <span class="literal">info</span> -e</span><br></pre></td></tr></table></figure><h2 id="检查更新当前conda"><a href="#检查更新当前conda" class="headerlink" title="检查更新当前conda"></a>检查更新当前conda</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure><h1 id="关闭显示更多选项"><a href="#关闭显示更多选项" class="headerlink" title="关闭显示更多选项"></a>关闭显示更多选项</h1><h2 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h2><p>&bull; 同时按 <strong>Win+R</strong>,输入 <strong>regedit</strong> 打开注册表编辑器</p><h2 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h2><p>&bull; 切换到注册表路径： <strong>HKEY_CURRENT_USER\Software\Classes\CLSID</strong></p><h2 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h2><p>1, 在 <strong>CLSID</strong> 上弹出右键菜单,选择 <strong>新建 &gt; 项</strong>(<strong>New &gt; Key</strong>),将新增键命名为：<strong>{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}</strong><br>2, 同上操作,给 <strong>{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}</strong> 添加子健 <strong>InprocServer32</strong><br>3, 将 <strong>InprocServer32</strong> 的默认值设置为空白即可</p><h1 id="GitHub-shell使用不需要验证身份-macOs-操作"><a href="#GitHub-shell使用不需要验证身份-macOs-操作" class="headerlink" title="GitHub shell使用不需要验证身份(macOs 操作)"></a>GitHub shell使用不需要验证身份(macOs 操作)</h1><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>gh</span><br><span class="line">gh auth login</span><br></pre></td></tr></table></figure><p>会在shell中弹出对话框,选择 <code>Github.com</code>, 选择HTTPS, 这里需要声明一下,如果没有配置Git的通信协议的话,按照如下方式配置</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> config --global http.version HTTP/<span class="number">1</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后在对话框中选择YES,再选择<code>Login with a web browser</code>, 会在浏览器里弹出来一个界面, 绑定后以后就不需要输入密码了,之前需要通过token去做关联,每次都要去搜一遍咋操作的。。。。</p><h1 id="大文件分割"><a href="#大文件分割" class="headerlink" title="大文件分割"></a>大文件分割</h1><p>起初是由于利用python自动生成的sh指令太大了,搜索了一番后发现shell文件最多支持13W字符数,导致提取数据不全,搜了下将大的shell给按行分割成小的文件,然后再批量执行即可,下面直接给出从CSDN中搜索出来的答案, </p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">split</span> -l <span class="number">500000</span> -d <span class="comment">--verbose sourcelist.xlsx  target</span></span><br></pre></td></tr></table></figure><p>简单的做个测试,在shell里面输入如下指令</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">printf</span> <span class="string">&quot;%s\n&quot;</span> &#123;<span class="number">1</span>..<span class="number">10</span>&#125; &gt; test.txt | cat</span><br></pre></td></tr></table></figure><p><img src="/img/postImg/20_doNothing/usingSplit_step1.png" alt=""></p><p>这样可以得到test.txt文件,其中文件内容就是10行数字了, 通过上述操作后,把test.txt分割为十个文件,如下所示(Mac 里面不支持—verbose参数,git bash 里面是可以的)</p><p><img src="/img/postImg/20_doNothing/usingSplit_step2.png" alt=""></p><p>输入如下指令就可以生成这10个txt文件了(git bash里面应该是可以的,我没有去尝试)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ./ -name <span class="string">&#x27;test0*&#x27;</span> -<span class="built_in">printf</span> %f\\n|awk -F<span class="string">&#x27;.&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>|xargs -i&#123;&#125; <span class="built_in">mv</span> &#123;&#125; &#123;&#125;.txt</span><br></pre></td></tr></table></figure><p>但是这种指令对于用的不熟悉的人而言,还是记不住的,  等啥时候有时间再给出比较简单的解决方式了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">当问了chatGPT这个问题的时候,它给出了我一个忘不掉的指令,即简洁,又容易理解(百度,CSDN等垃圾再见吧), 答案如下,可根据自己的需求随便改动代码</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *old*; <span class="keyword">do</span> <span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;file/old/new&#125;</span>&quot;</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>上述命令中,<code>*old*</code> 表示匹配包含 <code>old</code> 的所有文件名。<code>$&#123;file/old/new&#125;</code> 表示将 <code>old</code> 替换为 <code>new</code>,<code>$&#123;file&#125;</code> 表示当前文件名。<code>&quot;$file&quot;</code> 和 <code>&quot;$&#123;file/old/new&#125;&quot;</code> 用双引号引起来,是为了避免文件名中包含空格等特殊字符时出现问题。如果要在文件名的开头或结尾添加前缀或后缀,可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *; <span class="keyword">do</span> <span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span> <span class="string">&quot;prefix<span class="variable">$file</span>&quot;</span>; <span class="keyword">done</span>   <span class="comment"># 添加前缀</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *; <span class="keyword">do</span> <span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;file%suffix&#125;</span>new&quot;</span>; <span class="keyword">done</span>   <span class="comment"># 替换后缀</span></span><br></pre></td></tr></table></figure><h1 id="Connection-refused"><a href="#Connection-refused" class="headerlink" title="Connection refused"></a>Connection refused</h1><p>解决Failed to connect to raw.githubusercontent.com port 443: Connection refused</p><p>使用vim /etc/hosts命令打开不能访问的机器的hosts文件,添加如下内容：(如果不能修改这个文件的情况下,采用<code>sudu -i</code>进入管理员模式对这个文件进行修改即可)</p><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">199.232.68.133</span> raw.githubusercontent.com</span><br><span class="line"><span class="number">199.232.68.133</span> user-images.githubusercontent.com</span><br><span class="line"><span class="number">199.232.68.133</span> avatars2.githubusercontent.com</span><br><span class="line"><span class="number">199.232.68.133</span> avatars1.githubusercontent.com</span><br></pre></td></tr></table></figure><h1 id="MAC-中安装ROS"><a href="#MAC-中安装ROS" class="headerlink" title="MAC 中安装ROS"></a>MAC 中安装ROS</h1><p>1, 安装Homebrew：打开终端,输入以下命令安装Homebrew：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>2,  安装ROS：在终端中输入以下命令来安装ROS：</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>ros</span><br></pre></td></tr></table></figure><p>3, 设置ROS环境变量：ROS依赖于环境变量来找到它的程序和库文件。在终端中输入以下命令来设置ROS环境变量：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/homebrew/opt/ros/setup.bash&quot;</span> &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure><h1 id="vim修改权限：-E45-已设定选项-‘readonly’-请加-强制执行"><a href="#vim修改权限：-E45-已设定选项-‘readonly’-请加-强制执行" class="headerlink" title="vim修改权限： E45: 已设定选项 ‘readonly’ (请加 ! 强制执行)"></a>vim修改权限： E45: 已设定选项 ‘readonly’ (请加 ! 强制执行)</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入 w !<span class="built_in">sudo</span> <span class="built_in">tee</span> % 后,在输入q退出,在打开文件时,文件已经被修改</span><br></pre></td></tr></table></figure><p>顺带搜了一个比较实用的技巧, 即</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Vim插入模式下,按 <span class="tag">&lt;<span class="name">Ctrl-r</span>&gt;</span>% 可将当前文件名输入到文件中</span><br></pre></td></tr></table></figure><h1 id="MAC-网络故障-ping-can-not-resolve-的问题"><a href="#MAC-网络故障-ping-can-not-resolve-的问题" class="headerlink" title="MAC 网络故障 ping: can not resolve 的问题"></a>MAC 网络故障 ping: can not resolve 的问题</h1><p>这个是莫名其妙发生的, 就是突然之间,网络就用不了了, 且网上给的教程都太老了,想重置MAC网络一些选项根本就没有！可以通过如下方式来解决这一问题</p><p>1, 首先关闭WI-FI</p><p>2, <code>cd  /Library/Preferences/SystemConfiguration</code></p><p>3, 删除相关文件, 使用管理员权限</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">sudo rm com<span class="selector-class">.apple</span><span class="selector-class">.airport</span><span class="selector-class">.preferences</span><span class="selector-class">.plist</span></span><br><span class="line">sudo rm com<span class="selector-class">.apple</span><span class="selector-class">.wifi</span><span class="selector-class">.message-tracer</span><span class="selector-class">.plist</span></span><br><span class="line">sudo rm com<span class="selector-class">.apple</span><span class="selector-class">.network</span><span class="selector-class">.eapolclient</span><span class="selector-class">.configuration</span><span class="selector-class">.plist</span></span><br><span class="line">sudo rm NetworkInterfaces.plist</span><br></pre></td></tr></table></figure><p>4, 重启就可以了</p><h1 id="MAC-Parallels-Desktop-Windows-11-卡死在开机界面问题"><a href="#MAC-Parallels-Desktop-Windows-11-卡死在开机界面问题" class="headerlink" title="MAC/Parallels Desktop Windows 11 卡死在开机界面问题"></a>MAC/Parallels Desktop Windows 11 卡死在开机界面问题</h1><p>还以为需要重新安装一次, 吓死了。。。。配置了那么久的Windows11。。。。这个问题其实是由于Windows软件还没关闭, 但是占用了比较多的CPU,然后直接将虚拟机关闭导致的(个人猜测), 这个问题解决起来比较简单, 但是却很重要, 找到MAC的<code>Activity Monitor</code>, 活动监视器, 类似于win上的任务管理器, 把Windows11给关闭掉,然后再打开就行了。</p><h1 id="AWK-相关使用"><a href="#AWK-相关使用" class="headerlink" title="AWK 相关使用"></a>AWK 相关使用</h1><p>AWK是一种文本处理工具,它可以帮助您从文本文件中提取和操作数据。下面是一些常见的AWK命令和示例：</p><p>1, 打印文件的某一列</p><p><code>awk &#39;&#123;print $1&#125;&#39; file.txt</code></p><p>这个命令会打印文件file.txt的第一列。</p><p>2, 计算文件的行数</p><p><code>awk &#39;END&#123;print NR&#125;&#39; file.txt</code></p><p>这个命令会计算文件file.txt的行数。</p><p>3, 查找匹配的行</p><p><code>awk &#39;/pattern/ &#123;print&#125;&#39; file.txt</code></p><p>这个命令会打印文件file.txt中包含“pattern”的行。</p><p>4, 计算文件的平均值</p><p><code>awk &#39;&#123;sum+=$1&#125; END &#123;print sum/NR&#125;&#39; file.txt</code></p><p>这个命令会计算文件file.txt的第一列的平均值。</p><p>5, 在文件中搜索并替换</p><p><code>awk &#39;&#123;gsub(/oldtext/, &quot;newtext&quot;); print&#125;&#39; file.txt</code></p><p>这个命令会在文件file.txt中查找所有的“oldtext”并替换为“newtext”。</p><p>6, 过滤掉某些行</p><p><code>awk &#39;!/pattern/&#39; file.txt</code></p><p>这个命令会过滤掉文件file.txt中包含“pattern”的行。</p><p>7, 打印文件中最长的行</p><p><code>awk &#39;&#123; if (length($0) &gt; max) &#123;max = length($0); longestLine = $0&#125;&#125; END &#123;print longestLine&#125;&#39; file.txt</code></p><p>这个命令会打印文件file.txt中最长的一行。</p><p>8, 按列排序</p><p><code>awk &#39;&#123;print $2, $1&#125;&#39; file.txt | sort</code></p><p>这个命令会按文件file.txt的第二列进行排序,并打印第一列和第二列。</p><h1 id="SED-的使用"><a href="#SED-的使用" class="headerlink" title="SED 的使用"></a>SED 的使用</h1><p><code>sed</code> 是一种流编辑器,用于从文本流中读取数据,对数据进行编辑和转换,然后将编辑后的结果输出到标准输出或文件中。<code>sed</code> 在命令行中使用,可以对文件或文本进行编辑操作。</p><p>以下是 <code>sed</code> 命令的语法：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">arduinoCopy <span class="selector-tag">code</span></span><br><span class="line">sed <span class="selector-attr">[选项]</span> <span class="string">&#x27;动作&#x27;</span> 文件名</span><br></pre></td></tr></table></figure><p>其中,<code>选项</code> 用于指定不同的操作方式,常用的选项包括：</p><p>&bull; <code>-n</code>：仅显示处理过的行<br>&bull; <code>-i</code>：直接修改文件内容</p><p><code>动作</code> 是 <code>sed</code> 命令的核心部分,用于指定要执行的操作,常用的操作包括：</p><p>&bull;  <code>s/old/new/g</code>：替换指定字符串,其中 <code>old</code> 为要替换的字符串,<code>new</code> 为替换后的字符串,<code>g</code> 表示全局替换。<br>&bull;  <code>p</code>：打印当前行<br>&bull;  <code>d</code>：删除当前行<br>&bull;  <code>a</code>：在当前行后添加一行文本<br>&bull;  <code>i</code>：在当前行前插入一行文本</p><p>以下是一些常见的 <code>sed</code> 命令示例：</p><p>1, 将文件中的所有 <code>foo</code> 替换为 <code>bar</code> 并输出到标准输出：</p><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/foo/bar/g&#x27;</span> <span class="keyword">file</span>.txt</span><br></pre></td></tr></table></figure><p>2, 删除文件中所有包含 <code>foo</code> 的行：</p><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/foo/d&#x27;</span> <span class="keyword">file</span>.txt</span><br></pre></td></tr></table></figure><p>3, 在文件的第 5 行后面添加一行文本 <code>Hello World</code> 并将结果写入新文件 <code>newfile.txt</code>：</p><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;5a\</span></span><br><span class="line"><span class="string">Hello World&#x27;</span> <span class="keyword">file</span>.txt &gt; newfile.txt</span><br></pre></td></tr></table></figure><p>4, 在文件的第 5 行前面插入一行文本 <code>Hello World</code> 并将结果写入新文件 <code>newfile.txt</code>：</p><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;5i\</span></span><br><span class="line"><span class="string">Hello World&#x27;</span> <span class="keyword">file</span>.txt &gt; newfile.txt</span><br></pre></td></tr></table></figure><p>以上是 <code>sed</code> 命令的一些常见用法示例,更多的用法可以通过查看 <code>sed</code> 的官方文档来了解。</p><h1 id="VIM-对于Python3第三方库的自动补全"><a href="#VIM-对于Python3第三方库的自动补全" class="headerlink" title="VIM 对于Python3第三方库的自动补全"></a>VIM 对于Python3第三方库的自动补全</h1><p>ycm实际是用的jedi的模块和功能来补全python,因此参考<a href="https://vi.stackexchange.com/questions/2403/vim-code-completion-for-python-3的意见,直接下载jedi并安装。">https://vi.stackexchange.com/questions/2403/vim-code-completion-for-python-3的意见,直接下载jedi并安装。</a></p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git clone --recursive https://github.<span class="keyword">com</span>/davidhalter/jedi-<span class="keyword">vim</span>.git ~/.<span class="keyword">vim</span>/bundle/jedi-<span class="keyword">vim</span></span><br></pre></td></tr></table></figure><p>然后在~/.vimrc中添加:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot;为了Python3的第三方库安装Jedi插件</span></span><br><span class="line">Plugin <span class="string">&#x27;davidhalter/jedi-vim&#x27;</span>   <span class="comment">&quot; 注意, 这个是需要放在Vundle下面的</span></span><br><span class="line"><span class="comment">&quot;===============================Jedi==================================</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;python3&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:loaded_youcompleteme</span> = <span class="number">1</span> <span class="comment">&quot; 判断如果是python3的话,就禁用ycmd。</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:jedi</span>#force_py_version = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:pymode_python</span> = <span class="string">&#x27;python3&#x27;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment">&quot;===============================Jedi===================================</span></span><br></pre></td></tr></table></figure><p>如果报错的话,就安装一下<code>jedi</code></p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> jedi</span><br></pre></td></tr></table></figure><p>补全效果可以参考如下所示, 用起来感觉还行(MACOS系统)</p><p><img src="/img/postImg/20_doNothing/jedi_vim_补全效果.png" alt=""></p><h1 id="FRF-频率响应函数"><a href="#FRF-频率响应函数" class="headerlink" title="FRF 频率响应函数"></a>FRF 频率响应函数</h1><p>FRF(Frequency Response Function)是一种用于描述系统对输入信号频率变化的响应特性的数学工具。它在信号处理、控制系统、结构动力学等领域中被广泛应用。</p><p>FRF可以用于分析线性系统,它描述了系统在不同频率下输入信号和输出响应之间的关系。通常,输入信号是一个单一频率的正弦波或复杂信号,而输出响应是系统对该输入信号的相应输出。FRF表示了在给定频率下,输出信号的幅度和相位与输入信号的幅度和相位之间的关系。</p><p>FRF通常表示为复数形式,包含两个部分：幅度响应和相位响应。幅度响应表示输出信号的幅度相对于输入信号的幅度的增益或衰减情况,而相位响应表示输出信号的相位相对于输入信号的相位的偏移。</p><p>FRF可以通过实验测量或数学模型来获取。在实验中,通过将系统激励于不同频率的输入信号,并测量输出信号的幅度和相位,可以得到系统的频率响应曲线。在数学建模中,可以使用系统的微分方程或传递函数来计算频率响应。</p><p>FRF在许多应用中都具有重要的作用。例如,在信号处理中,可以使用FRF来分析音频设备的频率响应,以优化音频信号的质量。在控制系统中,FRF可以用于设计和调整控制器,以使系统对不同频率的输入信号具有期望的响应。在结构动力学中,FRF可以用于分析结构物的振动特性,并评估其对外界激励信号的响应。</p><p>总之,FRF是一种描述系统对输入信号频率变化的响应特性的数学工具,它在各个领域中都具有广泛的应用。通过分析FRF,可以更好地理解和控制系统的频率行为。</p><p>未来有时间专门写一篇来介绍这部分；</p><h1 id="报错解决：AttributeError-module-‘lib’-has-no-attribute-‘OpenSSL-add-all-algorithms’"><a href="#报错解决：AttributeError-module-‘lib’-has-no-attribute-‘OpenSSL-add-all-algorithms’" class="headerlink" title="报错解决：AttributeError: module ‘lib’ has no attribute ‘OpenSSL_add_all_algorithms’"></a>报错解决：AttributeError: module ‘lib’ has no attribute ‘OpenSSL_add_all_algorithms’</h1><p>在shell中输入如下指令可解决这一问题</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pip</span> install cryptography==<span class="number">38</span>.<span class="number">0</span>.<span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="提示某程序已损坏"><a href="#提示某程序已损坏" class="headerlink" title="提示某程序已损坏"></a>提示某程序已损坏</h1><p>对于苹果电脑所需的设置</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">sudo xattr -r -d <span class="keyword">com</span>.apple.quarantine + 空格 + 在应用中程序找到APP拖入终端即可；</span><br></pre></td></tr></table></figure><h1 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h1><p>在Linux中，使用ifconfig命令确认本机IP。如果在终端窗口中运行ifconfig命令，则会在wp2s0的inet addr中显示其有线网络IP地址，而在enp3s0的inet addr中显示本机的无线网IP地址。</p><h1 id="tensorflow-install-MacOs"><a href="#tensorflow-install-MacOs" class="headerlink" title="tensorflow install (MacOs)"></a>tensorflow install (MacOs)</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># There is currently no official GPU support for MacOS.</span></span><br><span class="line">python3 -m pip <span class="keyword">install</span> tensorflow</span><br><span class="line"><span class="comment"># Verify the installation:</span></span><br><span class="line">python3 -c <span class="string">&quot;import tensorflow as tf; print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot;</span></span><br></pre></td></tr></table></figure><h1 id="mac-终端多个标签切换"><a href="#mac-终端多个标签切换" class="headerlink" title="mac 终端多个标签切换"></a>mac 终端多个标签切换</h1><p>如果在同一个终端窗口中打开了多个标签页，可以使用 Command (⌘) + Shift + ] 切换到下一个标签页，或使用 Command (⌘) + Shift + [ 切换到上一个标签页。</p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:source/_posts/doNothingButConnect.md</p><h1 id="unique-ptr独占型智能指针"><a href="#unique-ptr独占型智能指针" class="headerlink" title="unique_ptr独占型智能指针"></a>unique_ptr独占型智能指针</h1><p>unique_ptr是C++11标准库中的一种智能指针，它提供了一种独占所有权的方式，即一个unique_ptr对象只能拥有一个指针，并且当unique_ptr对象被销毁时，它所拥有的指针也会被自动释放。</p><p>unique_ptr对象始终是关联的原始指针的唯一所有者，实现了独享所有权的语义。一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权也从源指针转移给目标指针(源指针被置空)。拷贝一个unique_ptr将不被允许，因为如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，它们都认为自己拥有这块资源(所以都会企图释放)。因此unique_ptr是一个仅能移动的类型。当指针析构时，它所拥有的资源也被销毁。默认情况下，资源的析构是伴随着调用unique_ptr内部的原始指针的delete操作的。</p><h2 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h2><p>unique_ptr有如下几种初始化方式：</p><p>1) 裸指针直接初始化，但不能通过隐式转换来构造，因为unique_ptr构造函数被声明为explicit；</p><p>2) 允许移动构造，但不允许拷贝构造，因为unique_ptr是个只移动类型；</p><p>3) 通过make_unique构造，但这是C++14才支持的语法。需要注意的是：make_unique不支持添加删除器，或者初始化列表。</p><p>例如：</p><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frame</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  std::unique_ptr&lt;Frame&gt; f(<span class="keyword">new</span> Frame());              <span class="comment">// 裸指针直接初始化</span></span><br><span class="line">  std::unique_ptr&lt;Frame&gt; f1 = <span class="keyword">new</span> Frame();            <span class="comment">// Error，explicit禁止隐式初始化</span></span><br><span class="line">  std::unique_ptr&lt;Frame&gt; f2(f);                       <span class="comment">// Error，禁止拷贝构造函数</span></span><br><span class="line">  std::unique_ptr&lt;Frame&gt; f3 = f;                      <span class="comment">// Error，禁止拷贝构造函数</span></span><br><span class="line">  f1 = f;                                             <span class="comment">// Error，禁止copy赋值运算符重载</span></span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;Frame&gt; f4(std::move(<span class="keyword">new</span> Frame()));      <span class="comment">// 移动构造函数</span></span><br><span class="line">  std::unique_ptr&lt;Frame&gt; f5 = std::move(<span class="keyword">new</span> Frame());     <span class="comment">// Error，explicit禁止隐式初始化</span></span><br><span class="line">  std::unique_ptr&lt;Frame&gt; f6(std::move(f4));               <span class="comment">// 移动构造函数</span></span><br><span class="line">  std::unique_ptr&lt;Frame&gt; f7 = std::move(f6);              <span class="comment">// move赋值运算符重载</span></span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;Frame[]&gt; f8(<span class="keyword">new</span> Frame[<span class="number">10</span>]());       <span class="comment">// 指向数组</span></span><br><span class="line"></span><br><span class="line">  auto f9 = std::make_unique&lt;Frame&gt;();                <span class="comment">// std::make_unique来创建，C++14后支持</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>工厂函数</p><p>作为工厂函数的返回类型：</p><p>1) 工厂函数负责在堆上创建对象，但是调用工厂函数的用户才会真正去使用这个对象，并且要负责这个对象生命周期的管理。所以使用unique_ptr是最好的选择。这正好是std::unique_ptr擅长的地方，因为调用者获得了工厂返回的资源的所有权，当unique_ptr析构时，它会自动销毁所拥有的指针；</p><p>2) unique_ptr转为shared_ptr很容易，作为工厂函数本身并不知道用户希望所创建的对象的所有权是专有的还是共享的，返回unique_ptr时调用者可以按照需要做变换。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://blog.csdn.net/robinvista/article/details/69415962">机器人中的速度概念 —robinvista</a></p><p>[2] <a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E8%A7%92">欧拉角—维基百科</a></p><p>[3] <a href="https://blog.csdn.net/llwy1428/article/details/92834705">谷歌浏览器截取长屏幕(全屏截图)</a></p><p>[4] <a href="https://blog.csdn.net/lejustdoit/article/details/106384508">Linux命令之大文件分割</a></p><p>[5] <a href="https://blog.csdn.net/m0_38126105/article/details/88366970">vim 修改文件显示只读问题解决</a></p><p>[6] <a href="https://blog.csdn.net/qq_38410730/article/details/105725663">【C++】unique_ptr独占型智能指针详解</a></p>]]></content>
      
      
      <categories>
          
          <category> TOOLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> robotics </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运动控制系统简介</title>
      <link href="/2020/10/03/archived_motionControl/"/>
      <url>/2020/10/03/archived_motionControl/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#运动控制">运动控制</a><ul><li><a href="#电机控制与运动控制">电机控制与运动控制</a></li><li><a href="#伺服电机的构成">伺服电机的构成</a></li><li><a href="#运动控制系统的典型构成">运动控制系统的典型构成</a></li></ul></li><li><a href="#位置控制">位置控制</a><ul><li><a href="#周期同步位置模式csp">周期同步位置模式(CSP)</a></li><li><a href="#轮廓位置模式-ppm">轮廓位置模式 (PPM)</a></li><li><a href="#位置模式pm">位置模式(PM)</a></li></ul></li><li><a href="#伺服系统相关概念">伺服系统相关概念</a><ul><li><a href="#交流伺服系统的组成">交流伺服系统的组成</a><ul><li><a href="#工作在位置控制模式时的系统组成及说明">工作在位置控制模式时的系统组成及说明</a></li><li><a href="#工作在速度控制模式时的系统组成">工作在速度控制模式时的系统组成</a></li><li><a href="#工作在转矩控制模式时的系统组成及说明">工作在转矩控制模式时的系统组成及说明</a></li></ul></li><li><a href="#伺服电动机与编码器">伺服电动机与编码器</a><ul><li><a href="#编码器">编码器</a><ul><li><a href="#增量编码器">增量编码器</a></li><li><a href="#绝对值编码器">绝对值编码器</a></li></ul></li></ul></li><li><a href="#伺服驱动器的结构与原理">伺服驱动器的结构与原理</a></li><li><a href="#电子齿轮比设计">电子齿轮比设计</a></li><li><a href="#通讯方式">通讯方式</a></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在做伺服电机方面工作,接触到的一些基础的知识,感觉还是非常值得去了解这些内容的,因此将自己从网络上,以及一些手册里的内容,放到这里。</p><h1 id="运动控制"><a href="#运动控制" class="headerlink" title="运动控制"></a>运动控制</h1><p><strong>运动控制</strong>主要分两个方向,一个是运动控制,通常用于机械领域；另一个就是过程控制,通常使用于化工领域。而运动控制指的是一种起源于早期的伺服系统,基于电动机的控制,以实现物体对角位移、转矩、转速等等物理量改变的控制。</p><h2 id="电机控制与运动控制"><a href="#电机控制与运动控制" class="headerlink" title="电机控制与运动控制"></a>电机控制与运动控制</h2><p><strong>电机控制</strong>(这里指伺服电机)主要关注的是控制单个电机的转距、速度、位置中的一个或多个参数达到给定值。而<strong>运动控制</strong>主要关注点在于协调多个电机,完成指定的运动(合成轨迹、合成速度),比较着重轨迹规划、速度规划、运动学转换。</p><p><strong>运动控制</strong>往往是针对产品而言的,包含机械、软件、电气等模块,例如机器人、无人机、运动平台等等,是对机械运动部件的位置、速度等进行实时的控制管理,使其按照预期的运动轨迹和规定的运动参数进行运动的一种控制。</p><p>两者有部分内容是重合的：位置环/速度环/转距环可以在电机的驱动器中实现,也可以在运动控制器中实现.</p><h2 id="伺服电机的构成"><a href="#伺服电机的构成" class="headerlink" title="伺服电机的构成"></a>伺服电机的构成</h2><p>伺服电机的装置由下列三者构成:</p><p>1,发出动作指令的”指示装置”(控制器,Controller),</p><p>2,依照指示装置的指示讯号与回馈讯号下等指令使电机动作的”控制装置”(伺服放大器),</p><p>3,以及将由伺服放大器而来的电力供给驱动控制对象和侦测其状态的”驱动、感测装置”。</p><h2 id="运动控制系统的典型构成"><a href="#运动控制系统的典型构成" class="headerlink" title="运动控制系统的典型构成"></a>运动控制系统的典型构成</h2><p>1, 开环系统(电机：步进电机；驱动器：脉冲分配,电流放大)</p><p>2,半闭环系统(电机：直流伺服电机、交流伺服电机；驱动器：电流放大,位置反馈控制)</p><p>3,半闭环系统(直流伺服电机、交流伺服电机；驱动器：速度反馈控制,电流放大；运动控制器：运动规划,速度指令,位置反馈取自电机轴)</p><p>4, 全闭环系统(驱动器：速度反馈控制,电流放大；运动控制器：运动规划,速度指令,位置反馈取自负载)</p><p>全闭环伺服系统可以消除机械传动带来的误差,而半闭环系统只能补偿部分误差,因此,半闭环伺服系统的精度比全闭环伺服系统的精度要低一些。由于采用了位置检测装置,所以全闭环系统的位置精度在其他因素确定了之后,主要取决于检测装置的分辨率和精度。</p><p>注意半闭环系统2与3的区别。驱动器如果工作在位置模式,运动控制器就只做位置轨迹的规划(Trajectory generator),每个通信周期发送目标位置到驱动器。驱动器接收到设定位置后,与当前位置比较,并依据控制器-驱动器通信周期与驱动器位置环周期进行线性或者非线性插值,将插值作为每个位置环周期的“设定位置”。</p><p>假设驱动器位置环周期是125us,控制器和驱动器通信周期为 2ms,当前位置为 0,目标位置为 1mm,那么接下来 16 个周期驱动器位置环的“设定位置”就依次为：0.0625mm,0.125mm, 0.1875mm, 0.25mm,…,1mm. 如果没有插值,那么接下来驱动器的第 1 个周期的设定位置就是 1mm,驱动器在第 125us时,位置为 1mm,在 2-16 个周期,设定位置维持不变,相当于电机停止,直到第 2ms,接收到新的“给定位置”。由于间隔仅为 2ms,电机并不会真的停止,而是表现为顿挫感,转动不流畅。</p><p>驱动器如果工作在速度模式,那么控制器就不仅做位置曲线的规划,还要完成位置环的调节。此时NC周期与位置环周期相等,不必插值。伺服驱动器的位置环被忽略,其速度环直接接受上层给出的”设定速度”。</p><h1 id="位置控制"><a href="#位置控制" class="headerlink" title="位置控制"></a>位置控制</h1><p>位置控制主要有三种模式：周期同步位置模式 (CSP),轮廓位置模式 (PPM),位置模式 (PM)。</p><h2 id="周期同步位置模式-CSP"><a href="#周期同步位置模式-CSP" class="headerlink" title="周期同步位置模式(CSP)"></a>周期同步位置模式(CSP)</h2><p>周期同步位置模式 (Cyclic synchronous position mode) ,与轮廓位置模式 (Profifile Position Mode) 不同,其轨迹发生器位于控制器端,而非驱动器内。在该模式下,控制器只需要周期性的下发目标位置即可(与位置插补模式的原理相类似),而且可以设置附加的速度前馈 (Velocity offffset) 或转矩前馈 (Torque offffset),即轮廓位置模式的 Trajectory Generator 在驱动器内,周期同步位置模式的 Trajectory Generator 在控制器内,而位置模式(Position Mode)、电子手轮模式(Master Encoder Mode)、脉冲/方向模式(Step Direction Mode)则不需要轨迹生成器。</p><h2 id="轮廓位置模式-PPM"><a href="#轮廓位置模式-PPM" class="headerlink" title="轮廓位置模式 (PPM)"></a>轮廓位置模式 (PPM)</h2><p>轮廓位置模式下,驱动器接收主站发送来的目标位置指令,在驱动器内部根据速度、加速度规划参数设置进行轨迹规划。例如：应用程序要求伺服轴以设定的速度、加速度运动到某个目标位置,驱动器接到这个指令后,在内部的轨迹生成器中计算出每个 NC 周期(比如：1ms)伺服轴应该到达的位置,然后发送给位置环去执行。</p><h2 id="位置模式-PM"><a href="#位置模式-PM" class="headerlink" title="位置模式(PM)"></a>位置模式(PM)</h2><p>位置需求值可直接设定。位置模式允许无轮廓线定位,即目标位置被立即设置为位置控制环的一个新的设定值。位置模式是一种有用的操作模式,在这种情况下,轴作为一个隶属轴,由没有大跳跃的渐进式位置设定值所控制。因此,不需要路径生成器。累进设定值的例子是模拟设定值电压。不产生路径的特殊工作模式是主编码器模式,从轴跟随来自外部编码器的信号脉冲 (例如主轴) 或步进方向模式,步进电机驱动的每个脉冲指令对应一个小的旋转角度。另外的操作模式允许运行运动控制器而不接收在线命令。相反,使用模拟电压信号或信号脉冲作为命令值。这些传入的信号被转换成设定值,直接馈入相应的控制回路而没有一个轮廓或轨迹被产生。</p><h1 id="伺服系统相关概念"><a href="#伺服系统相关概念" class="headerlink" title="伺服系统相关概念"></a>伺服系统相关概念</h1><p>伺服系统通常由三个反馈系统构成,由外到内分别是位置环、速度环和电流环。调整时,内环的响应性要高于外环的响应性,如果不遵守该原则,则会使系统响应性变差或产生振动。<strong>电流环调节器参数仅与电机参数有关</strong>,相同电机的电流环参数确定后,如果负载改变,只需调整速度环调节器参数和位置环调节器参数即可,电流环调节器参数不用再做调整。如下所示为应用在机器人上的三环控制简图(非驱控一体)</p><div align="center"> <img src="/img/postImg/28_motionControl/threeLoopControl.svg" width="100%" height="40%"> </div><p>在交流伺服控制系统中,交流伺服电机运行状态的优劣取决于位置环、速度环和电流环三环控制器设计的好坏。交流伺服控制系统有两种,一种是位置伺服控制系统,包括电流控制器、速度控制器和位置控制器；另一种是速度伺服控制系统,只包括电流控制器和速度控制器。因此选取合适的参数,能够在一定程度上提高系统的快速性、稳定性、准确性。</p><p>在电流控制器、速度控制器和位置控制器中,电流控制器是最关键、重要的环节,因为不管是速度还是位置控制,最后都要转化成对交流电机电流的控制。速度环的作用是保证速度指令与交流电机的实际转速相同,从而消除负载转矩扰动等因素对交流电机的影响,通过交流电机的实际转速和输入的速度指令相比较,速度控制器利用其差值直接产生指令控制电流,并与电流指令共同作用,控制交流电机匀速、加速、减速旋转,从而达到交流电机实际转速与控制指令保持一致。位置环的作用是生成交流电机的速度指令,并能够使交流电机准确的跟踪、定位。交流电机的实际位置与设定的目标位置相比较,位置控制器利用其偏差生成交流电机的速度指令。当交流电机启动后,在距离目标位置较大的区域,位置控制器产生最大速度指令,从而使交流电机加速运动后以最大速度恒速运行,在距离较小的区域,位置控制器生成逐次减小的速度控制指令,从而使交流电机减速运动,直至到目标位置后静止。</p><p>在清能德创的伺服驱动说明书上,有提到过,电流环调节器参数仅与电机参数有关,因此在调整三环控制的时候,仅需要考虑速度环和运动环即可, 实际上还是需要有经验的人去调整电流环参数的。</p><h2 id="交流伺服系统的组成"><a href="#交流伺服系统的组成" class="headerlink" title="交流伺服系统的组成"></a>交流伺服系统的组成</h2><p>交流伺服系统是以交流伺服电动机为控制对象的自动控制系统, 它主要由伺服控制器、伺服驱动器和伺服电动机组成。交流伺服系统 主要有3种控制模式,分别是位置控制模式、速度控制模式和转矩控制模式。在不同的模式下,系统工作原理略有不同。交流伺服系统的控制模式可通过设置伺服驱动器的参数来改变。</p><h3 id="工作在位置控制模式时的系统组成及说明"><a href="#工作在位置控制模式时的系统组成及说明" class="headerlink" title="工作在位置控制模式时的系统组成及说明"></a>工作在位置控制模式时的系统组成及说明</h3><p>当交流伺服系统工作在位置控制模式时,能精确控制伺服电动机的转数,因此可以精确控制执行部件的移动距离,即可对执行部件进行运动定位控制。</p><p>伺服控制器发出控制信号和脉冲信号给伺服驱动器,伺服驱动器输出U、V、W三相电源电压给伺服电动机,驱动电动机工作,与电动机同轴旋转的编码器会将电动机的旋转信息反馈给伺服驱动器,如电动机每旋转一周编码器会产生一定数量的脉冲送给驱动器。伺服控制器输出的脉冲信号用来确定伺服电动机的转数,在驱动器中,该脉冲信号与编码器送来的脉冲信号进行比较,若两者相等,表明电动机旋转的转数已达到要求,电动机驱动的执行部件已移动到指定的位置。控制器发出的脉冲个数越多,电动机会旋转更多的转数。</p><h3 id="工作在速度控制模式时的系统组成"><a href="#工作在速度控制模式时的系统组成" class="headerlink" title="工作在速度控制模式时的系统组成"></a>工作在速度控制模式时的系统组成</h3><p>当交流伺服系统工作在速度控制模式时,伺服驱动器无需输入脉冲信号也可正常工作,故可取消伺服控制器,此时的伺服驱动器类似于变频器,但由于驱动器能接收伺服电动机的编码器送来的转速信息,不但能调节电动机转速,还能让电动机转速保持稳定。</p><p>伺服驱动器输出U、V、W三相电源电压给伺服电动机,驱动电动机工作,编码器会将伺服电动机的旋转信息反馈给伺服驱动器。电动机旋转速度越快,编码器反馈给伺服驱动器的脉冲频率就越高。操作伺服驱动器的有关输入开关,可以控制伺服电动机的启动、停止和旋转方向等。调节伺服驱动器的有关输入电位器,可以调节电动机的转速。</p><h3 id="工作在转矩控制模式时的系统组成及说明"><a href="#工作在转矩控制模式时的系统组成及说明" class="headerlink" title="工作在转矩控制模式时的系统组成及说明"></a>工作在转矩控制模式时的系统组成及说明</h3><p>当交流伺服系统工作在转矩控制模式时,伺服驱动器无需输入脉冲信号也可正常工作,故可取消伺服控制器,通过操作伺服驱动器的输入电位器,可以调节伺服电动机的输出转矩(又称扭矩,即转力)。</p><h2 id="伺服电动机与编码器"><a href="#伺服电动机与编码器" class="headerlink" title="伺服电动机与编码器"></a>伺服电动机与编码器</h2><p>交流伺服系统的控制对象是伺服电动机,编码器通常安装在伺服电动机的转轴上,用来检测同服电动机的转速、转向和位置等信息。</p><h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p>编码器旋转一周产生的脉冲个数称为分辨率。</p><h4 id="增量编码器"><a href="#增量编码器" class="headerlink" title="增量编码器"></a>增量编码器</h4><p>增量编码器的特点是每旋转一定的角度或移动一定的距离会产生一个脉冲,即输出脉冲随位移增加而不断增多。坑的是不能掉电保存,有段时间用这个编码器增加了不少自己的工作量。。。。。</p><h4 id="绝对值编码器"><a href="#绝对值编码器" class="headerlink" title="绝对值编码器"></a>绝对值编码器</h4><p>增量编码器通过输出脉冲的频率反映电动机的转速,通过A、B相脉冲的相位关系反映电动机的转向,故检测电动机转速和转向非常方便。绝对值编码器可以解决增量编码器测位时存在的问题,它可分为 单圈绝对值编码器和多圈绝对值编码器。</p><p>单圈绝对值编码器只能对一个圆周进行定位,超过一个圆周定位 就会发生重复,而多圈绝对值编码器可以对多个圆周进行定位。</p><h2 id="伺服驱动器的结构与原理"><a href="#伺服驱动器的结构与原理" class="headerlink" title="伺服驱动器的结构与原理"></a>伺服驱动器的结构与原理</h2><p>伺服驱动器又称伺服放大器,是交流伺服系统的核心设备。伺服驱动器的品牌很多,常见的有三菱、安川、松下和三洋等。 伺服驱动器的功能是将工频(50Hz或60Hz)交流电源转换成幅度和频率均可变的交流电源提供给伺服电动机。当伺服驱动器工作在速度控制模式时,通过控制输出电源的频率来对电动机进行调速;当工作在转矩控制模式时,通过控制输出电源的幅度来对电动机进行转矩控制;当工作在位置控制模式时,根据输入脉冲来决定输出电源的通断时间。</p><p>上位机通过发送脉冲到伺服驱动器,来实现控制。在这种方式下,用脉冲频率来控制速度,用脉冲个数来控制位置。同样,伺服驱动器也会发送脉冲数,来告诉上位机,伺服电机的位置和速度。比如,我们约定伺服电机10000个脉冲旋转一圈,那么,当上位机发送10000个脉冲,伺服电机旋转一圈,实现位置控制。如果上位机在一分钟内发完这10000个脉冲,那么伺服电机的速度就是1r/min,如果实在一秒钟内发完,那么伺服电机的速度就是1r/s,也就是60r/min。</p><p>低端PLC,数控系统,以及各种单片机系统一般都是采用这种模式,简单易行,成本低廉。很显然,当伺服轴数增加,这种控制方式的缺点就会显现出来,上位机硬件成本会增加,配线会很复杂,而且现场EMC不好的话,脉冲极易丢失。所以,这种模式一般是在四轴以下,所以,大部分PLC的脉冲控制轴数都在两轴或是三轴,极少部分PLC可以实现四轴。</p><p>不想介绍伺服驱动器的主电路,因为这个和自己读研的方向就差不多。。。。。问题是那会就懒得学,哈哈哈。。。。</p><h2 id="电子齿轮比设计"><a href="#电子齿轮比设计" class="headerlink" title="电子齿轮比设计"></a>电子齿轮比设计</h2><p>在实际应用中, 电动机与其他机械传动装置连接时, 电动机每转动一圈, 将转换为相应的位移, 带动负载运动。 位置指令通常是由上位机产生的, 是具有一定频率和个数的脉冲。 当指令脉冲当量和位置反馈脉冲当量不一致时, 采用电子齿轮的方法来进行调节是必需的, 它的好处可以用一个例子说明。</p><p>如图所示, 位置环中没有电子齿轮设计时, 要将工件移动 10mm, 上位机要做如下处理：</p><div align="center"> <img src="/img/postImg/28_motionControl/电子齿轮比.png" width="100%" height="40%"> </div><p>① 电动机转 1 圈为 6mm, 移动 10mm 需要 1. 6666 圈；</p><p>② 转动 1 圈需要 10000 个脉冲, 转动 1. 6666 圈, 一共需要 16666 个脉冲；</p><p>③ 发出 16666 个指令脉冲。</p><p>上位机在每次送出指令脉冲之前, 都要进行上述 “变换”, 受限于机械结构, 并且相应地增加了运算量。位置环中使用电子齿轮设计, 事先根据机械条件, 设定好电子齿轮比分子和分母的值, 参数一旦设定好, 只要机械条件不变, 就无需再次修改。 由于电子齿轮功能的存在, 上位机不用再进行 “变换” 指令, 彻底与机械结构脱离关系。 具体方法是：</p><p>① 首先确定机械要移动 1μm, 需要多少个脉冲, 由转 1 圈移动 6mm 计算出转动 10 / 6 个脉冲可以移动 1μm；</p><p>② 接下来设定电子齿轮比, 电子齿轮分子为 10, 分母为 6；</p><p>③ 最后在上位机选定脉冲当量为 1, 即 1 个脉冲代表移动 1μm, 这样要移动 10mm, 上 位机按指令单位计算出要发送 10000 个脉冲。</p><p>这样, 上位机不再需要额外计算, 只要把插补器送出的值折算成脉冲当量值后发出脉冲即可。根据上例, 可以定义出电子齿轮比。 假定相对于每一脉冲信号的机械运动部件的位移单位为 a 微米, 即脉冲当量为 a(a 一般为 1 或者 10、 100、 1000 等。), 在该机械结构下, 电动机转动 1 圈 (有 P 个反馈脉冲) 需要移动 x 微米, 则电子齿轮比 K 为:</p><p>K = A/B =aP/x</p><p>实际应用中, K 一般取值范围为 0. 01 ～ 100, 如果根据 a、 P、 x 计算出的 K 超出了这个范围, 伺服单元不能正常动作, 这时需要变更机械构成, 或者变动指令单位 a。</p><p>电子齿轮是位置环中的一个特殊功能, 它通常放在位置环的给定通道入口处, 齿轮比值 K 的变化实际上只是调节了位置指令脉冲频率, 从而改变了电动机的转速。 因此改变齿轮比 值不会影响位置环的性能。</p><h2 id="通讯方式"><a href="#通讯方式" class="headerlink" title="通讯方式"></a>通讯方式</h2><p>通讯方式就是专门为解决脉冲方式的不足而产生的,已经成为一种发展趋势,他把脉冲数和脉冲频率通过通讯的方式,发送给伺服驱动器,这种方式不但可以传递伺服电机的位置信息,还能传递各种状态信息,比如伺服电机的电流,扭矩以及伺服驱动器的故障代码等等,很显然,当轴数多的时候,这种方式的优势不言而喻。</p><p>由于运动控制的特殊性,所以不同的厂家都推出自己的运动控制总线,既有开放的,也有封闭的,比如CANopen,以及在此基础上开发的CANmotion和CANlink,MECHATROLINK-II,CCLink等等。随着工业以太网技术的发展,基于以太网的运动控制总线也应运而生,比如<strong>EtherCAT</strong>,ProfinetNet,MECHATROLINK-III等等。还有基于光纤的SERCOS,SSCNETⅢ/H等等。虽然通讯的形式繁多,但他们解决的一般都是实时性问题,因为对于运动控制来说,实时性是非常重要的。从应用开发的角度来说,脉冲和通讯是没有区别的,只是信号传递的形式发生了变化。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1,<a href="https://home.cnblogs.com/u/21207-iHome/">XXX已失联</a></p><p>2,<a href="https://www.zhihu.com/people/gk-auto">gk-auto</a></p><p>3, CoolDrive R 系列伺服驱动器用户说明书</p><p>4, <a href="https://zh.wikipedia.org/wiki/%E4%BC%BA%E6%9C%8D%E9%A6%AC%E9%81%94">伺服马达—维基百科</a></p><p>5, 《交流伺服系统设计指南》——孙与等著</p>]]></content>
      
      
      <categories>
          
          <category> ROBOTICS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> robot </tag>
            
            <tag> control </tag>
            
            <tag> motor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim 学习笔记(二)</title>
      <link href="/2020/09/28/archived_vim2020/"/>
      <url>/2020/09/28/archived_vim2020/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#powershell下使用vim">PowerShell下使用vim</a><ul><li><a href="#宏的读取与执行">宏的读取与执行</a></li><li><a href="#为不同类型定制样式">为不同类型定制样式</a></li></ul></li><li><a href="#格式化代码">格式化代码</a><ul><li><a href="#保持相同的缩进层次">保持相同的缩进层次</a></li><li><a href="#上一行的缩进层次保持到下一行">上一行的缩进层次保持到下一行</a></li><li><a href="#cindent-cindent">cindent Cindent</a></li><li><a href="#indentexpr">Indentexpr</a></li></ul></li><li><a href="#代码块快速格式化">代码块快速格式化</a></li><li><a href="#部分插件介绍">部分插件介绍</a></li><li><a href="#技巧">技巧</a><ul><li><a href="#手动载入插件">手动载入插件</a></li></ul></li><li><a href="#创建分割窗口">创建分割窗口</a><ul><li><a href="#窗口之间的切换">窗口之间的切换</a></li><li><a href="#关闭窗口">关闭窗口</a></li></ul></li><li><a href="#正则表达式">正则表达式</a><ul><li><a href="#元字符">元字符</a><ul><li><a href="#表示数量的元字符">表示数量的元字符</a></li><li><a href="#表示位置的符号">表示位置的符号</a></li><li><a href="#懒惰模式">懒惰模式</a></li></ul></li></ul></li><li><a href="#跳转">跳转</a></li><li><a href="#后记">后记</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前记的笔记已经在日常生活中大量的使用了,但是还是有很多技巧值得自己去探索,虽然下面的笔记中会经常用到,鉴于笔记的完整性,还是记录下来。这里的笔记很多源自于《vim实用技巧》</p><h1 id="PowerShell下使用vim"><a href="#PowerShell下使用vim" class="headerlink" title="PowerShell下使用vim"></a>PowerShell下使用vim</h1><p>第一步,以管理员的方式打开<code>powershell</code>。</p><p>第二步,输入 <code>Set-ExecutionPolicy RemoteSigned</code>, 选择<code>Y</code>。</p><p><img src="/img/postImg/42_vim/powershell_Set.png" style="zoom:60%;" /></p><p>第三步,输入命令</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">new</span>-<span class="keyword">item</span> -path $profile -itemtype <span class="built_in">file</span> -force</span><br></pre></td></tr></table></figure><p>创建配置文件。先切换到给出的地址,然后用记事本编辑(复制地址的时候,可以先选择,然后Contrl+ins)</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">cd C:<span class="string">\Users\yourComputerName\Documents\windowsPowerShell</span></span><br><span class="line">notepad .<span class="string">\Microsoft.PowerShell_profile.psl</span></span><br></pre></td></tr></table></figure><p><img src="/img/postImg/42_vim/usingNotepadOpenPSLFile.png" style="zoom:60%;" /></p><p>第四步,在打开的文本中输入如下内容</p><figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set-alias</span> <span class="string">vim</span> <span class="string">&quot;D:\Vim\vim82\vim.exe&quot;</span> <span class="comment"># 此处为vim的安装路径</span></span><br><span class="line"></span><br><span class="line"><span class="string">Function</span> <span class="string">Edit-Profile</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">vim</span> $<span class="string">profile</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="string">Function</span> <span class="string">Edit-Vimrc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">vim</span> $<span class="string">HOME</span>\<span class="string">_vimrc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加结束后,重启powershell即可。也只有windows可以这么折腾人了。</p><h2 id="宏的读取与执行"><a href="#宏的读取与执行" class="headerlink" title="宏的读取与执行"></a>宏的读取与执行</h2><p>宏允许把一段修改序列录制下来,用于之后的重复操作。 q 键既是“录制”按钮,也是“停止”按钮。为了录制按键操作,一开始需要按 q{register｝,从而指定一个用于保存宏的寄存器。当状态栏中出现“记录中”时,表示录制已经开始。此后,执行的每一条命令都将被宏捕获,直到再次按下 q 键停下为止。<br>可以用@{register}命令执行指定寄存器的内容,也可以用 @@ 来重复最近调用过的宏。</p><h2 id="为不同类型定制样式"><a href="#为不同类型定制样式" class="headerlink" title="为不同类型定制样式"></a>为不同类型定制样式</h2><p>vim 有很多的选项可以让我们来定制自己习惯的行为,完整的列表可以参考 :h option-list。可以通过在vimrc中通过:set命令来改变它们。 不同的语言或者是文档,由于类型不同,排版会有所差异。比如,对Ruby文件采用两个空格的缩进,而对JavaScript文件采用4列宽度的制表符。可以将下面的代码放到配置文件vimrc中：</p> <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&quot;autocmd&quot;</span>)</span><br><span class="line">        <span class="keyword">filetype</span> <span class="keyword">on</span></span><br><span class="line">        <span class="keyword">autocmd</span> FileType <span class="keyword">ruby</span> <span class="keyword">setlocal</span> <span class="keyword">ts</span>=<span class="number">2</span> <span class="keyword">sts</span>=<span class="number">2</span> <span class="keyword">sw</span>=<span class="number">2</span> et</span><br><span class="line">        <span class="keyword">autocmd</span> FileType javascript <span class="keyword">setlocal</span> <span class="keyword">ts</span>=<span class="number">4</span> <span class="keyword">ts</span>=<span class="number">4</span> <span class="keyword">sts</span>=<span class="number">4</span> <span class="keyword">sw</span>=<span class="number">4</span> noet</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h1 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h1><p> 开始介绍折叠功能之前, 需要将折叠选项功能打开:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> foldenable</span><br></pre></td></tr></table></figure><p>打开后, Vim就会注意到在普通模式下输入的折叠命令. 用来打开和关闭折叠的命令有很多个, 主要的有:</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">zc:</span> 关闭一个折叠 </span><br><span class="line"><span class="symbol">zo:</span> 打开一个折叠</span><br><span class="line"><span class="symbol">zM:</span> 关闭所有的折叠 </span><br><span class="line"><span class="symbol">zR:</span> 打开所有的折叠</span><br><span class="line"><span class="symbol">zf:</span> 可视模式下进行折叠(自己用的比较多)</span><br><span class="line"><span class="symbol">zd:</span> 删除折叠</span><br></pre></td></tr></table></figure><h1 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h1><p>在对代码进行格式化时经常需要考虑很多因素. 每一种语言都有自己的语法规则, 还有些语言对格式非常依赖. 在有些情况下, 程序员需要按照公司给出的规定来格式化代码.虽然具体的格式化细节不尽相同, 但是它们都遵循一些基本的规则, 也就是说, 用户只需要关心不同的地方即可. 在大部分情况下, 格式化规则的修改可以通过一系列的 Vim选项来设置, 在这些选项当中, 比较重要的有以下几个:</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">formatoptions: 这个选项负责特定格式的设置。</span></span><br><span class="line"></span><br><span class="line"><span class="section">comments: 什么是注释, 以及如何对它们进行格式化 </span></span><br><span class="line"></span><br><span class="line"><span class="section">(no)expandtab: 用空格代替制表符</span></span><br><span class="line"></span><br><span class="line"><span class="section">softtabstop: 一个制表符可以用多少个空格来代替</span></span><br><span class="line"></span><br><span class="line"><span class="section">tabstop: 一个制表符的宽度</span></span><br></pre></td></tr></table></figure><p>通过这些选项, 用户几乎可以设置与缩进相关的方方面面. 但是光有这些还不足够, 用户仍然需要告诉 Vim 是否需要自动缩进, 还是由用户手动完成缩进. 如果用户希望由 Vim来完成缩进, 可以通过 4 种方法来完成。</p><h2 id="保持相同的缩进层次"><a href="#保持相同的缩进层次" class="headerlink" title="保持相同的缩进层次"></a>保持相同的缩进层次</h2><p>Autoindent 是缩进代码最简单的方式. 它的功能仅仅是与上一行保持相同的缩进层次. 所以说, 如果当前行缩进了 4 个空格, 按下 Enter 后插入的空行也会缩进 4 个空格. 至于什么时候修改缩进的层次则完成取决于用户. 这种缩进方式适用于若干行需要保持相同缩进层次的语言. 打开 autoindent 的命令是 :set autoindent 或 :set ai.</p><h2 id="上一行的缩进层次保持到下一行"><a href="#上一行的缩进层次保持到下一行" class="headerlink" title="上一行的缩进层次保持到下一行"></a>上一行的缩进层次保持到下一行</h2><p>Smartindent 比 autoindent 稍微智能一些. 它仍然可以让上一行的缩进层次保持到下一行, 但用户无需手动修改缩进层次. Smartindent 可以识别出 C 语言的大部分结构, 并根据它们来决定何时增加/减少缩进层次. 由于许多 编程语言都或多或少地都继承了 C 语言的语法, 所以 smartindent 也可以应用到其他语言. 打开 smartindent 可以用:set smartindent 或 :set si。</p><h2 id="cindent-Cindent"><a href="#cindent-Cindent" class="headerlink" title="cindent Cindent"></a>cindent Cindent</h2><p>Cindent 经常被称为 clever indent(聪明的缩进) 或 configurable indent(可配置的缩进), 这是因为与前面介绍的两种缩进相比, 它的可配置性更强. 有三种设置选项:</p><p>cinkeys: 这个选项包含了一个列表, 列表中的各项之间用逗号分开, Vim 可以根据列表中的项来改变缩进 层次. 一个例子是: :set cinkeys=”0{,0},0#,:”, 意思是说无论何时碰到一个以 {, 或 }, 或 # 作为开 始的行, 或者是以 : 作为结束的行 (很多语言的 switch 结构都用到了 :), Vim 都要再缩进一层. cinkeys 的默认值是 “0{, 0}, 0), :, 0#, !^F, o, O, e”,</p><p>cinoptions: 这个选项包含了所有的, 专门用于 cindent 的选项. 它是一个各项之间由逗号分开的列表, 通 过这个列表可以设置大量的选项. 一个例子是 cinoptions=”&gt;2,{3,}3”, 意思是说在正常的缩进之上, 再额外添加两个空格, 另外, 在 { 与 } 的左边添加三个空格, 以便与前一行作比较。</p><p>cinwords: 这个选项包含的关键词会让Vim在下一行增加缩进. 一个例子是:set cinwords=”if,else,do,while 这同时也是它的默认值。</p><h2 id="Indentexpr"><a href="#Indentexpr" class="headerlink" title="Indentexpr"></a>Indentexpr</h2><p>Indentexpr 是最灵活的缩进选项, 但同时也是最复杂的. 使用 indentexpr 时, 它会对一个表达式求值, 然后计算出一行的缩进. 因此, 用户写出的表达式必须能被 Vim求值。这里就不举例了。。。。</p><h1 id="代码块快速格式化"><a href="#代码块快速格式化" class="headerlink" title="代码块快速格式化"></a>代码块快速格式化</h1><p>缩进选项设置完毕后, 用户可能想根据新设置的选项更新一下代码的格式. 为了更新代码, 只需要告诉 Vim 重新缩进第一行到最后一行, 具体的命令是:<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">1G</span>=G</span><br></pre></td></tr></table></figure><br>如果把命令拆开来看, 各个部分的意思是:<br>1G: 跳到文件的第一行 (也可以使用 gg),=: 根据格式化的配置对文本加以缩进,G: 跳到文件的最后一行 (缩进的结束位置)</p><h1 id="部分插件介绍"><a href="#部分插件介绍" class="headerlink" title="部分插件介绍"></a>部分插件介绍</h1><p><code>auto-pairs</code>:自动补全括号和引号等, <code>Plugin &#39;jiangmiao/auto-pairs&#39;</code></p><p><code>vim-gitgutter</code>:支持Git 的高亮,<code>airblade/vim-gitgutter</code></p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>1, 向下查找当前光标所在单词或字符串<br>g* 查找则不限制whole word。 区别：比如在if这个单词上按*键则查找单词if,按g*键则查找if。</p><p>2, 向上查找当前光标所在单词或字符串<br>g# 查找则不限制whole word。 区别：比如在if这个单词上按#键则查找单词if,按g#键则查找if。</p><p>3, 删掉奇偶行</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:g/^/+</span><span class="number">1</span> d 或 %norm jdd 删除偶数行</span><br><span class="line"><span class="symbol">:g/^/d|m</span>  %删除奇数行</span><br></pre></td></tr></table></figure><p>4, C-o (fast out, fast in)<br>在insert模式下,用C-o后可以执行一个normal命令,然后立即返回insert模式,省去了用ESC的麻烦。</p><p>5, 特殊的“寄存器”：”=”<br>在插入模式或命令模式中,键入“Ctrl-R=”,Vim 会提示你输入一个表达式,普通的整数运算在此完全有效。</p><p>5, Make 和 grep<br>Make 和grep 应当算是 Unix 世界里无人不晓的基本工具了吧。很自然的,Vim 对它们有着特殊的支持。该支持主要通过访问一个特殊的快速修订窗口(quickfix window)来实现。直接在 Vim 的命令模式里输入相应的 make 或 grep 命令(如“:grep foo *.c”)即可将命令的执行结果放入该窗口,同时根据返回的结果跳转到第一个错误(make 的情况；在使用 grep 时是匹配成功之处)。以下是常用的“快速修订”命令：</p><figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:cn</span>(显示下一个错误)</span><br><span class="line"><span class="symbol">:cp</span>(显示上一个错误)</span><br><span class="line"><span class="symbol">:cl</span>(列出所有的错误及其编号)</span><br><span class="line"><span class="symbol">:cc</span>(跳转到指定编号的错误)</span><br><span class="line"><span class="symbol">:copen</span>(打开快速修订窗口<span class="punctuation">,</span>在其中显示所有错误<span class="punctuation">,</span>可在错误上双击鼠标或按回车键跳转至该错误</span><br></pre></td></tr></table></figure><p>6,  快捷键 </p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CTRL</span>-A          插入最近插入的文本</span><br><span class="line"><span class="built_in">CTRL</span>-H  删除光标前的字符</span><br><span class="line"><span class="built_in">CTRL</span>-W          删除光标前的单词</span><br><span class="line"><span class="built_in">CTRL</span>-U          删除光标所有输入的字符</span><br></pre></td></tr></table></figure><p>7,  跳回上次修改过的地方<br>很简单的一种方法就是先撤销,再反撤销：u<C-r></p><p>8,  跳转文件<br>在使用 df 后跳转回来,可用<C-o>跳转回原文件。</p><h2 id="手动载入插件"><a href="#手动载入插件" class="headerlink" title="手动载入插件"></a>手动载入插件</h2><p><code>filetype</code> 提供一种方便的机制来定义不同文件类型的配置。 也可以不用这种机制,手动载入对应文件的配置,例如, 创建或读取 *.plt 文件时执行 plt.vim:<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">au</span> BufNewFile,BufRead *.plt  <span class="keyword">source</span> ~/.<span class="keyword">vim</span>/after/ftplugin/plt.<span class="keyword">vim</span></span><br></pre></td></tr></table></figure></p><h1 id="创建分割窗口"><a href="#创建分割窗口" class="headerlink" title="创建分割窗口"></a>创建分割窗口</h1><p>vim 在启动的时候只会打开单个窗口,可用<code>Control+W+s</code> 来水平切分窗口,类似的,可用<code>Control+w+v</code> 来进行垂直切分。或者是用命令的方式来打开新的文件:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">sp</span>[lit] &#123;<span class="keyword">file</span>&#125;   水平切分</span><br><span class="line">:vsp[lit] &#123;<span class="keyword">file</span>&#125;  垂直切分</span><br></pre></td></tr></table></figure><h2 id="窗口之间的切换"><a href="#窗口之间的切换" class="headerlink" title="窗口之间的切换"></a>窗口之间的切换</h2><p>常见的一些命令如下所示</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;C-w&gt;</span><span class="attribute">w</span>   在窗口间循环切换</span><br><span class="line"><span class="section">&lt;C-w&gt;</span><span class="attribute">h</span>,j,k,l 类似移动一样的切换</span><br></pre></td></tr></table></figure><h2 id="关闭窗口"><a href="#关闭窗口" class="headerlink" title="关闭窗口"></a>关闭窗口</h2><p>减少工作去中窗口的数量,可以采用两种方式：<code>:close</code>, 命令关闭活动窗口,<code>:only</code> 命令关闭除了活动窗口以外的所有窗口,其等效的普通模式命令：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">EX命令          普通模式命令      用途</span><br><span class="line">:<span class="keyword">clo</span>[<span class="keyword">se</span>]        <span class="symbol">&lt;C-w&gt;</span><span class="keyword">c</span>         关闭活动窗口</span><br><span class="line">:<span class="keyword">on</span>[ly]         <span class="symbol">&lt;C-w&gt;</span><span class="keyword">o</span>         只保留活动窗口</span><br></pre></td></tr></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">. 匹配任意字符</span><br><span class="line"><span class="selector-attr">[abc]</span> 匹配方括号中的任意一个字符,可用-表示字符范围。如<span class="selector-attr">[a-z0-9]</span>匹配小写字母和数字</span><br><span class="line"><span class="selector-attr">[^abc]</span> 匹配除方括号中字符之外的任意字符</span><br><span class="line">\d 匹配阿拉伯数字,等同于<span class="selector-attr">[0-9]</span></span><br><span class="line">\D 匹配阿拉伯数字之外的任意字符,等同于<span class="selector-attr">[^0-9]</span></span><br><span class="line">\<span class="attribute">x</span> 匹配十六进制数字,等同于<span class="selector-attr">[0-9A-Fa-f]</span></span><br><span class="line">\<span class="attribute">X</span> 匹配十六进制数字之外的任意字符,等同于<span class="selector-attr">[^0-9A-Fa-f]</span></span><br><span class="line">\l 匹配<span class="selector-attr">[a-z]</span></span><br><span class="line">\L 匹配<span class="selector-attr">[^a-z]</span></span><br><span class="line">\u 匹配<span class="selector-attr">[A-Z]</span></span><br><span class="line">\U 匹配<span class="selector-attr">[^A-Z]</span></span><br><span class="line">\w 匹配单词字母,等同于<span class="selector-attr">[0-9A-Za-z_]</span></span><br><span class="line">\W 匹配单词字母之外的任意字符,等同于<span class="selector-attr">[^0-9A-Za-z_]</span></span><br><span class="line">\t 匹配&lt;TAB&gt;字符</span><br><span class="line">\s 匹配空白字符,等同于<span class="selector-attr">[\t]</span></span><br><span class="line">\S 匹配非空白字符,等同于<span class="selector-attr">[^\t]</span></span><br></pre></td></tr></table></figure><h3 id="表示数量的元字符"><a href="#表示数量的元字符" class="headerlink" title="表示数量的元字符"></a>表示数量的元字符</h3><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\*</span> 匹配<span class="number">0</span>-任意个</span><br><span class="line"><span class="string">\+</span> 匹配<span class="number">1</span>-任意个</span><br><span class="line"><span class="string">\?</span> 匹配<span class="number">0</span>-<span class="number">1</span>个</span><br><span class="line"><span class="string">\&#123;n,m&#125;</span> 匹配n-m个</span><br><span class="line"><span class="string">\&#123;n&#125;</span> 匹配n个</span><br><span class="line"><span class="string">\&#123;n,&#125;</span> 匹配n-任意个</span><br><span class="line"><span class="string">\&#123;,m&#125;</span> 匹配<span class="number">0</span>-m个</span><br><span class="line"><span class="string">\_.</span> 匹配包含换行在内的所有字符</span><br><span class="line"><span class="string">\&#123;-&#125;</span> 表示前一个字符可出现零次或多次,但在整个正则表达式可以匹配成功的前提下,匹配的字符数越少越好(使用“<span class="string">\&#123;-&#125;”来代替“*”,实现非贪婪匹配)</span></span><br><span class="line"><span class="string">\=</span> 匹配一个可有可无的项</span><br><span class="line"><span class="string">\_s</span> 匹配空格或断行</span><br><span class="line"><span class="string">\_[]</span></span><br><span class="line"><span class="string">\\*匹配</span> <span class="string">\*</span> 字符</span><br><span class="line"><span class="string">\.匹配</span> . 字符</span><br><span class="line"><span class="string">\/匹配</span> / 字符</span><br><span class="line"><span class="string">\\匹配</span> <span class="string">\</span> 字符</span><br><span class="line"><span class="string">\[匹配</span> [ 字符</span><br></pre></td></tr></table></figure><h3 id="表示位置的符号"><a href="#表示位置的符号" class="headerlink" title="表示位置的符号"></a>表示位置的符号</h3><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$ 匹配行尾</span><br><span class="line">^ 匹配行首</span><br><span class="line"><span class="string">\&lt;</span> 匹配单词词首</span><br><span class="line"><span class="string">\&gt;</span> 匹配单词词尾</span><br></pre></td></tr></table></figure><h3 id="懒惰模式"><a href="#懒惰模式" class="headerlink" title="懒惰模式"></a>懒惰模式</h3><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\&#123;-n,m&#125;</span> 与<span class="string">\&#123;n,m&#125;一样,尽可能少次数地重复</span></span><br><span class="line"><span class="string">\&#123;-&#125;</span> 匹配它前面的项一次或<span class="number">0</span>次, 尽可能地少</span><br><span class="line"><span class="string">\|&quot;或&quot;操作符</span></span><br><span class="line"><span class="string">\&amp;并列</span></span><br></pre></td></tr></table></figure><p>另外需要注意的一点是,在ex中,竖直线(|)是命令的分割符,有点像shell里面的管道,不过没有测试过是不是第二个命令可以用来接收第一个命令输出的结果。</p><h1 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h1><p>跳转用 <code>ctags</code> 是真的香, 配置好了后在各种函数之间跳转,可以快速的浏览代码的感觉真是爽爆了,macOs下面可以按照如下操作去安装</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>exuberant-ctags</span><br></pre></td></tr></table></figure><p>然后更改一下<code>～/.zprofile</code>文件(自己用的zsh, bash 的话应该有类似的文件), 往里面写入如下内容</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="string">&quot;/usr/local/bin:/usr/local/sbin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure><p>然后<code>source</code>一下这个文件,再查看下ctags 所处位置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zprofile</span><br><span class="line"><span class="built_in">which</span> ctags</span><br></pre></td></tr></table></figure><p>自己这边输出的是<code>/opt/homebrew/bin/ctags</code>, 然后在vim的配置文件中输入如下内容即可：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">let Tlist_Ctags_Cmd=<span class="string">&quot;/opt/homebrew/bin/ctags&quot;</span></span><br><span class="line"><span class="keyword">set</span> tags=<span class="string">../</span>*<span class="string">/tags</span>,<span class="string">./</span>*<span class="string">/tags</span>,<span class="string">./tags</span>,<span class="string">./../tags</span></span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>寄存器部分单独拿出来作为说明；</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] Vim 7.2<br>[2] Practice Vim<br>[3] <a href="https://harttle.land/2015/07/17/vim-advanced.html">感受Vim的强大：进阶技巧</a></p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tools </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim 寄存器</title>
      <link href="/2020/09/28/archived_vim_register/"/>
      <url>/2020/09/28/archived_vim_register/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#理解-vim-寄存器">理解 vim 寄存器</a><ul><li><a href="#复制专用寄存器">复制专用寄存器(“)</a></li><li><a href="#有名寄存器a-z">有名寄存器(“a-“z)</a></li><li><a href="#系统剪贴板与选择专用寄存器">系统剪贴板(“+)与选择专用寄存器(“*)</a></li><li><a href="#表达式寄存器">表达式寄存器(“=)</a></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从2020年的vim笔记中摘选出来单独做内容的说明;</p><h1 id="理解-vim-寄存器"><a href="#理解-vim-寄存器" class="headerlink" title="理解 vim 寄存器"></a>理解 vim 寄存器</h1><p>在以前的笔记中只提到一点点,这里多做一些说明。 vim 不使用单一的剪贴板进行剪切、复制与粘贴操作,而是为这些操作提供了多组寄存器。当使用删除、复制与粘贴命令时,可以明确指定某一个进行操作.  vim 的删除、复制与粘贴命令都会用到众多寄存器中的某一个。可以通过给命令加”{register} 前缀的方式指定要用的寄存器。若不指明,vim 将缺省使用无名寄存器。</p><p>看一些引用寄存器的例子,如果想把当前单词复制到寄存器 a 中,可执行”ayiw”,或者,可以用”bdd”,把当前整行文本剪切至寄存器 b 中。在此之后,既可以输入”ap” 粘贴来自寄存器 a 的单词,也可使用”bp”命令粘贴来自寄存器 b 的一整行文本,两者互不干扰.</p><h2 id="复制专用寄存器-“"><a href="#复制专用寄存器-“" class="headerlink" title="复制专用寄存器(“)"></a>复制专用寄存器(“)</h2><p>当使用 y{motion}命令时,要复制的文本不仅会被拷贝到无名寄存器中,而且也被拷贝到了复制专用寄存器中,后者可用数字 0 加以引用。 复制专用寄存器,顾名思义,仅当使用 y{motion}命令时才会被赋值。换句话讲,使用 x、s、c{ motion}以及 d motion}命令均不会覆盖该寄存器。如果复制了些文本,可以确信该文本会一直保存于寄存器 0 中,直到复制其他文本时才会被覆盖。复制专用寄存器是稳定的,而无名寄存器是易变的.</p><h2 id="有名寄存器-“a-“z"><a href="#有名寄存器-“a-“z" class="headerlink" title="有名寄存器(“a-“z)"></a>有名寄存器(“a-“z)</h2><p>vim 提供了组以 26 个英文字母,命名的有名寄存器。这意味着我们可以剪切(“ad{motion｝)、复制(“ay{motion｝)或者粘贴(“ap)多达 26 段文本。 用小写字母引用有名寄存器,会覆盖该寄存器的原有内容,而换用大写字母的话,则会将新内容添加到该寄存器的原有内容之后。</p><h2 id="系统剪贴板-“-与选择专用寄存器-“"><a href="#系统剪贴板-“-与选择专用寄存器-“" class="headerlink" title="系统剪贴板(“+)与选择专用寄存器(“*)"></a>系统剪贴板(“+)与选择专用寄存器(“*)</h2><p>当然,这个在windows/Linux里用的是比较多的,在mac上直接cmd+v就好了,没那么费事。如果想从 vim 复制文本到外部程序(反之亦然),则必须使用系统剪贴板.  如果在外部程序中用剪切或复制命令获取了文本,就可以通过”+p 命令(或在插入模式下用ctrl-r +)将其粘贴到 vim 内部。相反地,如果在 vim 的复制或删除命令之前加入相应的文本将被捕获至系统剪贴板。</p><h2 id="表达式寄存器-“"><a href="#表达式寄存器-“" class="headerlink" title="表达式寄存器(“=)"></a>表达式寄存器(“=)</h2><p>vim 的寄存器通常被认为是保存一段文本的容器。然而,通过=号引用的表达式寄存器却是个例外。当从表达式寄存器获取内容时,vim 将跳到命令行模式,并显示提示符“=”。这时,我们可以输入一段 vim 脚本表达式并按Enter执行,如果返回的是字符串(或者可被强制转换成字符串的数据), vim 将会使用它。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] Vim 7.2<br>[2] Practice Vim<br>[3] <a href="https://harttle.land/2015/07/17/vim-advanced.html">感受Vim的强大：进阶技巧</a></p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tools </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制学笔记(一)</title>
      <link href="/2020/09/24/archived_control_2020/"/>
      <url>/2020/09/24/archived_control_2020/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a><ul><li><a href="#线性系统的基本特性">线性系统的基本特性</a></li><li><a href="#控制系统的复数域数学模型">控制系统的复数域数学模型</a><ul><li><a href="#传递函数的性质">传递函数的性质</a></li><li><a href="#传递函数的极点和零点对输出的影响">传递函数的极点和零点对输出的影响</a></li></ul></li></ul></li><li><a href="#线性系统的时域分析法">线性系统的时域分析法</a><ul><li><a href="#动态过程与稳态过程">动态过程与稳态过程</a><ul><li><a href="#减小或消除稳态误差的措施">减小或消除稳态误差的措施</a></li></ul></li></ul></li><li><a href="#线性系统的根轨迹法">线性系统的根轨迹法</a></li><li><a href="#离散状态方程求解">离散状态方程求解</a></li><li><a href="#能控性和能观性">能控性和能观性</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果有数学基础,对高等数学中的微积分很熟悉,入门控制学会相对较快。可以看知乎的 <a href="https://zhuanlan.zhihu.com/c_217937043">小潘是个工程师</a>     的专栏,过几遍他的文章,心中的框架自然而然的就建立起来了,说的很透彻,也正是以前和师弟所说,控制某种程度上就是求解微分方程,只不过自己很难解释的清楚,另一方面自己水平太低,也解释不清。作为自己的学习笔记,会将书中看到的一些重要的,记录在这里。</p><h2 id="线性系统的基本特性"><a href="#线性系统的基本特性" class="headerlink" title="线性系统的基本特性"></a>线性系统的基本特性</h2><p>用线性微分方程描述的元件或系统,称为线性元件或线性系统。线性系统的重要性质是可以应用叠加原理。叠加原理有两重含义,即具有可叠加性和均匀性(或齐次性)。现举例说明∶设有线性微分方程</p><div align="center"> <img src="/img/postImg/17_Control/equation/线性微分方程.png" width="20%" height="20%"> </div><p>当f(t) = f1(t)时,上述方程的解为 c1(t); 当f(t) = f2(t),其解为c2(t).  如果 f(t) = f1(t) + f2(t), 容易验证,方程的解必为 c(t) = c1(t) +c2(t).这就是可叠加性。而当f(t) = Af1(t)时,式中A为常数,则方程的解必为 c(t) = Ac1(t), 这就是齐次性。</p><p>线性系统的叠加原理表明,两个外作用同时加于系统所产生的总输出,等于各个外作用单独作用时分别产生的输出之和,且外作用的数值增大若干倍时,其输出亦相应增大同样的倍数。因此,对线性系统进行分析和设计时,如果有几个外作用同时加于系统,则可以将它们分别处理,依次求出各个外作用单独加入时系统的输出,然后将它们叠加。此外,每个外作用在数值上可只取单位值,从而大大简化了线性系统的研究工作。</p><h2 id="控制系统的复数域数学模型"><a href="#控制系统的复数域数学模型" class="headerlink" title="控制系统的复数域数学模型"></a>控制系统的复数域数学模型</h2><p>控制系统的微分方程是在时间域描述系统动态性能的数学模型,在给定外作用及初始条件下,求解微分方程可以得到系统的输出响应。这种方法比较直观,特别是借助于计算机可以迅速而准确地求得结果。但是如果<strong>系统的结构改变或某个参数变化时</strong>,就要重新列写并求解微分方程,不便于对系统进行分析和设计。</p><p>用拉氏变换法求解线性系统的微分方程时,可以得到控制系统在复数域中的数学模型——传递函数。传递函数不仅可以表征系统的动态性能,而且可以用来<strong>研究系统的结构或参数变化对系统性能的影响</strong>。经典控制理论中广泛应用的频率法和根轨迹法,就是以传递函数为基础建立起来的,传递函数是经典控制理论中最基本和最重要的概念。</p><h3 id="传递函数的性质"><a href="#传递函数的性质" class="headerlink" title="传递函数的性质"></a>传递函数的性质</h3><p>1)传递函数是复变量s的有理真分式函数,具有复变函数的所有性质;m≤n,且所有系数均为实数。</p><p>2)传递函数是一种用系统参数表示输出量与输入量之间关系的表达式,它只取决于系统或元件的结构和参数,而与输入量的形式无关,也不反映系统内部的任何信息。</p><p>3)传递函数与微分方程有相通性。传递函数分子多项式系数及分母多项式系数,分别与相应微分方程的右端及左端微分算符多项式系数相对应。故在零初始条件下,将微分方程的算符d/dt用复数s置换便得到传递函数;反之,将传递函数多项式中的变量s用算符d/dt置换便得到微分方程。</p><h3 id="传递函数的极点和零点对输出的影响"><a href="#传递函数的极点和零点对输出的影响" class="headerlink" title="传递函数的极点和零点对输出的影响"></a>传递函数的极点和零点对输出的影响</h3><p>由于传递函数的极点就是微分方程的特征根,因此它们决定了所描述系统自由运动的模态,而且在强迫运动中(即零初始条件响应)也会包含这些自由运动的模态。</p><h1 id="线性系统的时域分析法"><a href="#线性系统的时域分析法" class="headerlink" title="线性系统的时域分析法"></a>线性系统的时域分析法</h1><p>在经典控制理论中,常用时域分析法、根轨迹法或频域分析法来分析线性控制系统的性能。显然,不同的方法有不同的特点和适用范围,但是比较而言,时域分析法是一种直接在时间域中对系统进行分析的方法,具有直观、准确的优点,并且可以提供系统时间响应的全部信息。</p><h2 id="动态过程与稳态过程"><a href="#动态过程与稳态过程" class="headerlink" title="动态过程与稳态过程"></a>动态过程与稳态过程</h2><p>在典型输入信号作用下,任何一个控制系统的时间响应都由动态过程和稳态过程两部分组成。</p><p>(1) 动态过程</p><p>动态过程又称过渡过程或瞬态过程,指系统在典型输人信号作用下,系统输出量从初始状态到最终状态的响应过程。由于实际控制系统具有惯性、摩擦以及其他一些原因,系统输出量不可能完全复现输入量的变化。根据系统结构和参数选择情况,动态过程表现为衰减、发散或等幅振荡形式。显然,一个可以实际运行的控制系统,其动态过程必须是衰减的。</p><p>(2) 稳态过程<br>稳态过程指系统在典型输入信号作用下,当时间t趋于无穷时,系统输出量的表现方式。稳态过程又称稳态响应,表征系统输出量最终复现输人量的程度,提供系统有关稳态误差的信息,用稳态性能描述。</p><p>应当指出,由于所研究的系统实质上都是线性化的系统,称为线性逼近,在建立系统线性化模型的过程中略去了许多次要因素,同时系统的参数又处于不断地微小变化之中,所以临界稳定现象实际上是观察不到的。基于线性逼近的稳定性,李雅普诺夫证明了一个显著的结论;如果其线性逼近是严格稳定的,即所有的根在左半平面,那么非线性系统将在应用线性逼近的平衡点的某个邻域内稳定。此外,他还证明了另一个结论;如果线性逼近至少有一个根在右半平面,那么这个非线性系统不可能在平衡点的任何邻域内稳定。</p><h3 id="减小或消除稳态误差的措施"><a href="#减小或消除稳态误差的措施" class="headerlink" title="减小或消除稳态误差的措施"></a>减小或消除稳态误差的措施</h3><p>为了减小或消除系统在输人信号和扰动作用下的稳态误差,可以采取以下措施。</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">(1)</span> 增大系统开环增益或扰动作用点之前系统的前向通道增益。</span><br><span class="line"><span class="comment">(2)</span> 在系统的前向通道或主反馈通道设置串联积分环节。</span><br></pre></td></tr></table></figure><p>注： 在反馈控制系统中,设置串联积分环节或增大开环增益以消除或减小稳态误差的措施,必然导致降低系统的稳定性,甚至造成系统不稳定,从而恶化系统的动态性能。因此,权衡考虑系统稳定性、稳态误差与动态性能之间的关系,便成为系统校正设计的主要内容。</p><p>(3)采用串级控制抑制内回路扰动<br>当控制系统中存在多个扰动信号,且控制精度要求较高时,宜采用串级控制方式,可以显著抑制内回路的扰动影响。</p><p>(4)采用复合控制方法<br>如果控制系统中存在强扰动,特别是低频强扰动,则一般的反馈控制方式难以满足高稳态精度的要求,此时可以采用复合控制方式。 复合控制系统是在系统的反馈控制回路中加入前馈通路,组成一个前馈控制与反馈控制相结合的系统,只要系统参数选择合适,不但可以保持系统稳定,极大地减小乃至消除稳态误差,而且可以抑制几乎所有的可量测扰动,其中包括低频强扰动。</p><h1 id="线性系统的根轨迹法"><a href="#线性系统的根轨迹法" class="headerlink" title="线性系统的根轨迹法"></a>线性系统的根轨迹法</h1><p>根轨迹简称根迹,它是开环系统某一参数从零变到无穷时,闭环系统特征方程式的根在s平面上变化的轨迹。当闭环系统没有零点与极点相消时,闭环特征方程式的根就是闭环传递函数的极点,常简称之为闭环极点。因此,从已知的开环零、极点位置及某一变化的参数来求取闭环极点的分布,实际上就是解决闭环特征方程式的求根问题。当<strong>开环增益</strong>或其他参数改变时,其全部数值对应的闭环极点均可在根轨迹图上简便地确定。因为系统的稳定性由系统闭环极点唯一确定,而系统的稳态性能和动态性能又与闭环零、极点在s平面上的位置密切相关,所以根轨迹图不仅可以直接给出闭环系统时间响应的全部信息,而且可以指明开环零、极点应该怎样变化才能满足给定的闭环系统的性能指标要求。除此而外,用根轨迹法求解高阶代数方程的根,比用其他近似求根法简便。</p><h1 id="离散状态方程求解"><a href="#离散状态方程求解" class="headerlink" title="离散状态方程求解"></a>离散状态方程求解</h1><p>离散状态空间表达式中的状态方程实际上是一阶差分方程组,所以,关于差分方程求解的方法都可用于离散状态方程的求解,常用的方法有递推法和 z 变换法。</p><p>1, 递推法</p><p>设离散系统的状态空间表达式为</p><div align="center"> <img src="/img/postImg/17_Control/equation/状态空间表达式.png" width="20%" height="20%"> </div><p>已知状态初始值 x(0) 和输入序列 u(k),  从 k=0 开始,按照状态方程逐步递推,就可得任意时刻的状态向量值。 对应的输出序列为</p><div align="center"> <img src="/img/postImg/17_Control/equation/递推后的任意时刻状态向量值的输出序列.png" width="60%" height="40%"> </div><p>2, Z 变换法</p><p>对状态方程进行 z 变换,得</p><div align="center"> <img src="/img/postImg/17_Control/equation/Z变换.png" width="40%" height="40%"> </div><h1 id="能控性和能观性"><a href="#能控性和能观性" class="headerlink" title="能控性和能观性"></a>能控性和能观性</h1><p>对于以离散状态空间表达的被控对象</p><div align="center"> <img src="/img/postImg/17_Control/equation/以离散状态空间表达的被控对象.png" width="30%" height="40%"> </div><p>对上式进行z逆变换,即得状态向量序列</p><div align="center"> <img src="/img/postImg/17_Control/equation/Z逆变换后的状态向量序列.png" width="30%" height="40%"> </div><p>得到状态后,根据输出方程 <code>y(k) = Cx(k) + Du(k)</code>。求得输出序列。 用 z 变换法求解虽然复杂一些,但可以求得解析结果,可以获得所求序列的一般项的表达式。</p><p>对于以离散状态空间表达的被控对象</p><div align="center"> <img src="/img/postImg/17_Control/equation/以离散状态空间表达的被控对象.png" width="30%" height="40%"> </div><p>如果系统在一个有限的时间间隔内,可用一个无约束的控制向量,使得系统由初始状态  x(t0)  转移到终点状态或者回到原点 x(0),则称系统在时间 t0 是可控的。它说明了系统控制输人对系统内部状态的控制或影响的能力。</p><p>可控性是被控系统的内在属性,由系统的结构和参数所决定。如果一个被控系统没有可控性,则设计就失去了意义。可观测性是反映由系统的量确定系统状态的可能性,即是说通过分析测量,重构系统状态的可能性。如果一个系统在状态 x(t0),可通过在一个有限的时间间隔内,由输出量的观测值所确定,则称该系统在时间 t0 是可观测的,观测值取决于系统的特性 A 和 C. 实际上大多数系统是可控的和可观测的,但是也有部分物理系统不具有可控性和可观测性,因此要予以判断。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] 《自动控制原理》 胡寿松</p><p>[2] 机电系统计算机控制</p>]]></content>
      
      
      <categories>
          
          <category> CONTROL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> simulation </tag>
            
            <tag> control </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 学习笔记(一)</title>
      <link href="/2020/09/01/archived_linux2020/"/>
      <url>/2020/09/01/archived_linux2020/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#linux-文件权限">Linux 文件权限</a><ul><li><a href="#passwd-和-chpasswd">passwd 和 chpasswd</a></li><li><a href="#chshchfn-和-chage">chsh、chfn 和 chage</a></li><li><a href="#创建分区">创建分区</a></li><li><a href="#使用变量">使用变量</a><ul><li><a href="#环境变量">环境变量</a></li><li><a href="#用户变量">用户变量</a></li></ul></li><li><a href="#命令替换">命令替换</a></li><li><a href="#重定向输入和输出">重定向输入和输出</a></li><li><a href="#输入重定向">输入重定向</a></li><li><a href="#管道">管道</a></li></ul></li><li><a href="#结构化命令">结构化命令</a><ul><li><a href="#if-then-语句">if-then 语句</a></li><li><a href="#if-then-e1se-语句">if-then-e1se 语句</a></li></ul></li><li><a href="#技巧">技巧</a><ul><li><a href="#参考">参考</a></li></ul></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>并非教程,留给自己平时查阅使用。</p><h1 id="Linux-文件权限"><a href="#Linux-文件权限" class="headerlink" title="Linux 文件权限"></a>Linux 文件权限</h1><p>用户权限是通过创建用户时分配的用户 ID (User ID,通常缩写为 UID)来跟踪的。UID 是数值,每个用户都有唯的 UID,但在登录系统时用的不是 UID,而是登录名。 Linux 系统使用一个专门的文件来将用户的登录名匹配到对应的 UID 值。这个文件就是 /etc/passwd 文件,它包含了一些与用户有关的信息。 root 用户账户是 Linux 系统的管理员,固定分配给它的 UID 是 0。Linux 系统会为各种各样的功能创建不同的用户账户,而这些账户并不是真的用户。这些账户叫作系统账户,是系统上运行的各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个系统用户账户登录到 Linux 系统.  /etc/passwd 文件中还有很多用户登录名和 UID 之外的信息。 /etc/passwd文件的字段包含了如下信息:</p><details><summary>展开</summary><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>, 登录用户名</span><br><span class="line"><span class="number">2</span>, 用户密码</span><br><span class="line"><span class="number">3</span>, 用户账户的 <span class="built_in">UID</span>(数字形式)</span><br><span class="line"><span class="number">4</span>, 用户账户的组 ID (GID)(数字形式)</span><br><span class="line"><span class="number">5</span>, 用户账户的文本描述(称为备注字段)</span><br><span class="line"><span class="number">6</span>, 用户 HOME 目录的位置</span><br><span class="line"><span class="number">7</span>, 用户的默认 shell</span><br></pre></td></tr></table></figure></details><p>出于安全考虑,现在,绝大多数 Linux 系统都将用户密码保存在另一个单独的文件中(叫作 shadow 文件,位置在/etc/shadow)。只有特定的程序(比如登录程序)才能访问这个文件.  /etc/shadow 文件对 Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow 文件,这让它比起 /etc/passwd安全许多。 etc/shadow 文件为系统上的每个用户账户都保存了一条记录。 在/et/shadow 文件的每条记录中都有 9 个字段：</p><details><summary>展开</summary><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>, 与<span class="regexp">/etc/</span>passwd 文件中的登录名字段对应的登录名</span><br><span class="line"><span class="number">2</span>, 加密后的密码</span><br><span class="line"><span class="number">3</span>, 自上次修改密码后过去的天数密码</span><br><span class="line"><span class="number">4</span>, 多少天后才能更改密码</span><br><span class="line"><span class="number">5</span>, 多少天后必须更改密码</span><br><span class="line"><span class="number">6</span>, 密码过期前提前多少天提醒用户更改密码</span><br><span class="line"><span class="number">7</span>, 密码过期后多少天禁用用户账户</span><br><span class="line"><span class="number">8</span>, 用户账户被禁用的日期</span><br><span class="line"><span class="number">9</span>, 预留字段给将来使用</span><br></pre></td></tr></table></figure></details><h2 id="passwd-和-chpasswd"><a href="#passwd-和-chpasswd" class="headerlink" title="passwd 和 chpasswd"></a>passwd 和 chpasswd</h2><p>改变用户密码的一个简便方法就是用 passwd 命令。 如果只用 passwd 命令,它会改你自己的密码。系统上的任何用户都能改自己的密码, root 用户オ有权限改别人的密码。 -e 选项能强制用户下次登录时修改密码。可以先给用户设置一个简单的密码,之后再强制在下次登录时改成他们能记住的更复杂的密码。 如果需要为系统中的大量用户修改密码,chpasswd 命令可以事半功倍。chpasswd 命令能从标准输入自动读取登录名和密码对(由冒号分割)列表,给密码加密,然后为用户账户设置。也可以用重定向命令来将含有 userid: passwd 对的文件重定向给该命令。比如</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">chpasswd</span> &lt; users.txt</span><br></pre></td></tr></table></figure><h2 id="chsh、chfn-和-chage"><a href="#chsh、chfn-和-chage" class="headerlink" title="chsh、chfn 和 chage"></a>chsh、chfn 和 chage</h2><p>chsh、chfn 和 chage 工具专门用来修改特定的账户信息。chsh 命令用来快速修改默认的用户登录 shell 使用时必须用 shell 的全路径名作为参数,不能只用 shell 名。这个在使用oh-my-zsh时会用到chsh这个指令。</p><p>chfn 命令提供了在/etc/passwd文件的备注字段中存储信息的标准方法。chfn命令会将用于 unix 的 finger 命令的信息存进备注字段,而不是简单地存入一些随机文本(比如名字或昵称之类的),或是将备注字段留空。finger 命令可以非常方便地査看 linux 系统上的用户信息</p><p>chage命令中有个好用的功能是设置账户的过期日期。有了它,你就能创建在特定日期自动过期的临时用户,再也不需要记住删除用户了！过期的账户跟锁定的账户很相似：账户仍然存在, 但用户无法用它登录。</p><h2 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h2><p>一开始,你必须在存储设备上创建分区来容纳文件系统。分区可以是整个硬盘,也可以是部分硬盘,以容纳虚拟目录的一部分。 fdisk 工具用来帮助管理安装在系统上的任何存储设备上的分区。它是个交互式程序,允许你输人命令来逐步完成硬盘分区操作。 要启动 fdisk 命令,必须指定要分区的存储设备的设备名,另外还得有超级用户权限。</p><p>有时候,创建新磁盘分区最麻烦的事情就是找出安装在 Linux 系统中的物理磁盘。Linux 采用了一种标准格式来为硬盘分配设备名称,但是你得熟悉这种格式。对于老式的 IDE 驱动器,Linux 使用的是/dev/hdx。其中x表示一个字母,具体是什么要根据驱动器的检测顺序(第一个驱动器是 a,第二个驱动器是 b,以此类推)。对于较新的 SATA 驱动器和 SCSI 驱动器, Linux使用/dev/sdx。其中的x具体是什么也要根据驱动器的检测顺序(和之前一样,第一个驱动器是 a,第二个驱动器是 b,以此类推)。在格式化分区之前,最好再检查下是否正确指定了驱动器。</p><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>shell 护着一组环境变量,用来记录特定的系统信息。比如系统的名称、登录到系统上的用户名、用户的系统 ID(也称为 UID)、用户的认主目录以及 shell 査找程序的搜索路径。可以用 set 命令来显示一份完整的当前环境变量列表。 在脚本中,可以在环境变量名称之前加上美元符($)来使用这些环境变量。</p><h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>除了环境变量,shell 允许在脚本中定义和使用自己的变量。定义变量允许临时存储数据并在整个脚本中使用,用户变量可以是任何由字母、数字或下划线组成的文本字符串,长度不超过 20 个。用户变量区分大小写,所以变量 Var1 和变量 var1 是不同的。 使用等号将值赋给用户量。在变量、等号和值之间不能出现空格.  shell 脚本会自动決定変量值的数据类型。在脚本的整个生命周期里,shell 脚本中定义的变量会一直保持着它们的值,但在 shell 脚本结束时会被删除掉。</p><p>变量每次被引用时,都会输出当前赋给它的值。重要的是要记住,引用一个变量值时需要使用美元符,而引用变量来对其进行赋值时则不要使用美元符。没有美元符,shell 会将量名解释成普通的文本字符串.</p><h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><p>shell 本中最有用的特性之一就是可以从命令输出中提取信息,并将其赋给变量。把输出赋给变量之后,就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。 有两种方法可以将命令输岀赋给变量</p><p>1, 反引号字符(‘)<br>2, $() 格式</p><p>命令替换允许你将 shell 命令的输出赋给变量。尽管这看起来并不那么重要,但它却是脚本编程中的一个主要组成部分。</p><p>要么用一对反引号把整个命令行命令围起来:</p><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">test </span>= &#x27;order&#x27;</span><br></pre></td></tr></table></figure><p>要么使用 $() 格式</p><p>shell 运行命令替换符号中的命令,并将其输出赋给变量 test. 注意,赋值等号和命令替换字符之间没有空格。</p><h2 id="重定向输入和输出"><a href="#重定向输入和输出" class="headerlink" title="重定向输入和输出"></a>重定向输入和输出</h2><p>最基本的重定向将命令的输出发送到一个文件中。bash shell 用大于号(&gt;)来完成这项功能. 显示器上出现的命令输出会被保存到指定的输出文件中。</p><p>有时,你可能并不想覆盖文件原有内容,而是想要将命令的输出追加到已有文件中,比如你正在创建一个记录系统上某个操作的日志文件。在这种情况下,可以用双大于号(&gt;&gt;)来追加数据</p><h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p>输人重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令,而非将命令的输出重定向到文件。输入重定向符号是小于号(&lt;) </p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>有时需要将一个命令的输出作为另一个命令的输入, 这个过程叫作管道连接(piping),管道符号是单个竖线(|)。</p><p>管道被放在命令之间,将一个命令的输出重定向到另一个命令中</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">command</span> | <span class="keyword">command</span>2</span><br></pre></td></tr></table></figure><p>Linux 系统实际上会同时运行这两个命令,在系统内部将它们连接起来。在第一个命令产生输出的同时,输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区。</p><h1 id="结构化命令"><a href="#结构化命令" class="headerlink" title="结构化命令"></a>结构化命令</h1><p>过某些命令。这样的命令通常称为结构化命令(structured command/“许多程序要求对 shel 脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳</p><h2 id="if-then-语句"><a href="#if-then-语句" class="headerlink" title="if-then 语句"></a>if-then 语句</h2><p>最基本的结构化命令就是 if-then 语句。if-then 语句有如下格式。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>bash shelll 的 if 语句会运行后面的那个命令。如果该命令的退出状态码是 0(该命令成功运行),位于 then 部分的命令就会被执行。如果该命令的退出状态码是其他值,then部分的命令就不会被执行,bash shell 继续执行脚本中的下一个命令。fi 语句用来表示 if-then 语句到此结東</p><h2 id="if-then-e1se-语句"><a href="#if-then-e1se-语句" class="headerlink" title="if-then-e1se 语句"></a>if-then-e1se 语句</h2><p>在if-then 语句中,不管命令是否成功执行,你都只有一种选择。如果命令返回一个非零退出状态码,bash shelll 继续执行脚本中的下一条命令。在这种情况下,如果能够执行另一组命令就好了。这正是 if-then-else 语句的作用。</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>1, 要想知道系统中有哪些文件,可以使用列表命令(ls)。本节将描述ls命令和可用来格式化 其输出信息的选项。 要把隐藏文件和普通文件及目录一起显示出来,就得用到-a参数。 -R参数是ls命令可用的另一个参数,叫作递归选项。它列出了当前目录下包含的子目录中的文件。如果目录很多,这个输出就会很长。</p><p>2, 在基本的输出列表中,ls命令并未输出太多每个文件的相关信息。要显示附加信息,另一个常用的参数是-l。-l参数会产生长列表格式的输出,包含了目录中每个文件的更多相关信息。 这种长列表格式的输出在每一行中列出了单个文件或目录。除了文件名,输出中还有其他有用信息。</p><p>3, 文件类型,比如目录(d)、文件(-)、字符型文件(c)或块设备(b); ls命令还支持在命令行中定义过滤器。它会用过滤器来决定应该在输出中显示哪些文件 或目录。 这个过滤器就是一个进行简单文本匹配的字符串。可以在要用的命令行参数之后添加这个过滤器: 当用户指定特定文件的名称作为过滤器时,ls命令只会显示该文件的信息。ls命令能够识别标准通配符,并在过滤器中用它们进行模式匹配.  问号(?)代表一个字符;星号(*)代表零个或多个字符。 在过滤器中使用星号和问号被称为文件扩展匹配(file globbing),指的是使用通配符进行模式匹配的过程。通配符正式的名称叫作元字符通配符(metacharacter wildcards)。除了星号和问号之外,还有更多的元字符通配符可用于文件扩展匹配。可以使用中括号。 另外,可以使用感叹号(!)将不需要的内容排除在外。</p><p>4, tree工具。它能够以一种美观的方式展示目录、子目录及其中的文件。 file命令能够探测文件的内部,并决定文件是什么类型的: tail命令会显示文件最后几行的内容(文件的“尾部”)。默认情况下,它会显示文件的末尾10行。 可以向tail命令中加入-n参数来修改所显示的行数。 -f参数是tail命令的一个突出特性。它允许你在其他进程使用该文件时查看文件的内容。 tail命令会保持活动状态,并不断显示添加到文件中的内容。这是实时监测系统日志的绝妙方式。</p><p>5, head命令,顾名思义,会显示文件开头那些行的内容。默认情况下,它会显示文件前10行的文本. touch命令非常有用,可以创建空文件和变更已有文件的访问时间或修改时间。</p><p>6, 有时你需要知道在某个设备上还有多少磁盘空间。df命令可以让你很方便地查看所有已挂载磁盘的使用情况。 df命令有一些命令行参数可用,但基本上不会用到。一个常用的参数是-h。它会把输出中的磁盘空间按照用户易读的形式显示</p><p>7, 如果在卸载设备时,系统提示设备繁忙,无法卸载设备,通常是有进程还在访问该设备或使用该设备上的文件。 这时可用lsof命令获得使用它的进程信息,然后在应用中停止使用该设备或停止该进程。</p><p>8, du命令可以显示某个特定目录(默认情况下是当前目录)的磁盘使用情况。这一方法可用来快速判断系统上某个目录下是不是有超大文件。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 《Linux 命令行与 shell 脚本编程大全》</p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rtb 学习笔记</title>
      <link href="/2020/08/01/archived_rtb/"/>
      <url>/2020/08/01/archived_rtb/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#工具箱的获取">工具箱的获取</a></li><li><a href="#重要函数说明">重要函数说明</a></li><li><a href="#理论部分">理论部分</a><ul><li><a href="#标准dh与改进dh的不同">标准DH与改进DH的不同</a><ul><li><a href="#从变换公式来观察">从变换公式来观察</a></li></ul></li><li><a href="#从图中来观察">从图中来观察</a></li></ul></li><li><a href="#微分运动和广义速度">微分运动和广义速度</a></li><li><a href="#雅可比矩阵的构造法">雅可比矩阵的构造法</a></li><li><a href="#力雅可比">力雅可比</a></li><li><a href="#技巧">技巧</a></li><li><a href="#参考">参考</a></li><li><a href="#注意">注意</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>机器人学工具箱(rtb)是一个快速验证自己想法的一个matlab工具箱,简单点说,如果要求解一个复杂的方程组,通过各种算法求出来后,如何知道所求的解不是错误的呢,当然,最简单的办法,带入到原方程即可,这是所求出来的答案必要非充分的条件。类似的,如果可以运用好这个工具,无疑可以快速验证自己的想法,而不必拘泥于具体的细节,同时里面的代码都是开源的,就是说可以阅读里面代码的实现过程,通过阅读优秀的代码来提升自己的编程能力。CSDN上的关于这个工具箱的使用的内容有些让人失望,所以还是自己记录下学习的过程吧。这个并不是一个教程,只是用来激发对此工具箱感兴趣的小伙伴们。</p><p>当初因为玩不了真的机械臂,所以极力的寻找一个可以仿真的软件,当时对于我这个单枪匹马走入机器人领域的小白来说,什么都不懂,大多数时间都在探索中渡过,不过这并不是件坏事,从中学习到不少的软件的使用方法,就自己目前的学习经验来看,rtb工具箱是个性价比超高的学习机器人学的工具了。 这个工具箱的下载可直接进入petercorke.com网站,里面有matlab工具箱以及作者写的书,虽然作者写的书被翻译成了中文,不过还是建议学习这个工具的小伙伴能够阅读英文,熟悉下相关的术语。 由于才疏学浅,文中错误难免,有任何问题可以发邮件。</p><h1 id="工具箱的获取"><a href="#工具箱的获取" class="headerlink" title="工具箱的获取"></a>工具箱的获取</h1><p>登陆网站下载好机器人工具箱并解压,如下图所示并运行文件 <span id = "inline-blue">startup_rvc.m</span>即可开始使用,或者是在此文件夹下,输入</p><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">addpath</span>(<span class="title">genpath</span>(<span class="variable">pwd</span>))</span></span><br></pre></td></tr></table></figure><div align="center"> <img src="/img/postImg/33_rtb/rtb_startup.png" width="100%" height="40%"> </div> <p>如果初次接触,可以输入</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rtbdemo</span></span><br></pre></td></tr></table></figure><p>快速了解这个软件的概况。里面内置了不少的著名的机器人模型,其模型均以mdl_为开头,比如导入puma560这款经典的机械臂模型和查看其基本信息。</p><p> <img src="/img/postImg/33_rtb/p560_demo.png" width="100%" height="40%"> </p><p>这里的p560的类型为Seriallink,通过 <span id = "inline-blue"> help Seriallink </span>指令可以一览这个类可以用来做什么了。</p><p> <img src="/img/postImg/33_rtb/SerialLink_Help.png" width="100%" height="40%"></p><p>说到这可能有些犯迷糊了,话说这个到底怎么用的呢,首先从最基础的建立机械臂的运动学模型开始说起,rtb提供了标准和改进的DH方法建立机械臂的模型,这里仅以标准的为例,只要给出了机械臂的DH参数,就可以使用rtb工具快速的建立模型,这里以ur5协作机械臂为例,使用Link建立连杆,再使用Seriallink来将连杆组合起来。如果你不是做机械臂结构的设计的话,一开始分析机械臂时,其机械臂DH参数已经确定好了,直接带入公式即可,这里只说工具的使用,而不谈具体的原理。建立ur5运动学模型的代码如下</p><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">DOF=<span class="number">6</span>;</span><br><span class="line">%<span class="built_in">offset</span>=<span class="number">0</span>;</span><br><span class="line">alpha=[<span class="literal">pi</span>/<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">pi</span>/<span class="number">2</span>,-<span class="literal">pi</span>/<span class="number">2</span>,<span class="number">0</span>];</span><br><span class="line">a=[<span class="number">0</span>,<span class="number">-0.425</span>,<span class="number">-0.39225</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">d=[<span class="number">0.089459</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.10915</span>,<span class="number">0.09465</span>,<span class="number">0.0823</span>];</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>:DOF</span><br><span class="line">ur5Link(i) = Link([<span class="number">0</span>,d(i),a(i),alpha(i)],<span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">end</span><br><span class="line">ur5=SerialLink(ur5Link,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;ur5&#x27;</span>);</span><br><span class="line">W=[<span class="number">-1.5</span>, <span class="number">1.5</span> <span class="number">-1.5</span>  <span class="number">1.5</span> <span class="number">-1.5</span> <span class="number">1.5</span> ];</span><br><span class="line">%ur5.teach([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],<span class="string">&#x27;workspace&#x27;</span>,W,<span class="string">&#x27;noshading&#x27;</span>,<span class="string">&#x27;jaxes&#x27;</span>)</span><br><span class="line">ur5.teach([-<span class="literal">pi</span>/<span class="number">2</span>,-<span class="literal">pi</span>/<span class="number">2</span>,<span class="number">0</span>,-<span class="literal">pi</span>/<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>运行此段代码后的结果如下所示</p><p><img src="/img/postImg/33_rtb/ur5_rtb.png" width="30%" height="30%"></p><p>在命令行中输入<code>ur5.</code> 然后按下tab键,就可以看到其提供的很多功能,真心想了解这些功能的话,还是去查看SerialLink.m的代码,带有目的性的去阅读代码就行,如果有相关的知识,阅读那些代码,并不是个困难的事情。 对于这款机械臂,使用自带的求逆解的函数目前还没有成功过。。。所以需要自己分析如何求逆解了,求出逆解后可以做一些有趣的事情,比如说写字(代码可以做的优化工作有很多,因为没怎么优化,所以比较慢)。</p><p><img src="/img/postImg/33_rtb/ur5Young.gif" width="80%" height="80%"></p><p>这里给出很久之前的工作,这里就不重复把原来的内容给抄一遍,而且可以通过检索一些文献,可以知道在改进DH下的运动/动力学的推导过程,这里仅给出其正逆解,然后会在一个专门的一篇文章中给出多种动力学建模方法以及相关代码,其推导过程整理成文档,如下所示：</p><embed width="1000" height="800" src="/pdfFile/ur5Kin.pdf"> </embed> <p>其中需要注意的是,以自身为参考系右乘变换矩阵,相对于静坐标系左乘变换矩阵。如果建立了动力学模型,那么就可以做一些相关的动力学仿真,比如仅受重力时的动态变化过程</p><p><img src="/img/postImg/33_rtb/onlyGrav.gif" width="80%" height="80%"></p><h1 id="重要函数说明"><a href="#重要函数说明" class="headerlink" title="重要函数说明"></a>重要函数说明</h1><p>由于此工具箱涵盖的内容非常多,这里仅对类函数<code>SerialLink</code>的功能进行了罗列。 通过<a href="https://www.petercorke.com/RTB/r9/html/SerialLink.html">peter</a>的网站关于串联机器人SerialLink类函数的讲解, 其方法(Methods)有</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">plot<span class="keyword">display</span> graphical representation of robot</span><br><span class="line">plot3d<span class="keyword">display</span> <span class="number">3</span>D graphical <span class="keyword">model</span> of robot</span><br><span class="line">teachdrive the graphical robot</span><br><span class="line">getposget position of graphical robot</span><br><span class="line">jtraja joint space trajectory</span><br><span class="line">edit<span class="keyword">display</span> <span class="keyword">and</span> edit kinematic <span class="keyword">and</span> dynamic <span class="keyword">parameters</span></span><br><span class="line">isspherical<span class="comment">test if robot has spherical wrist</span></span><br><span class="line">islimit<span class="comment">test if robot at joint limit</span></span><br><span class="line">isconfig<span class="comment">test robot joint configuration</span></span><br><span class="line">fkine<span class="comment">forward kinematics</span></span><br><span class="line">A<span class="comment">link transforms</span></span><br><span class="line">trchain<span class="comment">forward kinematics as a chain of elementary transforms</span></span><br><span class="line">ikine6s<span class="comment">inverse kinematics for 6-axis spherical wrist revolute robot</span></span><br><span class="line">ikine<span class="comment">inverse kinematics using iterative numerical method</span></span><br><span class="line">ikunc<span class="comment">inverse kinematics using optimisation</span></span><br><span class="line">ikcon<span class="comment">inverse kinematics using optimisation with joint limits</span></span><br><span class="line">ikine_sym<span class="comment">analytic inverse kinematics obtained symbolically</span></span><br><span class="line">jacob0<span class="comment">Jacobian matrix in world frame</span></span><br><span class="line">jacobn<span class="comment">Jacobian matrix in tool frame</span></span><br><span class="line">jacob_dot<span class="comment">Jacobian derivative</span></span><br><span class="line">maniplty<span class="comment">manipulability</span></span><br><span class="line">vellipse<span class="comment">display velocity ellipsoid</span></span><br><span class="line">fellipse<span class="comment">display force ellipsoid</span></span><br><span class="line">qmincon<span class="comment">null space motion to centre joints between limits</span></span><br><span class="line">accel<span class="comment">joint acceleration</span></span><br><span class="line">coriolis<span class="comment">Coriolis joint force</span></span><br><span class="line">dyn<span class="comment">show dynamic properties of links</span></span><br><span class="line">friction<span class="comment">friction force</span></span><br><span class="line">gravload<span class="comment">gravity joint force</span></span><br><span class="line">inertia<span class="comment">joint inertia matrix</span></span><br><span class="line">cinertia<span class="comment">Cartesian inertia matrix</span></span><br><span class="line">nofriction<span class="comment">set friction parameters to zero</span></span><br><span class="line">rne<span class="comment">inverse dynamics</span></span><br><span class="line">fdyn<span class="comment">forward dynamics</span></span><br><span class="line">payload<span class="comment">add a payload in end-effector frame</span></span><br><span class="line">perturb<span class="comment">randomly perturb link dynamic parameters</span></span><br><span class="line">gravjac<span class="comment">gravity load and Jacobian</span></span><br><span class="line">paycap<span class="comment">payload capacity</span></span><br><span class="line">pay<span class="comment">payload effect</span></span><br><span class="line">sym<span class="comment">a symbolic version of the object</span></span><br><span class="line">gencoords<span class="comment">symbolic generalized coordinates</span></span><br><span class="line">genforces<span class="comment">symbolic generalized forces</span></span><br><span class="line">issym<span class="comment">test if object is symbolic</span></span><br></pre></td></tr></table></figure><p>这里补充一句,差不多知道提供那些方法/功能就可以了,用到的时候,再继续深究。这里不对其进行翻译有很多原因,希望想接触机器人学的童鞋尽量去看英文。因为中文翻译错误挺多。可读写的属性有</p><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">Properties (read/write)</span><br><span class="line">linksvector <span class="keyword">of</span> Link objects (<span class="number">1</span>xN)</span><br><span class="line">gravitydirection <span class="keyword">of</span> gravity [gx gy gz]</span><br><span class="line">basepose <span class="keyword">of</span> robot<span class="symbol">&#x27;s</span> base (<span class="number">4</span>x4 homog xform)</span><br><span class="line">toolrobot<span class="symbol">&#x27;s</span> tool transform, T6 <span class="keyword">to</span> tool tip (<span class="number">4</span>x4 homog xform)</span><br><span class="line">qlimjoint limits, [qmin qmax] (Nx2)</span><br><span class="line">offsetkinematic joint coordinate offsets (Nx1)</span><br><span class="line">namename <span class="keyword">of</span> robot, used <span class="keyword">for</span> graphical display</span><br><span class="line">manufannotation, manufacturer<span class="symbol">&#x27;s</span> name</span><br><span class="line">commentannotation, general comment</span><br><span class="line">plotoptoptions <span class="keyword">for</span> plot() method (cell <span class="keyword">array</span>)</span><br><span class="line">fast<span class="keyword">use</span> MEX version <span class="keyword">of</span> RNE. Can only be set <span class="literal">true</span> <span class="keyword">if</span> the mex <span class="keyword">file</span> exists. <span class="keyword">Default</span> <span class="keyword">is</span> <span class="literal">true</span>.</span><br></pre></td></tr></table></figure><p>只读属性有</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Properties</span> (read only)</span><br><span class="line"><span class="attribute">n</span>number of joints</span><br><span class="line"><span class="attribute">config</span>joint configuration string, eg. &#x27;RRRRRR&#x27;</span><br><span class="line"><span class="attribute">mdh</span>kinematic convention boolean (<span class="number">0</span>=DH, <span class="number">1</span>=MDH)</span><br><span class="line"><span class="attribute">theta</span>kinematic: joint angles (<span class="number">1</span>xN)</span><br><span class="line"><span class="attribute">d</span>kinematic: link offsets (<span class="number">1</span>xN)</span><br><span class="line"><span class="attribute">a</span>kinematic: link lengths (<span class="number">1</span>xN)</span><br><span class="line"><span class="attribute">alpha</span>kinematic: link twists (<span class="number">1</span>xN)</span><br></pre></td></tr></table></figure><p>选项</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Options</span><br><span class="line"><span class="string">&#x27;name&#x27;</span>, NAME <span class="built_in">set</span> robot name property <span class="keyword">to</span> NAME</span><br><span class="line"><span class="string">&#x27;comment&#x27;</span>, COMMENT <span class="built_in">set</span> robot comment property <span class="keyword">to</span> COMMENT</span><br><span class="line"><span class="string">&#x27;manufacturer&#x27;</span>, MANUF <span class="built_in">set</span> robot manufacturer property <span class="keyword">to</span> MANUF</span><br><span class="line"><span class="string">&#x27;base&#x27;</span>, T <span class="built_in">set</span> base transformation matrix property <span class="keyword">to</span> T</span><br><span class="line"><span class="string">&#x27;tool&#x27;</span>, T <span class="built_in">set</span><span class="built_in"> tool </span>transformation matrix property <span class="keyword">to</span> T</span><br><span class="line"><span class="string">&#x27;gravity&#x27;</span>, G <span class="built_in">set</span> gravity vector property <span class="keyword">to</span> G</span><br><span class="line"><span class="string">&#x27;plotopt&#x27;</span>, P <span class="built_in">set</span><span class="built_in"> default </span>options <span class="keyword">for</span> .plot() <span class="keyword">to</span> P</span><br><span class="line"><span class="string">&#x27;plotopt3d&#x27;</span>, P <span class="built_in">set</span><span class="built_in"> default </span>options <span class="keyword">for</span> .plot3d() <span class="keyword">to</span> P</span><br><span class="line"><span class="string">&#x27;nofast&#x27;</span> don<span class="string">&#x27;t use RNE MEX file</span></span><br></pre></td></tr></table></figure><p>下面介绍重要的函数<br>1, <code>Robobt.plot</code></p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Graphical display <span class="keyword">and</span> animation</span><br><span class="line"></span><br><span class="line">R.plot(q, <span class="keyword">options</span>) displays a graphical animation <span class="keyword">of</span> a robot based <span class="keyword">on</span> the kinematic model.</span><br><span class="line">A stick figure polyline joins the origins <span class="keyword">of</span> the link coordinate frames. </span><br><span class="line">The robot <span class="keyword">is</span> displayed at the joint angle q (<span class="number">1</span>xN), <span class="keyword">or</span> <span class="keyword">if</span> a matrix (MxN) it <span class="keyword">is</span> animated <span class="keyword">as</span> </span><br><span class="line">the robot moves along the M-<span class="type">point</span> trajectory.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Options</span></span><br><span class="line"><span class="string">&#x27;workspace&#x27;</span>, W Size <span class="keyword">of</span> robot <span class="number">3</span>D workspace, W = [xmn, xmx ymn ymx zmn zmx]</span><br><span class="line"><span class="string">&#x27;floorlevel&#x27;</span>, LZ-coordinate <span class="keyword">of</span> floor (<span class="keyword">default</span> <span class="number">-1</span>)</span><br><span class="line"><span class="string">&#x27;delay&#x27;</span>, D Delay betwen frames <span class="keyword">for</span> animation (s)</span><br><span class="line"><span class="string">&#x27;fps&#x27;</span>, fps Number <span class="keyword">of</span> frames per second <span class="keyword">for</span> display, inverse <span class="keyword">of</span> <span class="string">&#x27;delay&#x27;</span> <span class="keyword">option</span></span><br><span class="line"><span class="string">&#x27;[no]loop&#x27;</span> <span class="keyword">Loop</span> <span class="keyword">over</span> the trajectory forever</span><br><span class="line"><span class="string">&#x27;[no]raise&#x27;</span> Autoraise the figure</span><br><span class="line"><span class="string">&#x27;movie&#x27;</span>, M Save frames <span class="keyword">as</span> files <span class="keyword">in</span> the folder M</span><br><span class="line"><span class="string">&#x27;trail&#x27;</span>, L Draw a <span class="type">line</span> recording the tip <span class="type">path</span>, <span class="keyword">with</span> <span class="type">line</span> style L</span><br><span class="line"><span class="string">&#x27;scale&#x27;</span>, S Annotation scale factor</span><br><span class="line"><span class="string">&#x27;zoom&#x27;</span>, Z Reduce size <span class="keyword">of</span> auto-computed workspace <span class="keyword">by</span> Z, makes robot look bigger</span><br><span class="line"><span class="string">&#x27;ortho&#x27;</span>Orthographic <span class="keyword">view</span></span><br><span class="line"><span class="string">&#x27;perspective&#x27;</span> Perspective <span class="keyword">view</span> (<span class="keyword">default</span>)</span><br><span class="line"><span class="string">&#x27;view&#x27;</span>, V Specify <span class="keyword">view</span> V=<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;top&#x27;</span> <span class="keyword">or</span> [az el] <span class="keyword">for</span> side elevations, </span><br><span class="line">plan <span class="keyword">view</span>, <span class="keyword">or</span> general <span class="keyword">view</span> <span class="keyword">by</span> azimuth <span class="keyword">and</span> elevation angle.</span><br><span class="line"><span class="string">&#x27;top&#x27;</span> <span class="keyword">View</span> <span class="keyword">from</span> the top.</span><br><span class="line"><span class="string">&#x27;[no]shading&#x27;</span> <span class="keyword">Enable</span> Gouraud shading (<span class="keyword">default</span> <span class="keyword">true</span>)</span><br><span class="line"><span class="string">&#x27;lightpos&#x27;</span>, L Position <span class="keyword">of</span> the light source (<span class="keyword">default</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">20</span>])</span><br><span class="line"><span class="string">&#x27;[no]name&#x27;</span> Display the robot<span class="string">&#x27;s name</span></span><br><span class="line"><span class="string">&#x27;</span>[<span class="keyword">no</span>]wrist<span class="string">&#x27; Enable display of wrist coordinate frame</span></span><br><span class="line"><span class="string">&#x27;</span>xyz<span class="string">&#x27; Wrist axis label is XYZ</span></span><br><span class="line"><span class="string">&#x27;</span>noa<span class="string">&#x27; Wrist axis label is NOA</span></span><br><span class="line"><span class="string">&#x27;</span>[<span class="keyword">no</span>]arrow<span class="string">&#x27; Display wrist frame with 3D arrows</span></span><br><span class="line"><span class="string">&#x27;</span>[<span class="keyword">no</span>]tiles<span class="string">&#x27; Enable tiled floor (default true)</span></span><br><span class="line"><span class="string">&#x27;</span>tilesiz<span class="string">e&#x27;, S Side length of square tiles on the floor (default 0.2)</span></span><br><span class="line"><span class="string">&#x27;</span>tile1color<span class="string">&#x27;, CColor of even tiles [r g b] (default [0.5 1 0.5] light green)</span></span><br><span class="line"><span class="string">&#x27;</span>tile2color<span class="string">&#x27;, CColor of odd tiles [r g b] (default [1 1 1] white)</span></span><br><span class="line"><span class="string">&#x27;</span>[<span class="keyword">no</span>]shadow<span class="string">&#x27; Enable display of shadow (default true)</span></span><br><span class="line"><span class="string">&#x27;</span>shadowcolor<span class="string">&#x27;, C Colorspec of shadow, [r g b]</span></span><br><span class="line"><span class="string">&#x27;</span>shadowwidth<span class="string">&#x27;, W Width of shadow line (default 6)</span></span><br><span class="line"><span class="string">&#x27;</span>[<span class="keyword">no</span>]jaxes<span class="string">&#x27; Enable display of joint axes (default false)</span></span><br><span class="line"><span class="string">&#x27;</span>[<span class="keyword">no</span>]jvec<span class="string">&#x27; Enable display of joint axis vectors (default false)</span></span><br><span class="line"><span class="string">&#x27;</span>[<span class="keyword">no</span>]joints<span class="string">&#x27; Enable display of joints</span></span><br><span class="line"><span class="string">&#x27;</span>jointcolor<span class="string">&#x27;, CColorspec for joint cylinders (default [0.7 0 0])</span></span><br><span class="line"><span class="string">&#x27;</span>jointdiam<span class="string">&#x27;, D Diameter of joint cylinder in scale units (default 5)</span></span><br><span class="line"><span class="string">&#x27;</span>linkcolor<span class="string">&#x27;, C Colorspec of links (default &#x27;</span>b<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">&#x27;</span>[<span class="keyword">no</span>]bas<span class="string">e&#x27; Enable display of base &#x27;</span>pedestal<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#x27;</span>basecolor<span class="string">&#x27;, C Color of base (default &#x27;</span>k<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">&#x27;</span>basewidth<span class="string">&#x27;, W Width of base (default 3)</span></span><br></pre></td></tr></table></figure><p>根据这些选项能够自定义绘图连杆的颜色,地板颜色,轴的局部坐标系等信息了。 </p><p>2, <code>SerialLink.rne</code></p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Inverse dynamics</span><br><span class="line"></span><br><span class="line">tau = R.rne(q, qd, qdd) <span class="keyword">is</span> <span class="keyword">the</span> joint torque required <span class="keyword">for</span> <span class="keyword">the</span> robot R <span class="keyword">to</span> achieve <span class="keyword">the</span> specified </span><br><span class="line">joint position q (<span class="number">1</span>xN), velocity qd (<span class="number">1</span>xN) <span class="keyword">and</span> acceleration qdd (<span class="number">1</span>xN), <span class="keyword">where</span> N <span class="keyword">is</span> <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> robot joints.</span><br><span class="line"></span><br><span class="line">tau = R.rne(q, qd, qdd, grav) <span class="keyword">as</span> <span class="keyword">above</span> <span class="keyword">but</span> overriding <span class="keyword">the</span> gravitational acceleration vector (<span class="number">3</span>x1) <span class="keyword">in</span> <span class="keyword">the</span> robot object R.</span><br><span class="line"></span><br><span class="line">tau = R.rne(q, qd, qdd, grav, fext) <span class="keyword">as</span> <span class="keyword">above</span> <span class="keyword">but</span> specifying a wrench acting <span class="keyword">on</span> <span class="keyword">the</span> <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">the</span> manipulator </span><br><span class="line">which <span class="keyword">is</span> a <span class="number">6</span>-vector [Fx Fy Fz Mx My Mz].</span><br><span class="line"></span><br><span class="line">tau = R.rne(x) <span class="keyword">as</span> <span class="keyword">above</span> <span class="keyword">where</span> x=[q,qd,qdd] (<span class="number">1</span>x3N).</span><br><span class="line"></span><br><span class="line">tau = R.rne(x, grav) <span class="keyword">as</span> <span class="keyword">above</span> <span class="keyword">but</span> overriding <span class="keyword">the</span> gravitational acceleration vector <span class="keyword">in</span> <span class="keyword">the</span> robot object R.</span><br><span class="line"></span><br><span class="line">tau = R.rne(x, grav, fext) <span class="keyword">as</span> <span class="keyword">above</span> <span class="keyword">but</span> specifying a wrench acting <span class="keyword">on</span> <span class="keyword">the</span> <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">the</span> manipulator </span><br><span class="line">which <span class="keyword">is</span> a <span class="number">6</span>-vector [Fx Fy Fz Mx My Mz].</span><br><span class="line"></span><br><span class="line">[tau,wbase] = R.rne(x, grav, fext) <span class="keyword">as</span> <span class="keyword">above</span> <span class="keyword">but</span> <span class="keyword">the</span> extra output <span class="keyword">is</span> <span class="keyword">the</span> wrench <span class="keyword">on</span> <span class="keyword">the</span> base.</span><br></pre></td></tr></table></figure><p>有几种办法可以得到其正运动学的齐次变换矩阵, 在此之前先说两个方法里的函数 <code>R.A</code>,<code>R.fkine</code> 其中A表示的是连杆之间的变换,fkine给出的是最后变换的4*4矩阵,其输入参数有两个,一个是连杆的编号,另外一个是关节角度(可以是符号)。例如</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mdl_ur5</span>;</span><br><span class="line"><span class="attribute">ur5</span>.A(<span class="number">1</span>,<span class="number">1</span>)  %当theta1 = <span class="number">1</span>时的变换矩阵,也就是基座到坐标系<span class="number">1</span>的齐次变换矩阵</span><br><span class="line"><span class="attribute">ur5</span>.A(<span class="number">2</span>,[rand,<span class="number">1</span>]) %当theta2 = <span class="number">1</span>时的变换矩阵,从坐标系<span class="number">1</span>到坐标系<span class="number">2</span>的齐次变换矩阵,此时与theta1没有什么关系</span><br><span class="line"><span class="attribute">ur5</span>.A(<span class="number">1</span>:<span class="number">2</span>,[<span class="number">1</span>,<span class="number">1</span>]) %从基座到坐标系<span class="number">2</span>的齐次变换矩阵</span><br><span class="line"><span class="attribute">ur5</span>.A(<span class="number">1</span>:<span class="number">6</span>,ones(<span class="number">1</span>,<span class="number">6</span>)) %从基座到末端的变换矩阵</span><br></pre></td></tr></table></figure><p>验证结果如下</p><p> <img src="/img/postImg/33_rtb/test_fkine.png" width="60%" height="50%"> </p><p>如果喜欢花里胡哨的,可以考虑修改下R.plot中的参数,鉴于参数比较多,这里就说一个比较有意思的——写字,可以使用<code>trail</code>这个参数,可以需要将想写的字通过逆解求出来,然后再绘制出来,这样可以优化上面写的<code>青春</code>,这里做一个简要的演示,用的指令为</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">load(<span class="string">&#x27;Qing&#x27;</span>); <span class="comment">%事先求好的逆解</span></span><br><span class="line">mdl_ur5;</span><br><span class="line">ur5.<span class="built_in">plot</span>(qlist(<span class="number">1</span>:<span class="number">5</span>:<span class="keyword">end</span>,:),<span class="string">&#x27;trail&#x27;</span>,<span class="string">&#x27;-b&#x27;</span>)  <span class="comment">%为了绘制的快一些,以5个点为间隔</span></span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="/img/postImg/33_rtb/qing.gif" width="80%" height="80%"></p><h1 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h1><p>主要还是对标准的DH方法建立的模型进行阐述,因为在进行动力学代码编写的时候,感受到了那块的不易理解。顺便吐槽下国内的一些教材,当时在写递推Newton-Euler法建立的动力学的模型时,参考了国内两本教材(一本用的标准的DH,另外一本用的改进的)看得我当时就哭晕了过去.就不能标准下吗。。。。。好处就是对理论有了更好的理解(并不意味着可以很好的表述出来),当然,建立动力学模型的方法有很多,可以参考刘延柱老师的《多体系统动力学》</p><p>串联机械臂的链路是由连杆组成,这些连杆由关节(运动副)连接起来。一般用R表示转动副,P表示移动副。这里的运动副在维基百科下的定义为</p><p>运动副是两个机械构件之间通过直接接触而组成的可动连接。两个构件上参与接触而构成运动副的点、线、面等元素被称为运动副元素。</p><p>1, 两构件在未构成运动副之前,在空间中有6个相对自由度,构成运动副后,它们之间的相对运动将受到约束,约束数最少为1,最多为5。<br>常根据引入约束的数目将运动副分类,把引入一个约束的运动副成为一级副,以此类推引入两个约束的运动副称为二级副,还有三级,四级,五级副。</p><p>2, 按照运动副的接触形式分类。面和面接触的运动副在接触部分的压强较低,被称为低副,<br>而通过点或线接触构成的运动副称为高副,高副比低副容易磨损。</p><p>3, 按照相对运动的形式分类。构成运动副的两个构件之间的相对运动若是平面运动则为平面运动副,若为空间运动则称为空间运动副,<br>两个构件之间的相对运动为转动的运动副被称为转动副或回转副,也称铰链。相对运动为移动的运动副称为移动副；<br>相对运动为螺旋运动的运动副称为螺旋副；相对运动为球面运动的运动副称为球面副。</p><h2 id="标准DH与改进DH的不同"><a href="#标准DH与改进DH的不同" class="headerlink" title="标准DH与改进DH的不同"></a>标准DH与改进DH的不同</h2><h3 id="从变换公式来观察"><a href="#从变换公式来观察" class="headerlink" title="从变换公式来观察"></a>从变换公式来观察</h3><p>连杆变换是由基本旋转和平移变换所组成, 标准的DH参数的变换法则如下(后置)</p><div align="center"> <img src="/img/postImg/33_rtb/DH_Transform/std_transform.png" width="30%" height="30%"> </div><p>改进的DH参数的变换法则如下(前置)</p><div align="center"> <img src="/img/postImg/33_rtb/DH_Transform/mdh_transform.png" width="30%" height="30%"> </div><h2 id="从图中来观察"><a href="#从图中来观察" class="headerlink" title="从图中来观察"></a>从图中来观察</h2><p>标准的DH</p><div align="center"> <img src="/img/postImg/33_rtb/classic_dh_parameters.png" width="30%" height="40%"> </div><p>改进的DH</p><div align="center"> <img src="/img/postImg/33_rtb/MDH.png" width="30%" height="40%"> </div><p>从图中可以看出,标准 DH 是将连的坐标系固定在连杆的后端,即坐标系 <img src="/img/postImg/mathSym/O_i_minus_1.png" width="2%" height="2%"> 与关节i对齐,而改进的 DH 则是将连杆坐标系固定在连杆的前端,也即坐标系 <img src="/img/postImg/mathSym/O_i_minus_1.png" width="2%" height="2%">  与关节i-1 对齐。为了凸显其中的不同,可以参考下面的表格:</p><div align="center"><table id="hor-zebra" summary="Employee Pay Sheet">      <thead>                                              <tr>                                             <th scope="col">SDH</th>            <th scope="col">MDH</th>                  </tr>                                            </thead>                                             <tbody>                                              <tr>                                             <td>关节坐标系为其固连坐标系 </td>                    <td>以连杆的前一个关节坐标系为其固连坐标系 </td>                                </tr>                                            <tr class="odd">                                 <td> 以当前 Z 轴和“前一个”坐标系的 Z轴叉乘确定 X轴   </td>                      <td> 以“后一个”坐标的Z轴与当前Z轴叉乘确定X轴 </td>                                </tr>                                            <tr>                                             <td>  相关节坐标系之间的参数变化顺序为： <img src="/img/postImg/33_rtb/DH_Transform/std变换.png" width="20%" height="20%">  </td>                 <td> 相关节坐标系之间的参数变化顺序为:  <img src="/img/postImg/33_rtb/DH_Transform/mdh变换.png" width="20%" height="20%"> </td>                                </tr>                                            </tbody>                                             </table>                                                </div><p>另外需要说明一点，MDH中所给的公式里，<img src="/img/postImg/mathSym/alpha.png" width="1%" height="1%">,与a参数下标都是i-1, 这个i-1说明的是用的SDH参数表中的内容，所以一般给的MDH表中<img src="/img/postImg/mathSym/alpha.png" width="1%" height="1%">和a都会比SDH表中往下移动一位；</p><h1 id="微分运动和广义速度"><a href="#微分运动和广义速度" class="headerlink" title="微分运动和广义速度"></a>微分运动和广义速度</h1><p>刚体或坐标系的微分运动包含微分移动矢量d和微分转动矢量<img src="/img/postImg/mathSym/delta.png" width="1%" height="1%">。前者由沿三个坐标轴的微分移动组成,后者由绕三坐标轴的微分转动组成,即</p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/微分移动.png" width="30%" height="30%"> </div><div align="center"> <img src="/img/postImg/33_rtb/微分运动/微分转动.png" width="30%" height="30%"> </div><p>将两者合并为6维列矢量 D , 称为刚体或坐标系的微分运动矢量：</p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/微分运动矢量.png" width="5%" height="5%"> </div><p>相应的,刚体或坐标系的广义速度V是由线速度v和角速度 <img src="/img/postImg/mathSym/omega.png" width="1%" height="1%"> 组成的6维列矢量：</p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/六维列矢量.png" width="10%" height="10%"> </div><p>微分运动矢量 D 和广义速度 V 也是相对于某坐标系而言的。在不同的坐标系中表示是不同的。若相对基坐标系(或参考系)的微分运动为 D (d 和 <img src="/img/postImg/mathSym/delta.png" width="1%" height="1%">), 则相对坐标系 {T},</p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/T的齐次坐标表示.png" width="30%" height="30%"> </div><p>的微分运动 <img src="/img/postImg/33_rtb/微分运动/TD.png" width="2%" height="2%"></p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/TD的微分运动.png" width="30%" height="30%"> </div><div align="center"> <img src="/img/postImg/33_rtb/微分运动/转动的微分.png" width="10%" height="10%"> </div><p>合并上式, 可以得到<img src="/img/postImg/33_rtb/微分运动/TD.png" width="2%" height="2%">与D的关系为</p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/TD与T的关系.png" width="30%" height="30%"> </div><p>上式可简写为</p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/TD与T的关系简写.png" width="20%" height="20%"> </div><p>对于任何 3 维矢量  p= [p_x, p_y, p_z]。其反对称矩阵S(p)定义为</p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/反对称矩阵的定义.png" width="20%" height="20%"> </div><p>它具有以下性质：</p><p>(1) <img src="/img/postImg/33_rtb/微分运动/反对称矩阵的性质1.png" width="20%" height="20%"><br>(2) <img src="/img/postImg/33_rtb/微分运动/反对称矩阵的性质2.png" width="20%" height="20%"><br>(3) <img src="/img/postImg/33_rtb/微分运动/反对称矩阵的性质3.png" width="20%" height="20%"><br>相应地,广义速度 V 的坐标变换为</p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/广义速度的坐标变换.png" width="20%" height="20%"> </div><p>任意两坐标系{A}和{B}之间广义速度的坐标变换为</p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/任意两坐标系的广义速度变换公式.png" width="20%" height="20%"> </div><h1 id="雅可比矩阵的构造法"><a href="#雅可比矩阵的构造法" class="headerlink" title="雅可比矩阵的构造法"></a>雅可比矩阵的构造法</h1><p>雅可比矩阵J(q)既可当成是从关节空间向操作空间的速度传递的线性关系,也可看成是微分运动转换的线性关系,即</p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/雅可比矩阵与关节空间向操作空间的速度传递关系.png" width="10%" height="10%"> </div><p>对于 n 个关节的机器人,其雅可比J(q)是 6 * n  阶矩阵。其中前 3 行代表对手爪线速度 v 的传递比；后 3 行代表对手爪的角速度 <img src="/img/postImg/mathSym/omega.png" width="1%" height="1%"> 的传递比。另一方面,每一列代表相应的关节速度 <img src="/img/postImg/mathSym/dot_q.png" width="1%" height="1%">, 对于手爪线速度和角速度的传递比;</p><h1 id="力雅可比"><a href="#力雅可比" class="headerlink" title="力雅可比"></a>力雅可比</h1><p>机器人与外界环境相互作用时, 在接触的地方要产生力 f 和力矩 n, 统称为末端广义(操作)力矢量, 记为：</p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/广义操作力矢量.png" width="10%" height="10%"> </div><p>例如, 操作臂提取重物时承受的外界作用力和力矩。在静止状态下,广义操作力矢量F应与各关节的驱动力(或力矩)相平衡。n 个关节的驱动力组成的n维矢量</p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/N维驱动矢量.png" width="20%" height="20%"> </div><p>称为关节力矢量。 利用虚功原理, 可以得到关节力矢量 <img src="/img/postImg/mathSym/tau.png" width="1%" height="1%"> 与相应的广义操作力矢量F之间的关系。令各关节的虚位移为 <img src="/img/postImg/mathSym/delta.png" width="1%" height="1%"> q, 末端执行器相应的虚位移为D。所谓的虚位移,是满足机械系统几何约束的无限小位移。各关节所作的虚功只和 <img src="https://latex.codecogs.com/png.latex?W = \tau^T\delta q = \tau_1\delta q_1 + \tau_2\delta q_2 + \cdots + \tau_n\delta q_n"/> 与末端执行器所作的虚功 <img src="https://latex.codecogs.com/png.latex?W=F^TD=f^Td + n^T\delta"/> 应该相等(总的虚功为零),即</p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/虚功定理.png" width="20%" height="20%"> </div><p>不难得到</p><div align="center"> <img src="/img/postImg/33_rtb/微分运动/操作力与关节力的线性映射.png" width="10%" height="10%"> </div><p>式中,<img src="https://latex.codecogs.com/png.latex? J^T(q)"/> 称为操作臂的力雅可比, 它表示在静态平衡状态下, 操作力向关节力映射的线性关系。</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>1, 工具箱使用的关节坐标都是行向量.</p><p>2, 判别给的是标准DH还是改进DH,可从给的参数栏的下标入手,如果有相同的下标,则是标准,否则,为改进的DH参数。</p><p>3, 想同时展示多个机器人,比如两个机器人,需要创建一个机器人的复本,其基座处在不同的位置,这样就可以同时展示两个机器人了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://petercorke.com/rvc/home/">Robotics, Vision and Control Fundamental algorithms in MATLAB: Second Edition》Peter</a></p><p>[2] <a href="https://zh.wikipedia.org/wiki/%E8%BF%90%E5%8A%A8%E5%89%AF">运动副—维基百科</a></p><p>[3] <a href="https://blog.csdn.net/qq_35551200/article/details/97030782">matlab中Link函数与SeriaLink函数学习笔记 —红烧肉不好吃</a></p><p>[4] 机器人技术基础 — 熊有伦</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>由于latex.codecogs.com挂了，里面的公式目前都无法显示，正在处理中。。。。。。截止目前已经处理了百分之五十了；</p>]]></content>
      
      
      <categories>
          
          <category> ROBOTICS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> robot </tag>
            
            <tag> matlab </tag>
            
            <tag> rtb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 学习(一)</title>
      <link href="/2020/07/18/archived_python2020/"/>
      <url>/2020/07/18/archived_python2020/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a><ul><li><a href="#基础知识">基础知识</a></li><li><a href="#读取文件">读取文件</a><ul><li><a href="#读取文件夹下所有的文件">读取文件夹下所有的文件</a></li></ul></li><li><a href="#序列函数">序列函数</a><ul><li><a href="#enumerate函数">enumerate函数</a></li><li><a href="#zip函数">zip函数</a></li></ul></li><li><a href="#字典">字典</a><ul><li><a href="#用序列创建字典">用序列创建字典</a></li><li><a href="#有效的键类型">有效的键类型</a></li></ul></li><li><a href="#集合">集合</a></li><li><a href="#列表集合和字典推导式">列表、集合和字典推导式</a></li><li><a href="#python-合并字典">Python 合并字典</a></li><li><a href="#函数">函数</a><ul><li><a href="#命名空间作用域">命名空间、作用域</a></li><li><a href="#生成器">生成器</a></li><li><a href="#生成器表达式">生成器表达式</a></li></ul></li></ul></li><li><a href="#python字符串前面加urb的含义">python字符串前面加u,r,b的含义</a><ul><li><a href="#文件和操作系统">文件和操作系统</a><ul><li><a href="#python文件打开方式">python文件打开方式</a></li></ul></li><li><a href="#python绘图">python绘图</a><ul><li><a href="#matplotlib">matplotlib</a><ul><li><a href="#显示中文标题">显示中文标题</a></li><li><a href="#seaborn-的使用">seaborn 的使用</a></li></ul></li></ul></li><li><a href="#pandas的数据结构介绍">pandas的数据结构介绍</a><ul><li><a href="#series">Series</a></li><li><a href="#dataframe">DataFrame</a></li></ul></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在18年的时候就把python的基本语法过了一遍了,无奈matlab和mathematica太好用了,所以python这个工具就一直被我给冷落了,现在重新拾起。文中的内容,有些是书本里面的,有些源自于菜鸟教程和一些零散的博客所汇聚而成,仅供自己学习和参考使用。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li><p>以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性,需通过类提供的接口进行访问,不能用 from xxx import * 而导入。 以双下划线开头的__foo 代表类的私有成员,以双下划线开头和结尾的 __foo__ 代表 Python 里特殊方法专用的标识,如 __init__() 代表类的构造函数。</p></li><li><p>if __name__ == ‘__main__‘的意思是：当.py文件被直接运行时,if __name__ == ‘__main__‘之下的代码块将被运行；当.py文件以模块形式被导入时,if __name__ == ‘__main__‘之下的代码块不被运行。</p></li><li><p>对程序计时可用如下两种方式：</p><p>1)time.time() 返回的是一个浮点型类型。这里获取的也是<strong>程序的执行时间</strong>。使用方法如下所示</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">start = <span class="type">time</span>.time()</span><br><span class="line">#^_^</span><br><span class="line">end = <span class="type">time</span>.time()</span><br><span class="line">print (<span class="keyword">end</span>-<span class="keyword">start</span>)</span><br></pre></td></tr></table></figure><p>2) time.clock()返回程序开始或第一次被调用clock()以来的CPU时间。这里获得的是<strong>CPU的执行时间</strong>。调用方式只需要把time.time()换成 time.clock()即可。</p></li></ol><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><h3 id="读取文件夹下所有的文件"><a href="#读取文件夹下所有的文件" class="headerlink" title="读取文件夹下所有的文件"></a>读取文件夹下所有的文件</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">os</span></span><br><span class="line">fileList = <span class="built_in">os</span>.listdir(<span class="built_in">path</span>)</span><br></pre></td></tr></table></figure><h2 id="序列函数"><a href="#序列函数" class="headerlink" title="序列函数"></a>序列函数</h2><h3 id="enumerate函数"><a href="#enumerate函数" class="headerlink" title="enumerate函数"></a>enumerate函数</h3><p>迭代一个序列时,你可能想跟踪当前项的序号。手动的方法可能是下面这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> collection:</span><br><span class="line">    <span class="comment"># do something with value </span></span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>因为这么做很常见,Python内建了一个 enumerate 函数,可以返回 (i, value) 元组序列：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(collection): </span><br><span class="line"><span class="comment"># do something with value</span></span><br></pre></td></tr></table></figure><p>当你索引数据时,使用 enumerate 的一个好方法是计算序列(唯一的) dict 映射到位置的值。</p><h3 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h3><p>zip 可以将多个列表、元组或其它序列成对组合成一个元组列表。zip 可以处理任意多的序列,元素的个数取决于最短的序列。zip 的常见用法之一是同时迭代多个序列,可以结合 enumerate 使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(seq1, seq2)):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;: &#123;1&#125;, &#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(i, a, b))</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典可能是Python最为重要的数据结构。它更为常见的名字是哈希映射或关联数组。它是键值对的大小可变集合,键和值都是Python对象。创建字典的方法之一是使用大括号,用冒号分隔键和值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">empty_dict = &#123;&#125; </span><br><span class="line">d1 = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="string">&#x27;some value&#x27;</span>, <span class="string">&#x27;b&#x27;</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;</span><br></pre></td></tr></table></figure><p>可以像访问列表或元组中的元素一样,访问、插入或设定字典中的元素,也可以用检查列表和元组是否包含某个值的方法,检查字典中是否包含某个键。keys 和 values 是字典的键和值的迭代器方法。虽然键值对没有顺序,这两个方法可以用相同的顺序输出键和值：用 update 方法可以将一个字典与另一个融合： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1.update(&#123;<span class="string">&#x27;b&#x27;</span> : <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;c&#x27;</span> : <span class="number">12</span>&#125;)</span><br></pre></td></tr></table></figure><p>update 方法是原地改变字典,因此任何传递给 update 的键的旧的值都会被舍弃。</p><h3 id="用序列创建字典"><a href="#用序列创建字典" class="headerlink" title="用序列创建字典"></a>用序列创建字典</h3><p>可能想将两个序列配对组合成字典。下面是一种写法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mapping = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">zip</span>(key_list, value_list): </span><br><span class="line">mapping[key] = value</span><br></pre></td></tr></table></figure><p>因为字典本质上是2元元组的集合,dict可以接受2元元组的列表：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mapping = <span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">5</span>), <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">5</span>))))</span><br></pre></td></tr></table></figure><p>下面的逻辑很常见：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> some_dict: </span><br><span class="line">value = some_dict[key]</span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">value = default_value</span><br></pre></td></tr></table></figure><p>因此,dict的方法get和pop可以取默认值进行返回,上面的if-else语句可以简写成下面：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = some_dict.get(key, default_value)</span><br></pre></td></tr></table></figure><h3 id="有效的键类型"><a href="#有效的键类型" class="headerlink" title="有效的键类型"></a>有效的键类型</h3><p>字典的值可以是任意Python 对象,而键通常是不可变的标量类型(整数、浮点型、字符串)或元组(元组中的对象必须是不可变的)。这被称为“可哈希性”。可以用 hash 函数检测一个对象是否是可哈希的。 要用列表当做键,一种方法是将列表转化为元组,只要内部元素可以被哈希,它也就可以被哈希。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是无序的不可重复的元素的集合。可以把它当做字典,但是只有键没有值。可以用两种方式创建集合：通过 set 函数或使用尖括号 set 语句.集合支持合并、交集、差分和对称差等数学集合运算. 合并是取两个集合中不重复的元素。可以用 union 方法,或者运算符|.交集的元素包含在两个集合中。可以用 intersection 或&amp;运算符.所有逻辑集合操作都有另外的原地实现方法,可以直接用结果替代集合的内容。对于大的集合,这么做效率更高.与字典类似,集合元素通常都是不可变的。要获得类似列表的元素,必须转换成元组.</p><h2 id="列表、集合和字典推导式"><a href="#列表、集合和字典推导式" class="headerlink" title="列表、集合和字典推导式"></a>列表、集合和字典推导式</h2><p>列表推导式允许用户方便的从一个集合过滤元素,形成列表在传递参数的过程中还可以修改元素。形式如下</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="string">[expr for val in collection if condition]</span></span><br></pre></td></tr></table></figure><p>它等同于下面的 for 循环:</p><figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="built_in">result</span> = [ ]</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> collection:</span><br><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line"><span class="built_in">result</span>.append(<span class="type">expr</span>)</span><br></pre></td></tr></table></figure><p>用相似的方法,还可以推导集合和字典。字典的推导式如下所示<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">dic = &#123;<span class="built_in">key</span>: value-<span class="keyword">expr</span> <span class="keyword">for</span> value in collection if condition&#125;</span><br></pre></td></tr></table></figure><br>集合的推导式与列表很像,只不过用的是尖括号</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">set_comp</span> = &#123;expr for value in collection if condition&#125;</span><br></pre></td></tr></table></figure><p>与列表推导式类似,集合与字典的推导也很方便,而且使代码的读写都很容易。来看前面的字符串列表。假如我们只想要字符串的长度,用集合推导式的方法非常方便.</p><h2 id="Python-合并字典"><a href="#Python-合并字典" class="headerlink" title="Python 合并字典"></a>Python 合并字典</h2><p>1,使用 <code>update()</code> 方法,第二个参数合并第一个参数</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">def <span class="built_in">Merge</span>(dict1, dict2): </span><br><span class="line">    <span class="built_in">return</span>(dict2.<span class="built_in">update</span>(dict1)) </span><br></pre></td></tr></table></figure><p>2,  使用 <code>**</code>, 函数将参数以字典的形式导入</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">def Merge(<span class="keyword">dict1, </span><span class="keyword">dict2): </span></span><br><span class="line">    res = &#123;**<span class="keyword">dict1, </span>**<span class="keyword">dict2&#125; </span></span><br><span class="line">    return res </span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数使用 def 关键字声明,用 return 关键字返回值,如果到达函数末尾时没有遇到任何一条return语句,则返回 None。 函数可以有一些位置参数(positional)和一些关键字参数(keyword)。关键字参数通常用于指定 默认值或可选参数。</p><h3 id="命名空间、作用域"><a href="#命名空间、作用域" class="headerlink" title="命名空间、作用域"></a>命名空间、作用域</h3><p>函数可以访问两种不同作用域中的变量：全局(global)和局部(local)。任何在函数中赋值的变量默认都是被分配到局部命名空间(local namespace)中的。局部命名空间是在函数被调用时创建的,函数参数会立即填入该命名空间。在函数执行完毕之后,局部命名空间就会被销毁</p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>能以一种一致的方式对序列进行迭代(比如列表中的对象或文件中的行)。通过一种叫做迭代器协议 iterator protocol,它是一种使对象可迭代的通用方式)的方式实现的,一个原生的使对象可迭代的方法。生成器(generator)是构造新的迭代对象的一种简单方式。一般的函数执行之后只会返回单个值,而生成器则是以延退的方式返回一个值序列,即每返回一个值之后暂停,直到下一个值被请求时再继续。要创建一个生成器,只需将函数中的 return 替换为 yeild 即可。调用该生成器时,没有任何代码会被立即执行。直到请求元素时,它オ会开始执行其代码。</p><h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>另一种更简洁的构造生成器的方法是使用生成器表达式(generator expression)。这是一种类似于列表、字典、集合推导式的生成器。其创建方式为,把列表推导式两端的方括号改成圆括号。</p><h1 id="python字符串前面加u-r-b的含义"><a href="#python字符串前面加u-r-b的含义" class="headerlink" title="python字符串前面加u,r,b的含义"></a>python字符串前面加u,r,b的含义</h1><p>u/U:<code>表示unicode字符串</code>。不是仅仅是针对中文, 可以针对任何的字符串,代表是对字符串进行unicode编码。一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。<br>建议所有编码方式采用utf8</p><p>r/R:<code>非转义的原始字符串</code>。与普通字符相比,其他相对特殊的字符,其中可能包含转义字符,即那些,反斜杠加上对应字母,表示对应的特殊含义的,比如最常见的”\n”表示换行,”\t”表示Tab等。而如果是以r开头,那么说明后面的字符,都是普通的字符了,即如果是“\n”那么表示一个反斜杠字符,一个字母n,而不是表示换行了。以r开头的字符,常用于正则表达式,对应着re模块。</p><p>b:<code>bytes</code>。python3.x里默认的str是(py2.x里的)unicode, bytes是(py2.x)的str, b”“前缀代表的就是bytespython2.x里, b前缀没什么具体意义, 只是为了兼容python3.x的这种写法。</p><h2 id="文件和操作系统"><a href="#文件和操作系统" class="headerlink" title="文件和操作系统"></a>文件和操作系统</h2><p>为了打开一个文件以便读写,可以使用内置的open函数以及一个相对或绝对的文件路径。从文件中取出的行都带有完整的行结束符(EOL),因此你常常会看到下面这样的代码(得到一组<strong>没有EOL的行</strong>)：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lines = [x.rstrip() <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(path)]</span><br></pre></td></tr></table></figure><p>如果使用open创建文件对象,一定要用close关闭它。关闭文件可以返回操作系统资源：</p><figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">f.<span class="keyword">close</span>()</span><br></pre></td></tr></table></figure><p>用with语句可以可以更容易地清理打开的文件：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (path) <span class="keyword">as</span> f:</span><br><span class="line"><span class="keyword">lines</span> = [x.rstrip() <span class="keyword">for</span> x <span class="keyword">in</span> f]</span><br></pre></td></tr></table></figure><p>这样可以在退出代码块时,自动关闭文件。向文件写入,可以使用文件的write或writelines方法。例如,创建一个无空行版的</p><figure class="highlight sml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="symbol">&#x27;tmp</span>.txt&#x27;,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> <span class="keyword">handle</span>:</span><br><span class="line"><span class="keyword">handle</span>.writelines(x for x <span class="keyword">in</span> <span class="keyword">open</span>(path) <span class="keyword">if</span> len(x) &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="symbol">&#x27;tmp</span>.txt&#x27;) <span class="keyword">as</span> f:</span><br><span class="line">lines = f.readlines<span class="literal">()</span></span><br></pre></td></tr></table></figure><p>最常用的文件方法如下表所示：</p><div class="table-container"><table><thead><tr><th>方法              &emsp;</th><th>说明</th></tr></thead><tbody><tr><td>read([size])      &emsp;</td><td>以字符串形式返回文件数据,可选的size参数用于说明读取的字节数</td></tr><tr><td>readlines([size]) &emsp;</td><td>将文件返回为行列表,可选参数size</td></tr><tr><td>write(str)        &emsp;</td><td>将字符串写入文件</td></tr><tr><td>close()           &emsp;</td><td>关闭句柄</td></tr><tr><td>flush()           &emsp;</td><td>清空内部I/O缓存区,并将数据强行写回磁盘</td></tr><tr><td>seek(pos)         &emsp;</td><td>移动到指定的文件位置(整数)</td></tr><tr><td>tell              &emsp;</td><td>以整数形式返回当前文件位置</td></tr><tr><td>closed()          &emsp;</td><td>如果文件已关闭,则为True</td></tr></tbody></table></div><p>一种更方便的方法将Unicode转换为另一种编码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sink_path = <span class="string">&#x27;sink.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> source:</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(sink_path,<span class="string">&#x27;xt&#x27;</span>,encoding = <span class="string">&#x27;iso-88859-1&#x27;</span>) <span class="keyword">as</span> sink:</span><br><span class="line">sink.write(source.read())</span><br></pre></td></tr></table></figure><p>注意,不要在二进制模式中使用seek。如果文件位置位于定义Unicode字符的字节的中间位置,读取后面会产生错误.</p><h3 id="python文件打开方式"><a href="#python文件打开方式" class="headerlink" title="python文件打开方式"></a>python文件打开方式</h3><p>r只读,r+读写,不创建新的文件,w新建文件只写入,w+新建读写,二者都会将文件内容清零。r+：可读可写,若文件不存在,则报错；w+: 可读可写,若文件不存在,则创建一个新的文件。a：附加写方式打开,不可读；a+: 附加读写方式打开。使用’r’一般情况下最常用的,但是在进行读取二进制文件时,可能会出现文档读取不全的现象；使用’rb’按照二进制位进行读取的,不会将读取的字节转换成字符,二进制文件用二进制读取用’rb,’rt‘模式下,python在读取文本时会自动把\r\n转换成\n,文本文件用二进制读取用‘rt’。当我们写文件时,操作系统往往不会立刻把数据写入磁盘,而是放到内存缓存起来,空闲的时候再慢慢写入。只有调用close()方法时,操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘,剩下的丢失了。</p><h2 id="python绘图"><a href="#python绘图" class="headerlink" title="python绘图"></a>python绘图</h2><h3 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h3><p>matplotlib 是python中最有名的绘图库,在编写较大的应用程序时使用matplotlib会更加有效。如果需要绘制某种类型的图表,在<a href="http://matplotlib.sourceforge.net/gallery.html">http://matplotlib.sourceforge.net/gallery.html</a> 这个页面找到对应自己需要的,然后粘贴复制即可,基本上略微的修改就可以直接的拿来使用了。和matlab中的绘图十分的相似,如果熟悉matlab绘图的话,对于了解这块绘图会有十分大的帮助。有的时候不得不佩服那些粘贴复制的,带我兜兜转转,问题没解决掉,反而使得时间浪费了不少。看了<a href="https://towardsdatascience.com/the-art-of-effective-visualization-of-multi-dimensional-data-6c7202990c57">Dipanjan Sarkar</a>的博客,绘图就是门艺术,这里就简要的说明下seaborn绘图的命令。</p><h4 id="显示中文标题"><a href="#显示中文标题" class="headerlink" title="显示中文标题"></a>显示中文标题</h4><p>更改编码方式以及使用本地字体,可用参考如下代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-            </span></span><br><span class="line"><span class="comment">## 上面更改编码方式,下面解决中文显示</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="seaborn-的使用"><a href="#seaborn-的使用" class="headerlink" title="seaborn 的使用"></a>seaborn 的使用</h4><p>在工作的时候遇到的问题,由于需要进行不同参数下的误差对比,所以用到了这个,这里简略的说明几个用法</p><ol><li><p>ax.set_title(‘your title’), 设置标题</p></li><li><p>f.savefig(‘yourPic.eps’, dpi=360) ,保存图片,其中dpi可以理解为设置分辨率的。</p></li><li><p>ax.invert_xaxis(), x轴内容进行转过来显示。</p></li><li><p>ax.tick_params(axis=’x’,labelsize=6),刻度调整.</p></li><li><p>sns.set(),样式控制sns.set(style=’white’,palette=’muted’,color_codes=True),style为图表的背景主题,有5种主题可以选择：darkgrid (默认), whitegrid,dark,white,ticks, palette为设置主体颜色,有6种可以选择：deep,muted,pastel,bright,dark,colorblind</p></li><li><p>用despine进行边框控制：white和ticks参数的样式,都可以删除上方和右方坐标轴上不需要的边框。despine(top=True, right=True, left=False, bottom=False, offset=None, trim=False),默认无参数的情况下,是删除上面及右边的边框。offset可设置边框的偏移距离,trim设置删除边框的范围.</p></li></ol><p>下面给出seaborn.heatmap详细的参数说明,主要摘抄了 <a href="https://me.csdn.net/ztf312">计科小白兔</a>的博文</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">seaborn.heatmap(data, <span class="attribute">vmin</span>=None, <span class="attribute">vmax</span>=None, <span class="attribute">cmap</span>=None, <span class="attribute">center</span>=None, <span class="attribute">robust</span>=<span class="literal">False</span>,</span><br><span class="line"><span class="attribute">annot</span>=None, <span class="attribute">fmt</span>=<span class="string">&#x27;.2g&#x27;</span>, <span class="attribute">annotkws</span>=None, <span class="attribute">linewidths</span>=0, <span class="attribute">linecolor</span>=<span class="string">&#x27;white&#x27;</span>, <span class="attribute">cbar</span>=<span class="literal">True</span>, </span><br><span class="line"><span class="attribute">cbarkws</span>=None, <span class="attribute">cbar_ax</span>=None, <span class="attribute">square</span>=<span class="literal">False</span>, <span class="attribute">ax</span>=None, <span class="attribute">xticklabels</span>=<span class="literal">True</span>, <span class="attribute">yticklabels</span>=<span class="literal">True</span>, <span class="attribute">mask</span>=None, **kwargs) </span><br></pre></td></tr></table></figure><p>1,data：矩阵数据集,可以使numpy的数组(array),如果是pandas的dataframe,则df的index/column信息会分别对应到heatmap的columns和rows.<br>2,vmax,vmin, 图例中最大值和最小值的显示值,没有该参数时默认不显示.<br>3,linewidths,热力图矩阵之间的间隔大小<br>4, cmap,热力图颜色<br>5, ax,绘制图的坐标轴,否则使用当前活动的坐标轴。<br>6, annot,annotate的缩写,annot默认为False,当annot为True时,在heatmap中每个方格写入数据。<br>7, annot_kws,当annot为True时,可设置各个参数,包括大小,颜色,加粗,斜体字等：sns.heatmap(x, annot=True, ax=ax2, annot_kws={‘size’:9,’weight’:’bold’, ‘color’:’blue’})<br>8, fmt,格式设置,决定annot注释的数字格式,小数点后几位等；<br>9, <strong>cbar</strong> : 是否画一个颜色条<br>10, <strong>cbar_kws</strong> : 颜色条的参数</p><h2 id="pandas的数据结构介绍"><a href="#pandas的数据结构介绍" class="headerlink" title="pandas的数据结构介绍"></a>pandas的数据结构介绍</h2><p>要使用pandas,得熟悉提供的两个主要数据结构：Series和DataFrame。</p><h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><p>Series是一种类似于一维数组的对象,它由一组数据(各种NumPy数据类型)以及一组与之相关 的数据标签(即索引)组成,感觉和字典有一点相似。Series的字符串表现形式为：索引在左边,值在右边。由于我们没有为数据指定索引,于是会自动 创建一个0到N-1(N为数据的长度)的整数型索引。pandas的isnull和notnull函数可用于检测缺失数据。对于许多应用而言,Series最重要的一个功能是,它会根据运算的索引标签自动对齐数据。</p><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>DataFrame是一个表格型的数据结构,它含有一组有序的列,每列可以是不同的值类型(数值、字 符串、布尔值等)。DataFrame既有行索引也有列索引,它可以被看做由Series组成的字典(共用 同一个索引)。DataFrame中的数据是以一个或多个二维块存放的(而不是列表、字典或别的一维数据结构),建DataFrame的办法有很多,最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典。DataFrame构造函数所能接受的各种数据如下所示。</p><ol><li>Numpy 中的集合函数</li></ol><div class="table-container"><table><thead><tr><th>方法             &emsp;</th><th>说明</th></tr></thead><tbody><tr><td>unique(x)        &emsp;</td><td>计算 x 中的唯一元素,并返回有序结果</td></tr><tr><td>intersect1d(x,y) &emsp;</td><td>计算 x 和 y 中的公共元素,并返回有序结果</td></tr><tr><td>union1d(x,y)     &emsp;</td><td>计算 x 和 y 的并集,并返回有序结果</td></tr><tr><td>in1d(x,y)        &emsp;</td><td>得到一个表示“x 的元素是否包含于 y”的布尔型数组</td></tr><tr><td>setdiff1d(x,y)   &emsp;</td><td>集合的差,即元素在 x 中且不在 y 中</td></tr><tr><td>setxor1d(x,y)    &emsp;</td><td>集合的对称差,即存在于一个数组中但不同时存在于两个数组中的元素</td></tr></tbody></table></div><p>伪随机数生成,部分 numpy random 函数</p><div class="table-container"><table><thead><tr><th>函数        &emsp;</th><th>说明</th></tr></thead><tbody><tr><td>seed        &emsp;</td><td>确定随机数生成器的种子</td></tr><tr><td>permutation &emsp;</td><td>返回一个序列的随机排列或返回一个随机排列的范围</td></tr><tr><td>shuffle     &emsp;</td><td>对一个序列就地随机排列</td></tr><tr><td>rand        &emsp;</td><td>产生均匀分布的样本值</td></tr><tr><td>randint     &emsp;</td><td>从给定的上下限范围内随机选取整数</td></tr><tr><td>randn       &emsp;</td><td>产生正态分布(平均值为 0, 标准差为 1) 的样本值,类似于 MATLAB 接口</td></tr><tr><td>binomial    &emsp;</td><td>产生二项分布的样本值</td></tr><tr><td>normal      &emsp;</td><td>产生正态(高斯)分布的样本值</td></tr><tr><td>beta        &emsp;</td><td>产生 beta 分布的样本值</td></tr><tr><td>chisquare   &emsp;</td><td>产生卡方分布的样本值</td></tr><tr><td>gamma       &emsp;</td><td>产生 Gamma 分布的样本值</td></tr><tr><td>uniform     &emsp;</td><td>产生在[0,1) 中均匀分布的样本值</td></tr></tbody></table></div><p>这里重点的说一下如何使用 <code>pandas</code> + <code>DataFrame</code> 输出 <code>xlsx</code> 文件,这也是自己在工作中经常会遇到的一个问题,这里字典就会很有用处。这里先介绍下批量生成字符串的一种很简单的方法,比如自己在处理运动指令IP值时,对于机器人来说,有六个轴的,自己写 <code>IP1,IP2,IP3 ...</code>, 久而久之就会很烦的。。。。下面这样就会使得问题变得很简单(类似的,对于字符串可用 <code>%s</code> 来替代)</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">indexNames</span> = [<span class="string">&#x27;IP%d&#x27;</span>%i for i in range(<span class="number">1</span>,<span class="number">7</span>) ]</span><br></pre></td></tr></table></figure><p>这样配合着字典,比如</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">  dict<span class="selector-attr">[indexNames[i]</span>] = IP<span class="selector-attr">[:,i]</span>        #这里IP的矩阵大小为N*<span class="number">6</span></span><br></pre></td></tr></table></figure><p>再利用</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(dic)</span><br><span class="line">df.to_excel(<span class="string">&#x27;test.xlsx&#x27;</span>,<span class="attribute">index</span>=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>即可将结果输出到 <code>*.xlsx</code> 文件中去了, 这里忘了交代个事,就是需要引入相关的包</p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="title">from</span> pandas <span class="keyword">import</span> DataFrame</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]  <a href="https://www.runoob.com/python3/python-merging-two-dictionaries.html">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> PYTHON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python pandas 介绍</title>
      <link href="/2020/07/18/archived_python_pandas/"/>
      <url>/2020/07/18/archived_python_pandas/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a><ul><li><a href="#pandas的数据结构介绍">pandas的数据结构介绍</a><ul><li><a href="#series">Series</a></li><li><a href="#dataframe">DataFrame</a></li></ul></li></ul></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从Python 2020年学习笔记中单独拎出来作为内容的说明；</p><h2 id="pandas的数据结构介绍"><a href="#pandas的数据结构介绍" class="headerlink" title="pandas的数据结构介绍"></a>pandas的数据结构介绍</h2><p>要使用pandas,得熟悉提供的两个主要数据结构：Series和DataFrame。</p><h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><p>Series是一种类似于一维数组的对象,它由一组数据(各种NumPy数据类型)以及一组与之相关 的数据标签(即索引)组成,感觉和字典有一点相似。Series的字符串表现形式为：索引在左边,值在右边。由于我们没有为数据指定索引,于是会自动 创建一个0到N-1(N为数据的长度)的整数型索引。pandas的isnull和notnull函数可用于检测缺失数据。对于许多应用而言,Series最重要的一个功能是,它会根据运算的索引标签自动对齐数据。</p><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>DataFrame是一个表格型的数据结构,它含有一组有序的列,每列可以是不同的值类型(数值、字 符串、布尔值等)。DataFrame既有行索引也有列索引,它可以被看做由Series组成的字典(共用 同一个索引)。DataFrame中的数据是以一个或多个二维块存放的(而不是列表、字典或别的一维数据结构),建DataFrame的办法有很多,最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典。DataFrame构造函数所能接受的各种数据如下所示。</p><ol><li>Numpy 中的集合函数</li></ol><div class="table-container"><table><thead><tr><th>方法             &emsp;</th><th>说明</th></tr></thead><tbody><tr><td>unique(x)        &emsp;</td><td>计算 x 中的唯一元素,并返回有序结果</td></tr><tr><td>intersect1d(x,y) &emsp;</td><td>计算 x 和 y 中的公共元素,并返回有序结果</td></tr><tr><td>union1d(x,y)     &emsp;</td><td>计算 x 和 y 的并集,并返回有序结果</td></tr><tr><td>in1d(x,y)        &emsp;</td><td>得到一个表示“x 的元素是否包含于 y”的布尔型数组</td></tr><tr><td>setdiff1d(x,y)   &emsp;</td><td>集合的差,即元素在 x 中且不在 y 中</td></tr><tr><td>setxor1d(x,y)    &emsp;</td><td>集合的对称差,即存在于一个数组中但不同时存在于两个数组中的元素</td></tr></tbody></table></div><p>伪随机数生成,部分 numpy random 函数</p><div class="table-container"><table><thead><tr><th>函数        &emsp;</th><th>说明</th></tr></thead><tbody><tr><td>seed        &emsp;</td><td>确定随机数生成器的种子</td></tr><tr><td>permutation &emsp;</td><td>返回一个序列的随机排列或返回一个随机排列的范围</td></tr><tr><td>shuffle     &emsp;</td><td>对一个序列就地随机排列</td></tr><tr><td>rand        &emsp;</td><td>产生均匀分布的样本值</td></tr><tr><td>randint     &emsp;</td><td>从给定的上下限范围内随机选取整数</td></tr><tr><td>randn       &emsp;</td><td>产生正态分布(平均值为 0, 标准差为 1) 的样本值,类似于 MATLAB 接口</td></tr><tr><td>binomial    &emsp;</td><td>产生二项分布的样本值</td></tr><tr><td>normal      &emsp;</td><td>产生正态(高斯)分布的样本值</td></tr><tr><td>beta        &emsp;</td><td>产生 beta 分布的样本值</td></tr><tr><td>chisquare   &emsp;</td><td>产生卡方分布的样本值</td></tr><tr><td>gamma       &emsp;</td><td>产生 Gamma 分布的样本值</td></tr><tr><td>uniform     &emsp;</td><td>产生在[0,1) 中均匀分布的样本值</td></tr></tbody></table></div><p>这里重点的说一下如何使用 <code>pandas</code> + <code>DataFrame</code> 输出 <code>xlsx</code> 文件,这也是自己在工作中经常会遇到的一个问题,这里字典就会很有用处。这里先介绍下批量生成字符串的一种很简单的方法,比如自己在处理运动指令IP值时,对于机器人来说,有六个轴的,自己写 <code>IP1,IP2,IP3 ...</code>, 久而久之就会很烦的。。。。下面这样就会使得问题变得很简单(类似的,对于字符串可用 <code>%s</code> 来替代)</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">indexNames</span> = [<span class="string">&#x27;IP%d&#x27;</span>%i for i in range(<span class="number">1</span>,<span class="number">7</span>) ]</span><br></pre></td></tr></table></figure><p>这样配合着字典,比如</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">  dict<span class="selector-attr">[indexNames[i]</span>] = IP<span class="selector-attr">[:,i]</span>        #这里IP的矩阵大小为N*<span class="number">6</span></span><br></pre></td></tr></table></figure><p>再利用</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(dic)</span><br><span class="line">df.to_excel(<span class="string">&#x27;test.xlsx&#x27;</span>,<span class="attribute">index</span>=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>即可将结果输出到 <code>*.xlsx</code> 文件中去了, 这里忘了交代个事,就是需要引入相关的包</p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="title">from</span> pandas <span class="keyword">import</span> DataFrame</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]  <a href="https://www.runoob.com/python3/python-merging-two-dictionaries.html">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> PYTHON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ros 的安装</title>
      <link href="/2020/07/12/archived_ros%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2020/07/12/archived_ros%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#docker上安装ros">docker上安装ROS</a></li><li><a href="#ubuntu-上安装ros2">Ubuntu 上安装ROS2</a><ul><li><a href="#connection-refused">Connection refused</a></li></ul></li><li><a href="#install-ros1">Install ROS1</a><ul><li><a href="#初始化rosdep">初始化rosdep</a></li><li><a href="#创建并初始化工作目录">创建并初始化工作目录</a></li><li><a href="#命令-ifconfig没有找到的问题">命令 <code>ifconfig</code>没有找到的问题</a></li></ul></li><li><a href="#ros-rosdep-update更新失败简单解决">ROS rosdep update更新失败（简单解决）</a></li><li><a href="#mac-m2芯片上安装ros">MAC M2芯片上安装ROS</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>希望把一些自己学到的东西串联起来,所以学这个工具,可能要学习很长的时间,但是并不畏惧。很多内容源自于维基百科以及相关的书籍,比如《ROS机器人编程》等。</p><h1 id="docker上安装ROS"><a href="#docker上安装ROS" class="headerlink" title="docker上安装ROS"></a>docker上安装ROS</h1><p>在macOs系统上,建议在docker上学习以及使用ros, 类似的,可以在docker中学习linux内核,可以节省系统的运行开销以及储存空间。下面简单的说明下docker的安装。命令行下输入</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>docker</span><br></pre></td></tr></table></figure><p>下载成功后会出现</p><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">Moving App <span class="string">&#x27;Docker.app&#x27;</span> <span class="keyword">to</span> <span class="string">&#x27;/Applications/Docker.app&#x27;</span>.</span><br></pre></td></tr></table></figure><p>打开docker可以使用</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> /Applications/Docker.<span class="keyword">app</span>;<span class="keyword">open</span> Docker.<span class="keyword">app</span>;</span><br></pre></td></tr></table></figure><p>输入密码即可,可以检测docker是否安装成功,可以输入</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">docker <span class="comment">--version</span></span><br></pre></td></tr></table></figure><p>安装ros的方法使用了知乎用户<a href="https://zhuanlan.zhihu.com/p/85664330">JK 触发器</a>提供的策略,在登入账号的前提下,在命令行下输入 ：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull yz16/my_ros</span><br></pre></td></tr></table></figure><p>生成Container:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~;<span class="built_in">mkdir</span> ros_workspaces;</span><br><span class="line">docker run --name ros_env \</span><br><span class="line">--mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/Users/yourName/ros_workspaces,\</span><br><span class="line">target=/root/ros_workspaces \</span><br><span class="line">-itd -p 6080:80 yz16/my_ros</span><br></pre></td></tr></table></figure><br>浏览器打开 <a href="http://127.0.0.1:6080">http://127.0.0.1:6080</a> 就可以强行操作一波了。</p><p>确认容器有在运行,可以通过 docker ps 来查看,<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cd</span> ~;<span class="attribute">cd</span> ros_env;<span class="attribute">docker</span> ps</span><br></pre></td></tr></table></figure></p><p>输出详情介绍：<br>1,CONTAINER ID: 容器 ID。<br>2,IMAGE: 使用的镜像。<br>3,COMMAND: 启动容器时运行的命令。<br>4,CREATED: 容器的创建时间。<br>5,STATUS: 容器状态。<br>6,PORTS: 容器的端口信息和使用的连接类型(tcp\udp)。<br>7,NAMES: 自动分配的容器名称。</p><p>在宿主主机内使用 docker logs 命令,查看容器内的标准输出(先使用ps指令,查看文件夹中一连串的字母,再docker logs asdfadfs。</p><p>以后启动和关闭就可以直接使用如下指令来解决：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">docker <span class="literal">start</span>/<span class="literal">stop</span> ros_env</span><br></pre></td></tr></table></figure><h1 id="Ubuntu-上安装ROS2"><a href="#Ubuntu-上安装ROS2" class="headerlink" title="Ubuntu 上安装ROS2"></a>Ubuntu 上安装ROS2</h1><p>下面主要是通过源码编译的方式实现的,踩了些坑,记录了一下；</p><p>1, 确保有一个支持<code>UTF-8</code>的locale设置。locale设置例子如下：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo locale-gen en_US en_US.UTF-8</span><br><span class="line">sudo update-locale <span class="attribute">LC_ALL</span>=en_US.UTF-8 <span class="attribute">LANG</span>=en_US.UTF-8</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">LANG</span>=en_US.UTF-8</span><br></pre></td></tr></table></figure><p>2, 设置源：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sudo sh -c &#x27;. <span class="string">/etc/lsb-release</span> &amp;&amp; <span class="keyword">echo</span> <span class="string">&quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot;</span> &gt; <span class="string">/etc/apt/sources.list.d/ros-latest.list</span>&#x27;</span><br><span class="line">sudo apt-key adv <span class="params">--keyserver</span> &#x27;hkp:<span class="string">//keyserver.ubuntu.com</span><span class="function">:80</span>&#x27; <span class="params">--recv-key</span> C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure><p>3, 安装相关的工具包和依赖</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install build-essential </span><br><span class="line">sudo apt-get install cmake </span><br><span class="line">sudo apt-get install git </span><br><span class="line">sudo apt-get install python3-colcon-common-extensions </span><br><span class="line">sudo apt-get install python3-lark-parser </span><br><span class="line">sudo apt-get install python3-pip </span><br><span class="line">sudo apt-get install python3-rosdep2</span><br><span class="line">sudo apt-get python3-vcstool </span><br><span class="line">sudo apt-get wget</span><br><span class="line">python3 -m pip install -U <span class="string">\</span></span><br><span class="line">  argcomplete <span class="string">\</span></span><br><span class="line">  flake8 <span class="string">\</span></span><br><span class="line">  flake8-blind-except <span class="string">\</span></span><br><span class="line">  flake8-builtins <span class="string">\</span></span><br><span class="line">  flake8-<span class="keyword">class</span>-newline <span class="string">\</span></span><br><span class="line">  flake8-comprehensions <span class="string">\</span></span><br><span class="line">  flake8-deprecated <span class="string">\</span></span><br><span class="line">  flake8-docstrings <span class="string">\</span></span><br><span class="line">  flake8-<span class="keyword">import</span>-order <span class="string">\</span></span><br><span class="line">  flake8-quotes <span class="string">\</span></span><br><span class="line">  pytest-repeat <span class="string">\</span></span><br><span class="line">  pytest-rerunfailures <span class="string">\</span></span><br><span class="line">  pytest <span class="string">\</span></span><br><span class="line">  pytest-cov <span class="string">\</span></span><br><span class="line">  pytest-runner <span class="string">\</span></span><br><span class="line">  setuptools</span><br><span class="line">  </span><br><span class="line"><span class="comment"># install Fast-RTPS dependencies</span></span><br><span class="line">sudo apt install --<span class="literal">no</span>-install-recommends -y <span class="string">\</span></span><br><span class="line">  libasio-dev <span class="string">\</span></span><br><span class="line">  libtinyxml2-dev</span><br></pre></td></tr></table></figure><p>4, 创建工作空间并进行下载源码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/ros2_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/ros2_ws</span><br><span class="line">wget https://raw.githubusercontent.com/ros2/ros2/dashing/ros2.repos</span><br><span class="line">vcs import src &lt; ros2.repos</span><br></pre></td></tr></table></figure><p>一、遇到的问题：<br>根据ROS2的官方编译教程步骤下载ROS包时,到vcs import src &lt; ros2.repos 或 vcs import —input ros2.repos src这一步报错或者下载速度极慢</p><p>搜索到了以下三个网址,尝试了都不行,会显示 <code>Could not resolve host</code>等错误</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//github.com.cnpmjs.org/</span></span><br><span class="line"><span class="symbol">https:</span><span class="comment">//hub.fastgit.org/</span></span><br><span class="line"><span class="symbol">https:</span><span class="comment">//hub.fastgit.xyz/</span></span><br></pre></td></tr></table></figure><p>替换成<code>https://kgithub.com/</code>,这个目前是可以的(2023年6月3号测试没问题)</p><p>5, 用rosdep安装依赖项</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><p>在<code>rosdep update</code>的过程中可能会因为网络的问题而报错, 自己这边连续试了两次才正常的update成功, 如下图所示</p><p><img src="/img/postImg/1_ros/4_install_ros/3_rosdep_update_ubuntu_1804.png" width="50%" height="30%"></p><p>然后再</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">rosdep install <span class="attr">--from-paths</span> <span class="attribute">src</span> <span class="attr">--ignore-src</span> <span class="attr">--rosdistro</span> dashing -<span class="attribute">y</span> <span class="attr">--skip-keys</span> &quot;console_bridge fastcdr fastrtps libopensplice67 libopensplice69 rti-connext-dds-<span class="number">5.3</span>.<span class="number">1</span> urdfdom_headers&quot;</span><br></pre></td></tr></table></figure><p>6, 编译所有包</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/ros2_ws/</span></span><br><span class="line">colcon build <span class="params">--symlink-install</span></span><br></pre></td></tr></table></figure><p>编译过程如下</p><p><img src="/img/postImg/1_ros/4_install_ros/4_ros_complie_proess.png" width="80%" height="80%"></p><p>编译时间那叫做一个相当长。。。。。问题是还出错了。。。</p><p><img src="/img/postImg/1_ros/4_install_ros/5_ros2_complie_ERR.png" width="80%" height="100%"></p><p>排查了一圈后,结果发现是虚拟机里内存不够了,欲哭无泪啊。。。。解决起来稍微有点麻烦。。。。日了, 如果同样遇到了这个问题,可以按照如下步骤来重置虚拟机, 现在开启虚拟机就会在启动的时候显示<code>[FAILED]Failed to start Login Service</code>, 需要进行如下几步</p><p>1, 进入Recovery模式,自己又从网上查了两种方式,一个是长按<code>Shift</code>另一种是长按<code>e</code>, 亲测无效,且大无语,搞了好几次, 按住<code>Esc</code>的方式结果闪了1秒不到,就又到开机界面了,后面尝试了几次才知道,按1下就行了,不要长按；</p><p>2, 进入到<code>root</code>模式</p><p><img src="/img/postImg/1_ros/4_install_ros/1_Ubuntu_root_mode.png" width="50%" height="30%"></p><p>3,  输入如下命令后大概就有几百兆的存储空间了,然后再去扩充下磁盘</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> autoclean</span><br><span class="line">sudo apt-<span class="built_in">get</span> clean</span><br></pre></td></tr></table></figure><p>在拓展磁盘的过程中还发现了Ubuntu里面自带分析内存的旭日图。。。真神奇。。。</p><p><img src="/img/postImg/1_ros/4_install_ros/2_Ubuntu_xuri.png" width="50%" height="30%"></p><p>主要是用如下方法去进行</p><p>1, 使用命令安装分区管理工具gparted</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install gparted</span><br></pre></td></tr></table></figure><p>2, 使用命令启动分区管理工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gparted</span><br></pre></td></tr></table></figure><p>然后把想拓展的磁盘拉满就可以了。。。</p><p><img src="/img/postImg/1_ros/4_install_ros/6_gparted_expand.png" width="50%" height="30%"></p><p>拉满后点击确认,最后分配成功的时候看一下detail就行了</p><p><img src="/img/postImg/1_ros/4_install_ros/7_parted_OK.png" width="50%" height="30%"></p><p>然后通过命令<code>df -h</code>查看下当前磁盘的空间,让心里有个底；然后再回到编译的过程,又是漫长的等待。。。。。</p><h2 id="Connection-refused"><a href="#Connection-refused" class="headerlink" title="Connection refused"></a>Connection refused</h2><p>使用vim /etc/hosts命令打开不能访问的机器的hosts文件,添加如下内容：(如果不能修改这个文件的情况下,采用<code>sudu -i</code>进入管理员模式对这个文件进行修改即可)</p><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">199.232.68.133</span> raw.githubusercontent.com</span><br><span class="line"><span class="number">199.232.68.133</span> user-images.githubusercontent.com</span><br><span class="line"><span class="number">199.232.68.133</span> avatars2.githubusercontent.com</span><br><span class="line"><span class="number">199.232.68.133</span> avatars1.githubusercontent.com</span><br></pre></td></tr></table></figure><h1 id="Install-ROS1"><a href="#Install-ROS1" class="headerlink" title="Install ROS1"></a>Install ROS1</h1><p>鉴于很多视频介绍或者是书籍,都是基于较老的版本的ROS,也就是ROS1 版本了,其实安装起来非常简单,不过建议添加清华大学的镜像,这样快一些</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apt/sources<span class="meta">.list</span>.d/ros-latest<span class="meta">.list</span></span><br></pre></td></tr></table></figure><p>然后添加或替换成如下内容</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">deb https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/ros/u</span>buntu/ focal main</span><br></pre></td></tr></table></figure><p>然后再输入如下命令,信任 ROS 的 GPG Key,并更新索引：</p><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">key</span> adv --keyserver <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> --recv-<span class="keyword">key</span> C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br><span class="line">sudo apt <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>我看的书籍是基于<code>ros-kinetic</code>的,但是感觉都差不多,于是就直接安装了<code>ros-noetic</code>这个版本的了,估计等我完全熟悉的时候,这个版本依旧不会过时；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install ros-noetic-desktop-full</span><br></pre></td></tr></table></figure><p>还好个人网速给力,安装起来比上面用ROS2的用源码编译快得多了；后续的操作直接去看官网吧,就不一一复制下来了 <code>http://wiki.ros.org/noetic/Installation/Ubuntu</code></p><h2 id="初始化rosdep"><a href="#初始化rosdep" class="headerlink" title="初始化rosdep"></a>初始化rosdep</h2><p>在使用ROS之前,必须初始化rosdep。rosdep是一个通过在使用或编译ros的核心组 件时轻松安装依赖包来增强用户便利的功能。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><h2 id="创建并初始化工作目录"><a href="#创建并初始化工作目录" class="headerlink" title="创建并初始化工作目录"></a>创建并初始化工作目录</h2><p>ROS使用一个名为catkin的ROS专用构建系统。为了使用它,用户需要创建并初始化 catkin工作目录,如下所示。除非用户创建新的工作目录,否则此设置只需设置一次。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><h2 id="命令-ifconfig没有找到的问题"><a href="#命令-ifconfig没有找到的问题" class="headerlink" title="命令 ifconfig没有找到的问题"></a>命令 <code>ifconfig</code>没有找到的问题</h2><p>输入如下指令安装即可</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install net-tools</span><br></pre></td></tr></table></figure><p>这个主要是为了一些配置所用；</p><h1 id="ROS-rosdep-update更新失败（简单解决）"><a href="#ROS-rosdep-update更新失败（简单解决）" class="headerlink" title="ROS rosdep update更新失败（简单解决）"></a>ROS rosdep update更新失败（简单解决）</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pip install rosdepc</span><br></pre></td></tr></table></figure><h1 id="MAC-M2芯片上安装ROS"><a href="#MAC-M2芯片上安装ROS" class="headerlink" title="MAC M2芯片上安装ROS"></a>MAC M2芯片上安装ROS</h1><p>有的时候发现自己的虚拟机网络被墙，导致很多仿真无法进行下去，于是乎，就想办法不用虚拟机，因为自己虚拟机是ARM 64系统下的，翻墙实在不易，干脆就直接在自己电脑里面安装ROS了，运气好的是，在CSDN上就有人实现了这点，我就直接抄了，原文可见<a href="https://blog.csdn.net/jyw0401/article/details/130839211">macOS在miniconda下配置安装ROS1</a>, 下面就属于搬运内容了</p><p>1, 安装<a href="https://docs.conda.io/projects/miniconda/en/latest/">miniconda</a>, 如果自己安装了anaconda的话，在bashrc或者zshrc中给注释掉相关内容即可，没必要卸载掉, 找到如图所示的内容，安装即可</p><p><img src="/img/postImg/1_ros/5_install_on_mac/miniConda.png" alt=""></p><p>2, 创建新的环境</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">conda</span> create -n ROS  #如果下载的环境为<span class="number">3</span>.<span class="number">8</span>版本conda,则不写指定python版本</span><br></pre></td></tr></table></figure><p>3, 配置虚拟环境<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment">#激活境ROS</span></span><br><span class="line">conda activate ROS</span><br><span class="line"><span class="comment">#配置当前环境</span></span><br><span class="line">conda<span class="built_in"> config </span>--<span class="built_in">add</span> channels conda-forge</span><br><span class="line">conda<span class="built_in"> config </span>--<span class="built_in">add</span> channels robostack</span><br><span class="line">conda<span class="built_in"> config </span>--<span class="built_in">set</span> channel_priority strict</span><br></pre></td></tr></table></figure></p><p>4, 安装ROS noetic</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装noetic版本</span></span><br><span class="line">conda <span class="keyword">install</span> ros-noetic-desktop-full</span><br></pre></td></tr></table></figure><p>5, 安装附加工具<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">conda <span class="keyword">install </span>compilers cmake pkg-<span class="built_in">config</span> make ninja catkin_tools</span><br></pre></td></tr></table></figure></p><p>6, 重新加载ROS环境<br><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">deactivate</span></span><br><span class="line">conda <span class="built_in">activate</span> ROS</span><br></pre></td></tr></table></figure></p><p>7, ROS 初始化<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">rosdep <span class="keyword">init</span></span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure></p><p>接下来就可以创建工作空间来验证安装是否OK了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span>  ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>得到的结果如图所示</p><p><img src="/img/postImg/1_ros/5_install_on_mac/catkin_make_OK.png" alt=""></p><p>这就已经表明安装成功了</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用工具</title>
      <link href="/2020/01/16/continue_somethingElse/"/>
      <url>/2020/01/16/continue_somethingElse/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#绘图工具">绘图工具</a><ul><li><a href="#plantuml">plantUML</a></li><li><a href="#tikz">tikz</a></li></ul></li><li><a href="#windows-软件推荐">windows 软件推荐</a><ul><li><a href="#禁用-hyper-v">禁用 hyper-v</a></li><li><a href="#macos">macos</a><ul><li><a href="#数学软件推荐">数学软件推荐</a></li><li><a href="#hexo-上的一点小技巧">Hexo 上的一点小技巧</a></li><li><a href="#pycharm">pyCharm</a></li><li><a href="#imovie-快捷键">IMovie 快捷键</a></li></ul></li></ul></li><li><a href="#终端中的键盘快捷键">终端中的键盘快捷键</a><ul><li><a href="#typora">typora</a></li></ul></li><li><a href="#the-package-lockjson-file-was-created-with-an-old-version-of-npm">The package-lock.json file was created with an old version of npm</a><ul><li><a href="#了解一下">了解一下</a></li></ul></li><li><a href="#hexo-中的技巧记录">hexo 中的技巧记录</a><ul><li><a href="#hexo如何引用自己的文章">hexo如何引用自己的文章？</a></li></ul></li><li><a href="#hhkb-快捷键">HHKB 快捷键</a></li><li><a href="#ping-不通github解决办法">ping 不通github解决办法</a></li><li><a href="#e45-readonly-option-is-set-add--to-override">“E45: ‘readonly’ option is set (add ! to override)”</a></li><li><a href="#markdown-文章内部跳转">markdown 文章内部跳转</a></li><li><a href="#破解-beyond-compare">破解 Beyond Compare</a></li><li><a href="#改大写键盘为control键-ubuntu-中">改大写键盘为Control键 ubuntu 中</a></li><li><a href="#统计代码行数">统计代码行数</a></li><li><a href="#valgrind">Valgrind</a><ul><li><a href="#常用命令示例">常用命令示例：</a></li><li><a href="#示例输出片段解析">示例输出片段解析</a></li><li><a href="#泄漏检查部分">泄漏检查部分</a></li><li><a href="#怎么修复">怎么修复？</a></li><li><a href="#高级用法推荐">高级用法（推荐）</a></li></ul></li><li><a href="#git-记住密码方式">GIT 记住密码方式</a></li><li><a href="#nohup-命令的用法">nohup 命令的用法</a><ul><li><a href="#基本语法">基本语法：</a></li><li><a href="#示例用法">示例用法</a></li><li><a href="#注意事项">注意事项：</a></li></ul></li><li><a href="#ros-2-版本信息">ROS 2 版本信息</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有些零散的比较有用的点,就暂时放在这把,因为时间一长就容易遗忘,不时的来查阅一下,也许就像小孩子第一次去沙滩,看到美丽的贝壳，难以掩饰的激动。</p><h1 id="绘图工具"><a href="#绘图工具" class="headerlink" title="绘图工具"></a>绘图工具</h1><h2 id="plantUML"><a href="#plantUML" class="headerlink" title="plantUML"></a>plantUML</h2><p>使用HTML进行格式化(Formatting using HTML),可以使用少量的HTML标签来格式化文本, 该内容请点击<a href="http://archive.3zso.com/archives/plantuml-quickstart.html#sec-5-1-1">链接</a>, 由于这个脚本可以绘制很多种图,免费开源,绘制的图形虽然不如专门的工具,比如visio, 但是对于自己快速绘制流程图等等,是很有帮助的。</p><p>提高plantUML的分辨率,可以添加脚本(这段目前在甘特图中不适用)</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scale</span> <span class="attribute">x</span>*<span class="attribute">y</span></span><br></pre></td></tr></table></figure><h2 id="tikz"><a href="#tikz" class="headerlink" title="tikz"></a>tikz</h2><p>这个其实不是个软件,是tex里的绘图,可以绘制出非常好看的图,当然,需要知道的东西太多了,严格的来说并不易使用,入坑需谨慎。<br>学了一段时间后发现还是有一些作用的,配合着网站<a href="https://www.mathcha.io/,就可以实现快速绘制图形的功能了。">https://www.mathcha.io/,就可以实现快速绘制图形的功能了。</a></p><h1 id="windows-软件推荐"><a href="#windows-软件推荐" class="headerlink" title="windows 软件推荐"></a>windows 软件推荐</h1><p>1, Everything (搜索文件工具)<br>2, snipaste (贴图 + 截屏)<br>3, autohotkey (自定义快捷键,有编程底子的很快就能上手,用惯了vim的,可以用别人的配置,参考<code>https://www.kaifa99.com/GitHub/article_104420</code>)<br>4, focusky (相对简单的ppt制作软件,且花里胡哨)<br>5, Typora (好用的markdown编辑器)<br>6, Anaconda (开源包管理器)<br>7, winedt (latex编辑器)<br>8, texlive (miktex有时真的不给力,还不如安装texlive可以解决一些不必要的麻烦)<br>9, Evernote (印象笔记,可以方便的管理自己的笔记)<br>10, visio (可以绘制出好看到变态的软件)<br>11, vscode (开箱即用的编辑器,<del>相对于vim</del>,对新手非常友好,不过代价就是让人变懒了,类似的还有sublime,atom等等非常优秀的编辑器,<del>不好意思,我用vim</del>)<br>12, Mendeley (目前为止发现最适合自己的文献管理工具,目前为止放了近一千本书籍进去(chi hui)了,而且在windows可以同步,不必担心这些书籍找不到,可以说,使用好这个工具,可以有效的构建自己的知识体系。)<br>13, Teamviewer (非常好用的远程控制工具)<br>14, IDM (下载东西比较快速,在吾爱破解论坛里有不少破解的方法,自行搜索吧)</p><h2 id="禁用-hyper-v"><a href="#禁用-hyper-v" class="headerlink" title="禁用 hyper-v"></a>禁用 hyper-v</h2><p>在安装虚拟机等等会与这个冲突,所以记录一下。在 <code>Ctrl+R</code> 快捷键后输入 cmd, 然后在命令提示框内输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bcdedit /copy &#123;current&#125; /d <span class="string">&quot;Windows10 no Hyper-V</span></span><br></pre></td></tr></table></figure><p>将输出的结果, 比如为 {123l}(里面都是十六进制的,还有就是1与l在里面看出不来), 参考如下指令写入即可</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">bcdedit</span> /set &#123;<span class="number">123</span>l&#125; hypervisorlaunchtype <span class="literal">OFF</span></span><br></pre></td></tr></table></figure><p>然后重启电脑即可。</p><h2 id="macos"><a href="#macos" class="headerlink" title="macos"></a>macos</h2><p>1, iText(一款不错的ocr识别工具,不过需要收费)<br>2, iMovie (非常强大的视频剪辑软件)<br>3, docker (非常强大且好用的虚拟机)<br>4, keynote (非常有水平的ppt演示工具)<br>5, Vmware, 好用的虚拟机，可以去<a href="https://customerconnect.vmware.com/evalcenter?p=fusion-player-personal-13">官网</a>免费申请一个秘钥, 下面就是自己申请完秘钥，填入后的结果</p><div align="center"> <img src="/img/postImg/36_somethingElse/VMWARE_FUSION_12.png" width="100%" height="40%"> </div><h3 id="数学软件推荐"><a href="#数学软件推荐" class="headerlink" title="数学软件推荐"></a>数学软件推荐</h3><p>1, Mathematica (绝对的神器,无论是数值计算还是符号处理等等等等,都是一等一的水平)<br>2, Matlab (工科神器)<br>3, Lingo (运筹优化)<br>4, python (相对来说语法上易学的语言,平时用这个软件做计算,所以就归到这类吧)<br>5, maple(没用过,但是很强)</p><h3 id="Hexo-上的一点小技巧"><a href="#Hexo-上的一点小技巧" class="headerlink" title="Hexo 上的一点小技巧"></a>Hexo 上的一点小技巧</h3><p>插入固定图片大小时可用如下指令,当然想让其居中可以使用div容器<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;/images/your.png&quot;</span> <span class="attribute">width</span>=<span class="string">&quot;70%&quot;</span> <span class="attribute">height</span>=<span class="string">&quot;50%&quot;</span>&gt;</span><br></pre></td></tr></table></figure></p><p>如果报错<code>TypeError: Cannot set property lastIndex of undefined</code>, 多半是自己文章里加的一些符号,比如代码注释等等有问题,需要检查一下。</p><h3 id="pyCharm"><a href="#pyCharm" class="headerlink" title="pyCharm"></a>pyCharm</h3><p>内容部分选自知乎 <a href="https://www.zhihu.com/people/light-lin-69">Light Lin</a></p><p>1, <code>ctrl+alt+L</code>,格式化代码。</p><p>2, <code>alt+enter</code>万能键, 出了错不知道怎么办,就按这个键。</p><p>3, <code>ctrl+space</code> 万能提示键。</p><p>4, <code>ctrl+shift+f10</code>运行当前文件。</p><p>5, <code>ctrl+w</code>扩展选取和<code>ctrl+shift+w</code>缩减选区,根据当前层级一层一层向上伸展选中区域</p><p>6, <code>ctrl+alt+shift+T</code>重构选区</p><p>7, <code>ctrl+q</code>查注释</p><p>8, <code>ctrl+shift+i</code>没注释时查源码</p><p>9, <code>ctrl+p</code>调用方法时查看参数</p><p>10, <code>shift+enter</code>另起一行,光标在行内任意位置都能另起一行,且不破坏当行结构</p><p>11, <code>ctrl+alt+enter</code>向上另起一行。</p><p>12, <code>ctrl+shift+数字键</code>与<code>ctrl+数字键</code>书签功能。</p><p>13, <code>ctrl+shift+a</code>搜索IDE功能。</p><p>14, 双击<code>shift</code>搜索一切,不管是IDE功能、文件、方法、变量……都能搜索</p><p>自己用的最多的快捷键就是折叠了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CTRL+SHIFT+ +/-</span><br></pre></td></tr></table></figure><h3 id="IMovie-快捷键"><a href="#IMovie-快捷键" class="headerlink" title="IMovie 快捷键"></a>IMovie 快捷键</h3><p>1, 将所选部分添加到影片：E</p><p>2, 将所选部分连接到播放头位置的片段:Q</p><p>3, 将所选部分插入影片中的播放头位置:W</p><p>4, 自动改进所选片段的视频和音频质量:Shift-Command-E</p><p>5, 在播放头位置分隔片段:Command-B</p><p>6, 粘贴视频效果:Option-Command-L</p><p>7, 将所选部分评价为“拒绝的片段”,或者从时间线中删除所选部分: Delete 键</p><p>8, 调整影片的快慢,选中想更改速度的片段,使用快捷键：Command-R</p><h1 id="终端中的键盘快捷键"><a href="#终端中的键盘快捷键" class="headerlink" title="终端中的键盘快捷键"></a>终端中的键盘快捷键</h1><p>去苹果官网找到了未来可能用的上的快捷键,收集整理如下:</p><p><code>1,使用“终端”窗口和标签页</code></p><details><summary>展开</summary><table id="hor-zebra" summary="Employee Pay Sheet">      <thead>                                              <tr>                                             <th scope="col"> 操作</th>            <th scope="col">快捷键</th>                  </tr>                                            </thead>                                             <tbody>                                              <tr class="odd">                                 <td> 新建窗口   </td>                  <td> Command-N </td>                                </tr>                                            <tr>                                             <td> 新建标签页</td>                    <td>Command-T</td>                                </tr>                                            <tr class="odd">                                 <td> 使用相同命令新建标签页 </td>                      <td> Control-Command-T </td>                                </tr>                                            <tr>                                             <td> 显示或隐藏标签页栏 </td>                 <td> Shift-Command-T </td>                                </tr>                                            <tr class="odd">                                 <td> 显示所有标签页或退出标签页概览 </td>                      <td> Shift-Command-反斜杠 (\) </td>                                </tr>                                            <tr>                                             <td> 新建命令  </td>                 <td> Shift-Command-N </td>                                </tr>                                            <tr class="odd">                                 <td>    新建远程连接</td>                      <td> Shift-Command-K </td>                                </tr>                                            <tr>                                             <td>显示或隐藏检查器</td>                 <td>Command-I</td>                                </tr>                                            <tr class="odd">                                 <td>编辑标题</td>                      <td>Shift-Command-I</td>                                </tr>                                            <tr>                                             <td>    编辑背景颜色</td>                 <td> Option-Command-I </td>                                </tr>                                            <tr class="odd">                                 <td>放大字体    </td>                      <td> Command-加号键 (+) </td>                                </tr>                                            <tr>                                             <td>    缩小字体</td>                 <td> Command-减号键 (–) </td>                                </tr>                                            <tr class="odd">                                 <td>    下一个窗口</td>                      <td> Command-重音符键 (\`) </td>                                </tr>                                            <tr>                                             <td>上一个窗口</td>                 <td> Command-Shift-波浪符号 (~) </td>                                </tr>                                            <tr class="odd">                                 <td>上一个标签页    </td>                      <td> Control-Shift-Tab </td>                                </tr>                                            <tr>                                             <td>    将窗口拆分为两个面板</td>                 <td> Command-D </td>                                </tr>                                            <tr class="odd">                                 <td>    关闭拆分面板</td>                      <td> Shift-Command-D </td>                                </tr>                                            <tr>                                             <td>    关闭标签页</td>                 <td> Command-W </td>                                </tr>                                            <tr class="odd">                                 <td>关闭窗口    </td>                      <td>Shift-Command-W</td>                                </tr>                                            <tr>                                             <td>    关闭其他标签页</td>                 <td>Option-Command-W    </td>                                </tr>                                            <tr class="odd">                                 <td>全部关闭    </td>                      <td>Option-Shift-Command-W    </td>                                </tr>                                            <tr>                                             <td>滚动到顶部    </td>                 <td>Command-Home    </td>                                </tr>                                            <tr class="odd">                                 <td>滚动到底部    </td>                      <td>Command-End    </td>                                </tr>                                            <tr>                                             <td>上一页    </td>                 <td>Command-Page Up    </td>                                </tr>                                            <tr class="odd">                                 <td>下一页    </td>                      <td>Command-Page Down    </td>                                </tr>                                            <tr>                                             <td>上一行    </td>                 <td>Option-Command-Page Up    </td>                                </tr>                                            <tr class="odd">                                 <td>下一行    </td>                      <td>Option-Command-Page Down    </td>                                </tr>                                            </tbody>                                             </table>                                                </details><p><code>2, 编辑命令行</code></p><details><summary>展开</summary><table id='hor-zebra' summary='Employee Pay Sheet'><thead><tr><th scope='col'>操作</th><th scope='col'>快捷键</th></tr><tr><td>操作</td><td>快捷键</td></tr></thead><tbody><tr class='odd'><td>重新定位插入点</td><td>在按住</td></tr><tr><td>将插入点移到行的开头</td><td>Control-A</td></tr></thead><tbody><tr class='odd'><td>将插入点移到行的结尾</td><td>Control-E</td></tr><tr><td>将插入点前移一个字符</td><td>右箭头键</td></tr></thead><tbody><tr class='odd'><td>将插入点后移一个字符</td><td>左箭头键</td></tr><tr><td>将插入点前移一个字词</td><td>Option-右箭头键</td></tr></thead><tbody><tr class='odd'><td>将插入点后移一个字词</td><td>Option-左箭头键</td></tr><tr><td>删除行</td><td>Control-U</td></tr></thead><tbody><tr class='odd'><td>删除到行的结尾</td><td>Control-K</td></tr><tr><td>向前删除到字词的结尾</td><td>Option-D(选中将</td></tr></thead><tbody><tr class='odd'><td>向后删除到字词的开头</td><td>Control-W</td></tr><tr><td>删除一个字符</td><td>Delete</td></tr></thead><tbody><tr class='odd'><td>向前删除一个字符</td><td>向前删除(或使用</td></tr><tr><td>转置两个字符</td><td>Control-T</td></tr></tbody></table></details><p>还有相关很多快捷键,不过感觉用不上,所以就没记录,另外有时会用到录屏功能,录屏的快捷键为 Shift-Command-5：在 macOS Mojave 或更高版本中,拍摄截屏或录制屏幕。也可以使用 Shift-Command-3 或 Shift-Command-4 来拍摄截屏。</p><h2 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h2><p>1, 插入图片快捷键</p><p><code>MacOs</code>: ⌃⌘I</p><p><code>Windows</code>: Ctrl+Shift+I</p><p><code>Linux</code>:Ctrl+Shift+I</p><h1 id="The-package-lock-json-file-was-created-with-an-old-version-of-npm"><a href="#The-package-lock-json-file-was-created-with-an-old-version-of-npm" class="headerlink" title="The package-lock.json file was created with an old version of npm"></a>The package-lock.json file was created with an old version of npm</h1><p>使用一个低版本的npm即可</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> i <span class="built_in">npm</span>@<span class="number">6</span> -g</span><br></pre></td></tr></table></figure><p>chm2html</p><p>在Windows下，写下如下命令行可在所放置目录中进行转换</p><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">　for %<span class="variable">%c</span> in (yourpath/*.chm) do hh.exe -decompile yourpath/%<span class="variable">%c</span> yourpath/%<span class="variable">%c.chm</span></span><br></pre></td></tr></table></figure><h2 id="了解一下"><a href="#了解一下" class="headerlink" title="了解一下"></a>了解一下</h2><p>1, 导出数值数据最好采用CSV格式,尽量不用xlsx格式,因为存储同样的内容,xlsx格式比csv占用磁盘空间更大,处理起来更慢。</p><p>2,设置开机自启动,只需生成一个“快捷方式”,然后将此快捷方式放置到程序自启动文件夹之下即可,一般都在这儿：</p><figure class="highlight moonscript"><table><tr><td class="code"><pre><span class="line"><span class="name">C</span>:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</span><br></pre></td></tr></table></figure><h1 id="hexo-中的技巧记录"><a href="#hexo-中的技巧记录" class="headerlink" title="hexo 中的技巧记录"></a>hexo 中的技巧记录</h1><h2 id="hexo如何引用自己的文章？"><a href="#hexo如何引用自己的文章？" class="headerlink" title="hexo如何引用自己的文章？"></a>hexo如何引用自己的文章？</h2><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">post_link</span> 文章文件名（不要后缀） 文章标题（可选） %&#125;</span></span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">post_link</span> Hello-World %&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="template-tag">&#123;% <span class="name">post_link</span> Hello-World 你好世界 %&#125;</span></span><br></pre></td></tr></table></figure><h1 id="HHKB-快捷键"><a href="#HHKB-快捷键" class="headerlink" title="HHKB 快捷键"></a>HHKB 快捷键</h1><ul><li>Fn + Enter: 重命名文件</li></ul><h1 id="ping-不通github解决办法"><a href="#ping-不通github解决办法" class="headerlink" title="ping 不通github解决办法"></a>ping 不通github解决办法</h1><p>2023.1.23 号时使用时是可以解决的， 方法是更改hosts文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改 /etc/hosts</span></span><br><span class="line"><span class="built_in">sudo</span> vim /etc/hosts</span><br></pre></td></tr></table></figure><p>在hosts里添加github的ip</p><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">140.82.113.3</span> github.com</span><br><span class="line"><span class="number">199.232.5.194</span> github.global.ssl.fastly.net</span><br><span class="line"><span class="number">54.231.114.219</span> github-cloud.s3.amazonaws.com</span><br></pre></td></tr></table></figure><h1 id="“E45-‘readonly’-option-is-set-add-to-override-”"><a href="#“E45-‘readonly’-option-is-set-add-to-override-”" class="headerlink" title="“E45: ‘readonly’ option is set (add ! to override)”"></a>“E45: ‘readonly’ option is set (add ! to override)”</h1><p>这个是在我使用vim修改/etc/hosts的时候遇到的一个问题, 写完后用命令模式，输入<code>w!</code>即可</p><h1 id="markdown-文章内部跳转"><a href="#markdown-文章内部跳转" class="headerlink" title="markdown 文章内部跳转"></a>markdown 文章内部跳转</h1><p>在需要跳转的地方加入如下内容</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;yourTags&quot;</span>&gt;</span> yourContent <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用markdown语法进行跳转</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="name">点击跳转</span>](#yourTags)</span><br></pre></td></tr></table></figure><h1 id="破解-Beyond-Compare"><a href="#破解-Beyond-Compare" class="headerlink" title="破解 Beyond Compare"></a>破解 Beyond Compare</h1><p>有一个非常好用的方法，可以直接用于正版的软件，操作如下</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">命令行： regedit, 打开注册表</span><br><span class="line">删除项目<span class="keyword">CacheId: </span> HEKY_CUREENT_USER\Software\<span class="keyword">Scooter </span>Software\<span class="keyword">Beyond </span><span class="built_in">Compare</span> <span class="number">4</span>\<span class="keyword">CacheId</span></span><br></pre></td></tr></table></figure><h1 id="改大写键盘为Control键-ubuntu-中"><a href="#改大写键盘为Control键-ubuntu-中" class="headerlink" title="改大写键盘为Control键 ubuntu 中"></a>改大写键盘为Control键 ubuntu 中</h1><p>安装 Tweaks（如未安装）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gnome-tweaks</span><br></pre></td></tr></table></figure><p>打开 Tweaks → 进入 Keyboard &amp; Mouse → Additional Layout Options。</p><p>找到：</p><p>Caps Lock behavior → 选择 “Make Caps Lock an additional Ctrl”</p><p>或 Ctrl position → 选择将 Caps Lock 映射为 Ctrl</p><h1 id="统计代码行数"><a href="#统计代码行数" class="headerlink" title="统计代码行数"></a>统计代码行数</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -not -path <span class="string">&quot;./build/*&quot;</span> -not -path <span class="string">&quot;./.git/*&quot;</span> -<span class="built_in">exec</span> <span class="built_in">cat</span> &#123;&#125; + 2&gt;/dev/null | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><h1 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a>Valgrind</h1><p>1) 内存泄漏检测（使用 memcheck 工具）：</p><p>检查 new/malloc 分配的内存有没有被 delete/free。</p><p>2) 未初始化内存访问检测：<br>发现你使用了未赋值的变量或野指针等。</p><p>3) 越界访问检测：</p><p>能发现数组越界、访问非法内存等问题。</p><p>4) 线程错误检查（使用 helgrind）：</p><p>检测线程之间的竞争条件。</p><p>5) 性能分析（cachegrind）：</p><p>可分析缓存命中率、指令执行数量，适用于性能瓶颈分析。</p><h2 id="常用命令示例："><a href="#常用命令示例：" class="headerlink" title="常用命令示例："></a>常用命令示例：</h2><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">valgrind <span class="params">--leak-check=full</span> <span class="string">./your_program</span></span><br></pre></td></tr></table></figure><h2 id="示例输出片段解析"><a href="#示例输出片段解析" class="headerlink" title="示例输出片段解析"></a>示例输出片段解析</h2><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">=</span><span class="punctuation">=</span><span class="number">12345</span><span class="punctuation">=</span><span class="punctuation">=</span> Memcheck<span class="punctuation">,</span> a memory error detector</span><br><span class="line"><span class="punctuation">=</span><span class="punctuation">=</span><span class="number">12345</span><span class="punctuation">=</span><span class="punctuation">=</span> Copyright <span class="punctuation">(</span>C<span class="punctuation">)</span> <span class="number">2002</span><span class="punctuation">-</span><span class="number">2022</span><span class="punctuation">,</span> and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==<span class="number">1234</span>5== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==<span class="number">1234</span>5== Command: ./my_program</span><br><span class="line">==<span class="number">1234</span>5==</span><br><span class="line">==<span class="number">1234</span>5== Invalid read of size 4</span><br><span class="line">==<span class="number">1234</span>5==    at 0x<span class="number">401234</span>: main (main.cpp:12)</span><br><span class="line">==<span class="number">1234</span>5==  Address 0x0 is not stack&#x27;d<span class="punctuation">,</span> malloc&#x27;d or (recently) free&#x27;d</span><br></pre></td></tr></table></figure><p>这表示程序有一次非法读取（未定义行为）：</p><ul><li><p>Invalid read of size 4：读取了 4 个字节的非法内存</p></li><li><p>main.cpp:12：出错位置</p></li><li><p>Address 0x0：很可能是一个空指针访问</p></li></ul><h2 id="泄漏检查部分"><a href="#泄漏检查部分" class="headerlink" title="泄漏检查部分"></a>泄漏检查部分</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">==<span class="attribute">12345</span>== HEAP SUMMARY:</span><br><span class="line">==<span class="attribute">12345</span>==     <span class="keyword">in</span> use at exit: 72 bytes <span class="keyword">in</span> 2 blocks</span><br><span class="line">==<span class="attribute">12345</span>==   total heap usage: 4 allocs, 2 frees, 144 bytes allocated</span><br><span class="line"></span><br><span class="line">==<span class="attribute">12345</span>== 72 bytes <span class="keyword">in</span> 2 blocks are definitely lost <span class="keyword">in</span> loss record 1 of 1</span><br><span class="line">==<span class="attribute">12345</span>==    at 0x4845DEF: malloc (vg_replace_malloc.c:381)</span><br><span class="line">==<span class="attribute">12345</span>==    by 0x4011F6: main (main.cpp:10)</span><br><span class="line"></span><br><span class="line">==<span class="attribute">12345</span>== LEAK SUMMARY:</span><br><span class="line">==<span class="attribute">12345</span>==    definitely lost: 72 bytes <span class="keyword">in</span> 2 blocks</span><br><span class="line">==<span class="attribute">12345</span>==    indirectly lost: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==<span class="attribute">12345</span>==      possibly lost: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==<span class="attribute">12345</span>==    still reachable: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==<span class="attribute">12345</span>==         suppressed: 0 bytes <span class="keyword">in</span> 0 blocks</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><strong>definitely lost</strong></td><td>明确泄漏的内存，没有任何指针引用它</td></tr><tr><td><strong>indirectly lost</strong></td><td>被 <code>definitely lost</code> 的内存指针引用的内存</td></tr><tr><td><strong>possibly lost</strong></td><td>可能泄漏（比如指针指向中间地址）</td></tr><tr><td><strong>still reachable</strong></td><td>程序退出时仍然可达，但没有释放（不是很严重）</td></tr></tbody></table></div><h2 id="怎么修复？"><a href="#怎么修复？" class="headerlink" title="怎么修复？"></a>怎么修复？</h2><ul><li><p>找到出错位置的 代码行数（比如上面是 main.cpp:10）；</p></li><li><p>回去加上 delete 或 free；</p></li><li><p>或者修复未初始化、非法访问等行为。</p></li></ul><h2 id="高级用法（推荐）"><a href="#高级用法（推荐）" class="headerlink" title="高级用法（推荐）"></a>高级用法（推荐）</h2><p>带源码行号和可读性：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">valgrind <span class="attribute">--leak-check</span>=full <span class="attribute">--track-origins</span>=<span class="literal">yes</span> <span class="attribute">--show-leak-kinds</span>=all ./my_program</span><br></pre></td></tr></table></figure><h1 id="GIT-记住密码方式"><a href="#GIT-记住密码方式" class="headerlink" title="GIT 记住密码方式"></a>GIT 记住密码方式</h1><p>1) 生成访问 token（GitHub 或 GitLab）：</p><p>GitHub：Settings -&gt; Developer settings -&gt; Personal Access Token -&gt; 生成新 token（记得勾选 repo 权限）</p><p>GitLab：User -&gt; Preferences -&gt; Access Tokens</p><p>2) 第一次推送时使用用户名 + token 登录（而不是密码）：</p><p>用户名：你的 GitHub 用户名</p><p>密码：粘贴刚刚生成的 token</p><p>3) 保存密码到本地凭证管理器（Git 自带功能）：</p><p>对于 Linux/Mac：<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">config</span> --global credential.helper <span class="keyword">cache </span>  <span class="comment"># 临时缓存</span></span><br><span class="line">git <span class="built_in">config</span> --global credential.helper store   <span class="comment"># 永久保存（明文保存在 ~/.git-credentials 中）</span></span><br></pre></td></tr></table></figure><br>对于 Windows：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">config</span> <span class="comment">--global credential.helper manager</span></span><br></pre></td></tr></table></figure><h1 id="nohup-命令的用法"><a href="#nohup-命令的用法" class="headerlink" title="nohup 命令的用法"></a>nohup 命令的用法</h1><p>nohup 命令用于在 Linux/Unix 系统中以忽略挂起信号的方式运行命令，即使命令的终端关闭，它也能继续运行。常用于后台运行任务或脚本。</p><h2 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">nohup <span class="keyword">command</span> [<span class="keyword">args</span>] &gt; output.<span class="built_in">log</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure><p>command：你要执行的命令。</p><blockquote><p>output.log：将标准输出重定向到文件（默认是 nohup.out）。</p></blockquote><p>2&gt;&amp;1：将标准错误也重定向到标准输出（合并日志）。</p><p>&amp;：在后台运行该命令。</p><h2 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h2><ol><li>后台运行 Python 脚本：</li></ol><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">nohup <span class="keyword">python3</span> my_script.<span class="keyword">py</span> &gt; my_script.<span class="built_in">log</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure><ol><li>运行 shell 脚本并输出到默认文件：</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ./run_task.sh &amp;</span><br></pre></td></tr></table></figure><p>输出会写入当前目录下的 nohup.out。</p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>nohup 默认不接受用户输入（stdin 被关闭）。</p><p>日志建议重定向，否则信息会默认写入 nohup.out。</p><p>常与 &amp; 结合使用，真正放入后台运行。</p><h1 id="ROS-2-版本信息"><a href="#ROS-2-版本信息" class="headerlink" title="ROS 2 版本信息"></a>ROS 2 版本信息</h1><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">ros2 doctor <span class="comment">--report</span></span><br></pre></td></tr></table></figure><p>查看有哪些包：</p><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">ros<span class="number">2</span> pkg <span class="keyword">prefix</span> rclcpp</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <img src="https://segmentfault.com/q/1010000006210048" alt="hexo如何引用自己的文章？"></p>]]></content>
      
      
      <categories>
          
          <category> TOOLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启程の路</title>
      <link href="/2019/11/26/archived_Efort/"/>
      <url>/2019/11/26/archived_Efort/</url>
      
        <content type="html"><![CDATA[<p><p id="div-border-left-blue"> Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work, and the only way to do great work is to love what you do. --Steve Jobs </p><br>​      </p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>找到工作的自己确实非常非常开心,能做着自己感觉是伟大的工作,本身就是一件非常幸福的事情,回忆起自己找工作的这段旅程,确实很有趣,会给以后的自己留下一份不错的记忆。其中非常的感谢那些支持自己的人,比如性格超赞的小清,最近晒女朋友的小强等等,当然最感谢的还是HR吕小姐姐了,会用自己以后的行动去阐释的感谢这一词的。</p><p>对于自己而言,当然还是喜欢探索以及学习,能够把自己的想法付诸于现实,是非常富有成就感的,游戏只能给予小小的成就感,没少玩过游戏,要谈谈哪场游戏让自己印象最深刻,这个还真的想不起,但是,想想自己推导运动学逆解,符号形式的动力学方程并用机器人工具箱验证成功的时候等待,那种感觉此生怕是忘不了了。好吧,职业病犯了,谈起职业相关的,总是停不下了,就此打住了,依旧保持记笔记的习惯,一开始会差很多,相信坚持下来,会变得越来越好的, 加油！(换了macos系统,当然最爱的还是linux, 只是为了以后的工作,此篇就是在自己的mac下完成的, 玩linux还是在自己的raspberry pi 4b上了, 不过用了一段时间mac, 感觉和linux特别的相似,可能是经常用命令行的缘故吧,不过更好的是支持了一些常用的软件,各有优势吧)</p><h2 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h2><p>好吧,不知不觉之间就已经在实习的路上了,当然,对以往的粗心大意做了很多的弥补,毕竟以后用上的是真正的机械臂啊,出了问题,谁负责,所以得好好改改自己的这个随意的性格,变得严谨一些,未尝不是一件好事。 在这学习感觉就像是在人间天堂,好舒服,哈哈～, 会变成自己想要成为的人,将想法付诸于实践之中,话说也不知道啥时候能真正的碰上机械臂,好期待～。 </p><p>不知觉的之间,距离实习结束都一个多月了,感觉实习期间啥都没做,需要学习的东西还很多很多,比如现在还没有动手实现过卡尔曼滤波,最近好想上手来试一试。。。另外的就是,一个月期间,完成了论文的绝大多数,想想还蛮不可思议的,就是说嘛,不逼自己一把,根本就不知道自己有多菜。。。。好了,由于一些事情的堆积,导致现在在更新这个,上一次写都在两个多月前了,所以说,时光总是把人抛。当然,特别感谢储昭琦给予的照顾,学会了不少的东西,以后希望能够将所学的应用到这个行业中,这是非常有意义的事情,好好学习英语,希望能有一天出国无障碍般的交流,尽管知道很难,相信终有实现的那天的。</p><p>—时庚子年四月初八。</p>]]></content>
      
      
      <categories>
          
          <category> LIFE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记(一)</title>
      <link href="/2019/09/29/archived_cPlusPlus/"/>
      <url>/2019/09/29/archived_cPlusPlus/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#容器作为函数参数如何传参">容器作为函数参数如何传参</a></li><li><a href="#resize-and-reserve">resize AND reserve</a></li><li><a href="#动态内存分配和指针">动态内存分配和指针</a></li><li><a href="#hpp与h区别">.hpp与.h区别</a></li><li><a href="#类与对象">类与对象</a><ul><li><a href="#成员访问控制">成员访问控制</a><ul><li><a href="#示例">示例</a></li><li><a href="#注意事项">注意事项</a></li><li><a href="#关于类的注意事项">关于类的注意事项</a></li></ul></li><li><a href="#读取以及处理数据">读取以及处理数据</a></li><li><a href="#结合解引用和成员访问操作">结合解引用和成员访问操作</a><ul><li><a href="#表达式">表达式</a></li><li><a href="#函数相关">函数相关</a></li></ul></li><li><a href="#函数的传入参数">函数的传入参数</a></li></ul></li><li><a href="#常用库或函数使用说明">常用库或函数使用说明</a><ul><li><a href="#pugixml">pugixml</a></li></ul></li><li><a href="#知识点">知识点</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一些自己感觉比较有用的概念. 实际上就是一份从入门到放弃的笔记,毕竟还是喜欢从网上逛博客学知识,零散些没什么,能够将这些知识串起来就很有用了。</p><h1 id="容器作为函数参数如何传参"><a href="#容器作为函数参数如何传参" class="headerlink" title="容器作为函数参数如何传参"></a>容器作为函数参数如何传参</h1><p>1, void 函数名( vector&lt; int&gt; obj );</p><p>2,  void 函数名( vector&lt; int&gt;* pobj );</p><p>3,  void 函数名( const vector&lt; int&gt;* pobj ); // 在函数内不能改变 pobj 指向的对象 ,//调用时不会调用拷贝构造函数</p><p>4,  void 函数名( vector&lt; int&gt;&amp; obj );</p><p>5,  void 函数名( const vector&lt; int&gt;&amp; obj ); // 在函数内不能改变 obj 对象,// 在函数调用时调用了vector的拷贝构造函数</p><p>表达式放在构析函数中, 如果类的析构函数存在, 那么在每个类的生命期结束时它会被调用.析构函数由类名前面加一个波浪号来标识.</p><h1 id="resize-AND-reserve"><a href="#resize-AND-reserve" class="headerlink" title="resize AND reserve"></a>resize AND reserve</h1><ol><li><p>capacity:指容器在分配新的存储空间之前能存储的元素总数.size:指当前容器所存储的元素个数.</p></li><li><p>reserve表示容器预留空间,但并不是真正的创建对象,需要通过insert()或push_back()等创建对象.resize既分配了空间,也创建了对象.</p></li><li><p>reserve只修改capacity大小,不修改size大小,resize既修改capacity大小,也修改size大小.</p></li></ol><h1 id="动态内存分配和指针"><a href="#动态内存分配和指针" class="headerlink" title="动态内存分配和指针"></a>动态内存分配和指针</h1><p>静态与动态内存分配的两个主要区别是:</p><p>1, 静态对象是有名字的变量, 直接对其进行操作,而动态对象是没有名字的变量,通过指针间接地对它进行操作;</p><p>2, 静态对象的分配与释放由编译器自动处理事情, 相反,动态对象的分配与释放,必须由程序员显式地管理但不需要做任何事情,相对来说比较容易出错它通过new和delete两个表达式来完成, 对于动态分配的内存惟一的访问方式是通过指针间接地访问</p><p>3, 没有办法给动态分配的数组的每个元素显式地指定一个初始值, 当用完了动态分配的对象或对象的数组时, 必须显式地释放这些内存, 可以通过使用 delete 表达式的两个版本之一来完成这件事情,而释放之后的内存则可以被程序重新使用.</p><p>4, 如果忘了删除动态分配的内存程序就会在结束时出现内存泄漏 (memory leak) 的问题</p><p>5,  由于 C++不允许成员函数与数据成员共享同一个名字, 所以在这样的情况下,一般的习惯是在数据成员名字前面加一个下划线.</p><p>6,  在类定义中被定义的成员函数会被自动当作是内联函数,此外我们也可以用inline关键字显式地要求一个函数被视为内联函数</p><p>7, 被声明为 static 的数据成员是一类特殊的共享数据成员无论这个类的对象被定义了多少个静态数据成员在程序中也只有一份.</p><h1 id="hpp与-h区别"><a href="#hpp与-h区别" class="headerlink" title=".hpp与.h区别"></a>.hpp与.h区别</h1><p>.hpp,本质就是将.cpp的实现代码混入.h头文件当中,定义与实现都包含在同一文件,则该类的调用者只需要include该.hpp文件即可,无需再将cpp加入到project中进行编译.而实现代码将直接编译到调用者的obj文件中,不再生成单独的obj,采用hpp将大幅度减少调用project中的cpp文件数与编译次数,也不用再发布lib与dll文件,因此非常适合用来编写公用的开源库.</p><p>由于.hpp本质上是作为.h被调用者include的,所以当hpp文件中存在全局对象或者全局函数,而该hpp被多个调用者include时,将在链接时导致符号重定义错误.要避免这种情况,需要去除全局对象,将全局函数封装为类的静态方法.</p><p>Note: 函数返回运算结果的前提有3个：</p><p>1) 使用指针变量作为函数形参。</p><p>2)用接受运算结果的变量的指针(或地址)作为实参调用函数 </p><p>3)函数中通过指针间接引用修改这些变量。</p><p>Note: 函数名既代表函数,又是函数的指针。 2) delete只能删除由new创建的动态对象,否则将导致程序错误。</p><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>1, 类成员可以是数据, 函数或类型别名。所有成员必须在类的内部声明, 一旦类定义完成后, 就没有任何其他方式再增加成员了。</p><p>2, 类定义一般放在程序文件开头, 或者放到头文件中被程序文件包含, 此时这个定义是全局的。在全局作用域内, 该定义处处可见, 因此同一作用域内的所有函数都可以使用它。</p><h2 id="成员访问控制"><a href="#成员访问控制" class="headerlink" title="成员访问控制"></a>成员访问控制</h2><p>对类的成员进行访问,来自两个访问源： 类成员和类用户。类成员指的是类本身的成员函数,类用户指的是类外部的使用者,包括全局函数,另一个类的成员函数等。 无论数据成员还是函数成员,类的每个成员都有访问控制属性,由一下三个访问标号说明: public, private, protected.  类成员和类用户都可以访问公有成员,任何一个来自类外部的类用户都必须通过公有成员来访问。显然,public实现了类的外部接口。</p><p>只有类成员可以访问私有成员,类用户的访问是不允许的。显然,private实现了私有成员的隐蔽。</p><p>保护成员用protected标号说明,在不考虑继承的情况下,protected的性质和private的性质一致,但保护成员可以被派生类的类成员访问。总的来说可以参考如下表中所示</p><div class="table-container"><table><thead><tr><th>访问     &emsp;</th><th>public &emsp;</th><th>protected &emsp;</th><th>private</th></tr></thead><tbody><tr><td>同一个类 &emsp;</td><td>yes    &emsp;</td><td>yes       &emsp;</td><td>yes</td></tr><tr><td>派生类   &emsp;</td><td>yes    &emsp;</td><td>yes       &emsp;</td><td>no</td></tr><tr><td>外部的类 &emsp;</td><td>yes    &emsp;</td><td>no        &emsp;</td><td>no</td></tr><tr><td>友元类   &emsp;</td><td>yes    &emsp;</td><td>yes       &emsp;</td><td>yes</td></tr></tbody></table></div><p>另外需要说明:</p><p>1) 数据成员一般声明为 private,以实现信息的隐蔽.</p><p>2) 成员函数一般声明为 public,以提供外界使用的接口.</p><p>3) 构造函数一般声明为 public,以便创建类的对象.</p><p>4) 创建一个类类型的对象时,编译器会自动使用一个构造函数来初始化该对象,构造函数是一个特殊的、与类同名的成员函数,用于初始化每个数据成员来设置初始值。</p><p>5) 构造函数一般使用一个构造函数初始化列表,来初始化对象的数据成员.</p><p>6) 在类内部,声明成员函数是必需的,而定义成员函数则可选,可以在类外定义。在类内部定义的函数默认为 inline 函数.</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>可用下面代码辅助理解</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PublicFunction</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 可以在类外部调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 保护接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ProtectedFunction</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 在派生类中可以调用，但在类外部无法直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrivateFunction</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 只能在类的内部调用，类外部无法直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>下面需要注意的源自于林锐的《高质量C++/C编程指南》</p><p>1, <strong>在多重循环中,如果有可能,应当将最长的循环放在最内层,最短的循环放在最外层,来提高程序运行效率。</strong></p><p>2,  <strong>如果循环体内存在逻辑判断,并且循环次数很大,宜将逻辑判断移到循环体的外面.</strong></p><p>3, <strong>Switch 是多分支选择语句,而 if  语句只有两个分支可供选择。虽然可以用嵌套的 if 语句来实现多分支选择,但那样的程序冗长难读。这是 switch 语句存在的理由。</strong></p><p>常见的内存错误及其对策如下</p><p>1, 内存分配未成功,却使用了它。</p><p>2, 内存分配虽然成功,但是尚未初始化就引用它。</p><p>3, 内存分配成功并且已经初始化,但操作越过了内存的边界</p><p>4, 忘记了释放内存,造成内存泄露。</p><p>5, 释放了内存却继续使用它。</p><p>Note: </p><p>1) 用 malloc 或 new 申请内存之后,应该立即检査指针值是否为 NULL。防止使用指针值为 NULL 的内存</p><p>2) 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。</p><p>3) 避免数组或指针的下标越界,特别要当心发生“多 1”或者“少 1”操作。</p><p>4) 动态内存的申请与释放必须配对,防止内存泄漏。</p><p>5)用 free 或 delete 释放了内存之后,立即将指针设置为 NULL,防止产生“野指针”.</p><p>malloc 返回值的类型是 void *,所以在调用 malloc 时要显式地进行类型转换,将 void *转换成所需要的指针类型。</p><h3 id="关于类的注意事项"><a href="#关于类的注意事项" class="headerlink" title="关于类的注意事项"></a>关于类的注意事项</h3><p>类的基本思想是数据抽象和封装。数据抽象是种依赖于接口(interface)和实现(implementation)分离的编程(以及设计)技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p><p>除了静态 static 数据成员外,数据成员不能在类体中被显式地初始化。</p><h2 id="读取以及处理数据"><a href="#读取以及处理数据" class="headerlink" title="读取以及处理数据"></a>读取以及处理数据</h2><p>1) file.good()是在文件读取或者写的过程中出现错误；或者读到文件最后继续读才会返回false;</p><p>2) 在读取数组文件的时候,用上了getline这个函数,其函数用法如下,其中默认就是按行读取,这样的好处就是,去模拟信号的输入。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (buffer, stream_size, delimiter)</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(<span class="type">char</span>*, <span class="type">int</span> size, <span class="type">char</span>=<span class="string">&#x27;\n&#x27;</span>)</span></span></span><br></pre></td></tr></table></figure><h2 id="结合解引用和成员访问操作"><a href="#结合解引用和成员访问操作" class="headerlink" title="结合解引用和成员访问操作"></a>结合解引用和成员访问操作</h2><p>解引用迭代器可获得迭代器所指的对象,如果该对象的类型恰好是类,就有可能希望进一步访问它的成员。例如,对于一个由字符串组成的 vector 对象来说,要想检査其元素是否为空,令 it 是该 vector 对象的迭代器,只需检査主 it 所指字符串是否为空就可以了,其代码如下所示</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">(*it)</span>.empty<span class="comment">()</span></span><br></pre></td></tr></table></figure><p>注意,(*it).empty()中的圆括号必不可少,</p><p>为了简化上述表达式,C++语言定义了箭头运算符(-&gt;)。箭头运算符把解引用和成员访问两个操作结合在一起,也就是说,it->mem 和(*it).mem 表达的意思相同。</p><p>Note: String 和 vector 是两种最重要的标准库类型。string 对象是一个可变长的字符序列,vector 对象是一组同类型对象的容器。 迭代器允许对容器中的对象进行间接访问,对于 string 对象和 vector 对象来说,可以通过迭代器访问元素或者在元素间移动。 数组和指向数组元素的指针在一个较低的层次上实现了与标准库类型 string 和 vector 类似的功能。一般来说,应该优先选用标准库提供的类型,之后再考虑 C++语言内置的低层的替代品数组或指针</p><p>Note: ++运算符(++operator)是迭代器和指针定义的递增运算符。执行“加 1”操作使得迭代器指向下一个元素。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>当一个对象被用作右值的时候,用的是对象的值(内容)；当对象被用作左值的时候,用的是对象的身份(在内存中的位置)。 后置递增运算符的优先级高于解引用运算符,因此*pbeg++等价于*(pbeg++)。pbeg++把 pbeg 的值加 1, 然后返回 pbeg 的初始值的副本作为其求值结果,此时解引用运算符的运算对象是 pbeg 未增加之前的值。最终,这条语句输出 pbeg 开始时指向的那个元素,并将指针向前移动一个位置。 对于逗号运算符来说,首先对左侧的表达式求值,然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值,那么最终的求值结果也是左值。</p><h3 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h3><p>通过调用运算符(call operator)来执行函数。调用运算符的形式是一对圆括号,它作用于ー个表达式,该表达式是函数或者指向函数的指针：圆括号之内是一个用逗号隔开的实参(argument)列表,我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。</p><p>函数的形参列表可以为空,但是不能省略。要想定义一个不带形参的函数,最常用的办法是书写一个空的形参列表。不过为了与 C 语言兼容,也可以使用关键字 void 表示函数没有形参.  形参列表中的形参通常用逗号隔开,其中每个形参都是含有一个声明符的声明。即使两个形参的类型一样,也必须把两个类型都写出来.</p><p>大多数类型都能用作函数的返回类型。一种特殊的返回类型是 void,它表示函数不返回任何值。函数的返回类型不能是数组,类型或函数类型,但可以是指向数组或函数的指针。</p><p>和其他变量一样,形参的类型决定了形参和实参交互的方式。如果形参是<strong>引用类型</strong>,它将绑定到对应的实参上；否则,将实参的值拷贝后赋给形参。 当形参是引用类型时,我们说它对应的实参被引用传递或者函数被传引用调用。和其他引用一样,引用形参也是它绑定的对象的别名：也就是说,引用形参是它对应的实参的别名 当实参的值被拷贝给形参时,形参和实参是两个相互独立的对象。我们说这样的实参被值传递(passed by value)或者函数被传值调用(called by value)。</p><p><strong>指针</strong>就是一个存放地址的变量, 指针的行为和其他非引用类型一样。当执行指针拷贝操作时,拷贝的是指针的值。拷贝之后,两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象,所以通过指针可以修改它所指对象的值.</p><p>拷贝大的类类型对象或者容器对象比较低效,甚至有的类类型(包括 IO 类型在内)根本就不支持拷贝操作。当某种类型不支持拷贝操作时,函数只能通过引用形参访问该类型的对象。</p><p>举个例子,我们准备编写一个函数比较两个 string 对象的长度。因为 string 对象可能会非常长,所以应该尽量避免直接拷贝它们,这时使用引用形参是比较明智的选择又因为比较长度无须改变 string 对象的内容,所以把形参定义成对常量的引用.</p><p>Note: 如果函数无须改变引用形参的值,最好将其声明为常量引用。</p><p>一个函数只能返回一个值,然而有时函数需要同时返回多个值,引用形参为我们一次返回多个结果提供了有效的途径。</p><p>和所有数组一样,当将多维数组传递给函数时,真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组,所以首元素本身就是一个数组,指针就是一个指向数组的指针。数组第二维(以及后面所有维度)的大小都是数组类型的一部分,不能省略</p><p>使用迭代器访问元素:<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator <span class="keyword">it</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">it</span>=vec.begin();<span class="keyword">it</span>!=vec.<span class="keyword">end</span>();<span class="keyword">it</span>++)</span><br><span class="line">    cout&lt;&lt;*<span class="keyword">it</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure></p><p>int *a = new int[10] ();  // 每个元素初始化为0,括号内不能写其他值,只能初始化为0</p><p>谨记一句话,但凡使用了迭代器的循环体,都不要向迭代器所属的容器添加元素</p><p>C++初始化类成员的,它们是按照声 明的顺序初始化的,而不是按照出现在初始化列表中的顺序。 </p><h2 id="函数的传入参数"><a href="#函数的传入参数" class="headerlink" title="函数的传入参数"></a>函数的传入参数</h2><p>要修改变量的值,需要使用变量类型的指针作为参数或者变量的引用。如果变量是一般类型的变量,例如int,则需要使用int 类型的指针类型int * 作为参数或者int的引用类型int&amp;。但是如果变量类型是指针类型,例如char*,那么需要使用该类型的指针,即指向指针的指针类型 char**,或者该类型的引用类型char*&amp;。</p><h1 id="常用库或函数使用说明"><a href="#常用库或函数使用说明" class="headerlink" title="常用库或函数使用说明"></a>常用库或函数使用说明</h1><h2 id="pugixml"><a href="#pugixml" class="headerlink" title="pugixml"></a>pugixml</h2><p>pugixml 是一个用于解析和操作 XML 文档的 C++ 库，它被设计为轻量级、高性能且易于使用。pugixml 提供了简单而强大的 API，使得处理 XML 数据变得简单而高效。以下是关于 pugixml 的介绍和使用方法：</p><p><strong>特点和优势：</strong></p><p>轻量级： pugixml 是一个轻量级的库，不需要大量的内存开销，因此适用于嵌入式系统和资源受限的环境。<br>高性能： pugixml 在解析和处理 XML 数据时具有很高的性能，它使用了一些优化策略，如内存池，来提高效率。<br>易于使用： pugixml 提供了简洁明了的 API，使得读取、写入和操作 XML 数据变得非常容易。<br>安装和集成：</p><p>pugixml 不需要额外的安装过程，它是一个头文件库（header-only library），你只需要将 pugixml 的头文件包含在你的项目中即可开始使用。</p><p><strong>使用示例</strong></p><p>以下是一个简单的 pugixml 使用示例，展示了如何解析一个 XML 文档并访问其中的元素和属性：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pugixml.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pugi::xml_document doc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载 XML 文件</span></span><br><span class="line">    pugi::xml_parse_result result = doc.<span class="built_in">load_file</span>(<span class="string">&quot;example.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;XML parsing error: &quot;</span> &lt;&lt; result.<span class="built_in">description</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问根节点</span></span><br><span class="line">    pugi::xml_node root = doc.<span class="built_in">child</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Root node name: &quot;</span> &lt;&lt; root.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历子节点</span></span><br><span class="line">    <span class="keyword">for</span> (pugi::xml_node child : root.<span class="built_in">children</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Child node name: &quot;</span> &lt;&lt; child.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 访问节点属性</span></span><br><span class="line">        <span class="keyword">for</span> (pugi::xml_attribute attr : child.<span class="built_in">attributes</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Attribute name: &quot;</span> &lt;&lt; attr.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;, value: &quot;</span> &lt;&lt; attr.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例首先加载了一个名为 example.xml 的 XML 文件，然后访问了根节点和其子节点，以及子节点的属性。</p><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>1, 如果文件名用<span id = "inline-blue"> 尖括号括 </span>起来,  表明这个文件是一个工程或标准头文件查找过程会<span id = "inline-blue"> 检查预定义的 </span>目录;如果文件名用一对<span id = "inline-blue"> 引号括 </span>起来则表明该文件是用户提供的头文件查找该文件时将从<span id = "inline-blue"> 当前文件目 </span>录开始.</p><p>2, C++ 程序可以定义为对象的集合, 这些对象通过调用彼此的方法进行交互.</p><p>3, 块注释符是不可以嵌套使用的.</p><p>4,  <iostream>头文件中定义的操纵符有：  endl:输出时插入换行符并刷新流;endls：输出时在字符 插入NULL作为尾符;flush：刷新缓冲区, 把流从缓冲区输出到目标设备, 并清空缓冲区; ws：输入时略去空白字符;dec：令IO数据按十进制格式;hex:令IO数据按十六进制格式; oct：令IO数据按八进制格式</p><p>5, 使用 typedef 为一个已有的类型取一个新的名字;</p><p>6,  枚举类型(enumeration)是C++中的一种派生数据类型, 它是由用户定义的若干枚举常量的集合. 如果一个变量只有几种可能的值, 可以定义为枚举(enumeration)类型.所谓”枚举”是指将变量的值一一列举出来, 变量的值只能在列举出来的值的范围内.</p><p>7, 把常量定义为大写字母形式, 是一个很好的编程实践.</p><p>8, const 类型的对象在程序执行期间不能被修改改变.修饰符 volatile 告诉编译器不需要优化volatile声明的变量,让程序可以直接从内存中读取变量.对于一般的变量编译器会对变量进行优化,将内存中的变量值放在寄存器中以加快读写效率.由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式.只有 C99 增加了新的类型限定符 restrict.</p><p>9, extern 存储类用于提供一个全局变量的引用,全局变量对所有的程序文件都是可见的.当您使用 ‘extern’ 时,对于无法初始化的变量,会把变量名指向一个之前定义过的存储位置. 当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时,可以在其他文件中使用 extern 来得到已定义的变量或函数的引用.可以这么理解,extern 是用来在另一个文件中声明一个全局变量或函数.</p><p>10, “::”在C++中表示作用域,和所属关系.”::”是运算符中等级最高的</p><p>11,  预定义的对象 cin 是 iostream 类的一个实例.cin 对象附属到标准输入设备,通常是键盘.cin 是与流提取运算符 &gt;&gt;</p><p>12,  array也位于名称空间std中,与数组一样,array对象的长度也是固定的,也使用栈(静态内存分配),而不是自由存储区,因此其效率与数组相同,但更方便,更安全. </p><p>13, 类定义是以关键字 class 开头,后跟类的名称.类的主体是包含在一对花括号中.类定义后必须跟着一个分号或一个声明列表.</p><p>14, 关键字 public 确定了类成员的访问属性.在类对象作用域内,公共成员在类的外部是可访问的.</p><p>15, 点运算符“.”应用于实际的对象,箭头运算符“-&gt;”与一个指针对象的指针一起使用.</p><p>16,  ::std::vector&lt;&gt; 是一个认真设计的值类型,天生是可以拷贝构造和可赋值的.如果 T 是可比较的,那么 ::std::vector<T> 将自动地是可以比较的. 四个特殊的成员函数 T(); // 缺省构造函数(default constructor) ~T(); // 解构函数(destructor) T( T const&amp; ); // 拷贝构造函数 T&amp; operator=( T const&amp; ); // 拷贝赋值函数</p><p>17, 容量是指在容器下一次需要增长自己之前能够被加入到容器中的元素的总数连续存储的容器相关.</p><p>18, 实际的矩阵是在构造函数中动态分配的,在析构函数中删除的.</p><p>19, CLU, Ada 和 Modula-2 是三种支持抽象数据类型的程序设计语言.</p><p>20, 条件指示符#ifndef 检查前面是否已经被定义,#ifdef 指示符常被用来判断一个预处理器常量是否已被定义以便有条件地包含程序代码.</p><p>21, 不能用赋值操作符把一个数组拷贝到另一个中去.</p><p>22, 在C++中,设计 size_t 就是为了适应多个平台的. size_t的引入增强了程序在不同平台上的可移植性. 类似于无符号整形(unsignted int)</p><p>23, 每个类对象在被程序最后一次使用之后它的析构函数就会被自动调用.</p><p>24, &amp;:取地址,*：间接引用. 预处理命令的操作对象是编译器和连接器。</p><p>25, 当指针变量p指向整型变量a时,*p的运算结果就是a本身,而非a的值。</p><p>26, 多数情况下,应该在指针间接引用之前检测是否为空指针,从而避免异常错误。</p><p>27, p1指向变量a,p2指向变量b,*p1等价于a, *p2等价于b.</p><p>28,  不要返回函数里的局部对象的引用。</p><p>29,  结构体对象的指针成员存储的是地址,而不是指向的内容名,这一点与数组成员是不同的。</p><p>30, 当创建一个类时,您不需要重新编写新的数据成员和成员函数,只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类,新建的类称为派生类.</p><p>31, 为了避免同一个头文件被包含(include)多次,C/C++中有两种宏实现方式：一种是#ifndef方式；另一种是#pragma once方式。</p><p>32,  有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型,但是不想用该表达式的值初始化变量。为了满足这一要求,C++11 新标准引入了第二种类型说明符 decltype,它的作用是选择并返回操作数的数据类型。在此过程中,编译器分析表达式并得到它的类型,却不实际计算表达式的值.</p><p>33, 切记：decltype ((variable))(注意是双层括号)的结果永远是引用,而 decltype (variable)结果只有当 variable 本身就是一个引用时才是引用。</p><p>34, const是说明这个函数不会修改任何数据成员(object)。 为了声明一个const成员函数, 把const关键字放在函数括号的后面。声明和定义的时候都应该放const关键字。</p><p>35, Vector作为函数的参数或者返回值时,需要注意它的写法vector<int>&amp;a,  其中的“&amp;”不能少.</p><p>36, 类的构造函数是类的一种特殊的成员函数,它会在每次创建类的新对象时执行。 构造函数的名称与类的名称是完全相同的,并且不会返回任何类型,也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p><p>37, 任何不会修改数据成员的函数都应该声明为const类型;</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1, 《C++ Primer 第五版》</p><p>2, <a href="https://blog.csdn.net/w_linux/article/details/72417896">浅然言而信</a></p><p>3,  <a href="https://blog.csdn.net/jackywgw/article/details/6248342">jackywgw</a></p><p>4, <a href="https://www.cnblogs.com/lzhu/p/8034817.html">瘋子朱磊</a></p><p>5, 《高质量C++/C编程指南》—林锐</p><p>6, <a href="https://blog.csdn.net/txl199106/article/details/48622643">Tham</a></p><p>7, <a href="https://www.cnblogs.com/wuchanming/p/4310506.html">Jessica程序猿</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tools </tag>
            
            <tag> work </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab 浅记</title>
      <link href="/2019/09/19/archived_matlab2019/"/>
      <url>/2019/09/19/archived_matlab2019/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#命名方式">命名方式</a></li><li><a href="#编程规范">编程规范</a></li><li><a href="#函数定义">函数定义</a></li><li><a href="#技巧">技巧</a></li><li><a href="#octave配置">octave配置</a></li><li><a href="#后记">后记</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自己在学习这个工具的时候是由点及面的,而不是从头到尾按照顺序进行学习,这样的话不知道自己的需求是什么,学习起来就显得非常的乏味,这样就感受不到工具所带来的简便性所带来的乐趣。 仅仅收藏一些自己感觉有用的技巧以及遇到的错误及其解决方法,因为matlab能做的事太多了,网络上教程又那么多,不想画蛇添足, 另外吐槽的一点就是关于matlab的中文书籍(有不少),书中错误挺多,像是半成品,匆忙完成,虽说是工具吧,但是体现了认真负责的态度,而不是简单的堆砌文字,算了自己也没资格去评论。 这个写的太晚了,但是对于未来几十年,这恰恰不晚。另外matlab的程序,百分之95的代码都可以octave中运行的,而且octave是免费开源的,可以避免不必要的版权纠纷,尤其是在公司里上班,可以带来不必要的麻烦, 因此在本文最后会有一部分octave配置方面的内容。 另外个人感觉最重要的就是学会使用 <span id = "inline-green">help</span>和搜索技巧, 不光是matlab, 其他编程语言也是如此。</p><p>matlab有大量的资源在文件交换那,如果是想搜中文的话,进入matlab中文论坛去文件交换那搜索下载就好,或者是搜索 File Exchange 关键字也可以找到文件交换的入口。</p><p><img src="/img/postImg/11_Matlab/fileExchange.png" width="70%" height="50%"></p><p><img src="/img/postImg/11_Matlab/C_fileExchange.png" width="68%" height="50%"></p><h1 id="命名方式"><a href="#命名方式" class="headerlink" title="命名方式"></a>命名方式</h1><p>因为命名方式对于程序而言是非常重要的,自己对此感触颇深,以前写出的代码,以为只有天知道我知道,如今工作了再看那些代码,只有鬼知道。</p><p>1,变量名应该能够反映该变量的含义或用途,以小写字母开头,采用大小写混用模式或下画线分割模式, 如：areYouOk,are_you_ok等。</p><p>2,临时变量的变量名尽量短小。</p><p>3,布尔变量禁止使用否定式的变量名。比如使用areYouOk,而不使用areYouNotOk,一是因为~areYouNotOk相当于双重否定,感觉会有些别扭,二是前者感觉会更加的简介。</p><p>4,缩写形式即使全部为大写字母,在变量命名名时也应该与小写字母混合使用。</p><p>5,常数名、全局变量名、永久变量名应该全部采用大写字母,且用下画线分割单词。</p><p>6,结构体命名应该以大写字母开头</p><p>7,结构体的字段名不需要包含结构体名的含义</p><p>8,所有的函数命名应该采用英文形式,禁止使用汉语拼音</p><h1 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h1><p>总体原则:避免使用含糊代码。代码不是越简洁越好,而是越清楚越好,一开始写的时候还是需要注意些的,不能图一时爽,修改维护的时候就知道难受了,下面主要是写给自己看的。</p><p>1) 在内存充足的情况下,变量尽量不要重复使用,赋予每个变量唯一的含义,可以增强代码的可读性。</p><p>2) 在文件开始的注释,为重要变量编写文档。 </p><p>3) 在常量定义处,为该常量编写注释。 </p><p>4) 尽量少地使用全局变量。全局变量过多,不利于代码的维护和阅读。</p><p>5) 浮点数的逻辑运算要当心系统误差。</p><p>6) 函数头部的注释应该支持help和lookfor对该函数的查询,因此,该行注释中应尽可能包含可能的搜索关键字。 </p><p>7) 函数头部的注释应描述该函数的功能,并列出输入参数不同时该函数的语法和功能。</p><h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">定义</span> M 文件函数</span><br><span class="line">nargin 返回函数输入参数个数</span><br><span class="line">nargout 返回函数输出参数个数</span><br><span class="line">nargchk 验证输入参数个数</span><br><span class="line">nargoutchk 验证输出参数个数</span><br><span class="line">varargin 接收函数的输入参数到单元数组</span><br><span class="line">varargout 返回函数的输出参数到单元数组</span><br><span class="line">inputname 返回当前所执行 M 文件的文件名</span><br></pre></td></tr></table></figure><p>这里nargin可以分解为n+arg+in,即Number+ argument+ input,输入参数的个数。其他类似。 函数体中的nargin与nargout 函数 ,能够在调用一个函数时,指明函数有几个输入和输出参数。比如</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">n = nargin 返回所在函数的输入参数个数。</span><br><span class="line">N= nargin(<span class="function"><span class="keyword">fun</span>) 返回函数<span class="keyword">fun</span>定义的输入参数个数;如果定义的输入参数个数不确定,返回-1。</span></span><br></pre></td></tr></table></figure><p>这样在输入参数不够或者多的时候抛出异常。</p><p>varargin 和 varargout 传送或返回不定数目的参数。有一些函数,输入的参数或返回到调用函数的参数个数不确定,这就需要用到varargin 和 varargout 函数。比如</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">out</span> = myFun(varargin)</span><br></pre></td></tr></table></figure><p>如果在函数声明行将 varargin 作为最后一个输入参数,则函数在调用时可接受任意个变量。函数 myFun 接受任意个输入参数,组成一个单元数组,varargin 为单元数组名。该单元数组第 i 个单元就是从 varargin 位置算起的第 i 个输人参数。类似的,比如定义</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">out</span> = myFun(a,varargin)</span><br></pre></td></tr></table></figure><p>当调用格式为myFun(a,b,c)时,varargin 是长度为 2 的单元数组,并且 varargin{1} = b, varargin{2} = c。</p><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>0, 从自己学习的角度来说,最重要的就是学会使用help, 从自带的例子就可以学到很多,网上的一些说明和教程也不见得是对的,从自带的帮助里面也可以学习到一些编程技巧等等。</p><p>1,set(0,’RecursionLimit’,N) 修改最大递归限制,这个是自己寻找合适的参数时,有时需要跑很久才能找到自己需要的参数,限制就是递归到５００次就停止了,这样修改可以使得留下更多的时间冲一杯咖啡再回来看看结果有没有出来。 (忘记说一件事了,如果把N改的很大,内存溢出别来打我),当然另外一种极端的方法就是设置类似于控制里面的思路,设置误差函数,误差也就是你期待的值减去实际的值,当满足所给精度要求后,退出循环(简单的实现就是利用while循环),输出相关参数,这个对于给定输入并给出特定输出的时候比较适用(类似于函数关系)。这个可以应用于离线仿真的寻找比较好的参数的时候使用,这样就无须手动调整了。</p><p>2,若a为一个向量,则命令 b = a(:) 可以保证b为列向量。即无论a为行向量或列向量,b均是列向量, 这个在设计程序的时候非常有用。 要有预分配内存的习惯,这样会使得程序的运行效率高一些。</p><p>3,在程序的主函数或者在运行函数前写上dbstop if error, 十分有助于调试;  strfind 可以作用于数值数组用于查找子串的位置。</p><p>4,如果可以, 请使用 <span id = "inline-blue"> octave </span>来替代matlab,因为以后matlab毕竟是商业数学软件,而且价格还很贵,在mac上使用可以在配置文件中加上 alias octave=’octave-cli’,这样退出的话,就不会有多余的命令行界面了, 等有时间的话去测试下linux上是不是也是这样的。</p><p>5,就运行效率来说,逻辑索引要高于数值索引。 A(sub2ind(size(A),i,j))=[], 删除A的第i行、第j列的元素。</p><p>6,evalin 和 assignin 两个函数可以实现函数工作空间和基本工作空间中的变量的相互使用, 对于实验室小伙伴们在使用别人的代码去绘图或者是提取一些变量的时候非常有用,因为局部函数的值如果不去调试,一般来说是不会出现在工作空间中的。</p><p>7,MATLAB 中的 import 语句作用与 Python 中不同。Python使用 import 语句加载代码并使之能够访问。MATLAB使用 import 函数是为了不用包名就可以直接使用类或函数。</p><p>8,deal函数的使用可以使得程序简洁起来。 将输入分别分配给每个输出。</p><p>9,学会使用try,catch函数,一来可以避免程序因为错误或其他缘故而中止,二来可以很好的简化代码量。</p><p>10,在matlab中尽量避免使用for循环,有如下的替代方法,(1)优先考虑用向量化的运算来代替循环操作。(2)在必须使用多重循环时,循环次数少的放在外层,循环次数多的放在内层。</p><p>11, 逻辑数组和标量用.*, 这样会使得效率提升的非常快,下面举个栗子。</p><p><img src="/img/postImg/11_Matlab/eg1_matlab.png" width="70%" height="40%"></p><h1 id="octave配置"><a href="#octave配置" class="headerlink" title="octave配置"></a>octave配置</h1><p>从matlab转到octave其实就花了几天的时间,因为长期在命令行下工作,所以在命令行下玩octave当然不在话下。 如果你喜欢交互式的,那目测玩这个会有点费劲的,毕竟是开源的,没有matlab调试什么什么的那么方便了。</p><p>自己octave配置文件内容(.octaverc), 前提是这些包要安装上,不然就报错了,退出的话别直接ctrl+z了,不然后台还是在运行,在命令行中exit就行。</p><p>如果通过ctrl+z退出了,其后台依旧在运行,如果通过top指令查看进程并结束掉octave那个进程,可以使用如下方式 ‘ps aus|grep octave-cli’, 会想为什么会是这个指令呢？是不是有好奇心去探索下,哈哈～。</p><p>这里是自己配置文件里的内容,就像vim或者shell一样,换任何台linux/macos系统电脑,只需把之前的配置文件复制到新的电脑中即可,这样可以大大的简化繁琐的配置,这个是受用终身的。所以这里又一次的啰嗦了下。(最好把配置文件放在github或其他非常容易获取到的地方,放心,这个配置文件别人获取了也没什么用,属于私人订制)</p><details>  <summary>展开</summary><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setenv</span><span class="params">(<span class="string">&quot;GNUTERM&quot;</span>,<span class="string">&quot;qt&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">graphics_toolkit</span><span class="params">(<span class="string">&quot;gnuplot&quot;</span>)</span></span></span><br><span class="line">pkg load <span class="selector-tag">image</span></span><br><span class="line">pkg load symbolic</span><br><span class="line"><span class="function"><span class="title">graphics_toolkit</span><span class="params">(<span class="string">&quot;gnuplot&quot;</span>)</span></span></span><br><span class="line">edit mode sync</span><br><span class="line">edit home .</span><br><span class="line"><span class="function"><span class="title">EDITOR</span><span class="params">(<span class="string">&#x27;vim &gt; /dev/tty 2&gt;&amp;1 &lt; /dev/tty %s&#x27;</span>)</span></span></span><br><span class="line">dbstop <span class="keyword">if</span> error</span><br></pre></td></tr></table></figure></details><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>2023年8月评： 已经有好几年没有用MATLAB了，好多东西只有印象，好多技巧都给忘记了。。。。MATLAB这篇几乎一直没有更新过，曾几何时最熟悉的工具被自己遗忘的差不多了，惭愧；</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] 《MATLAB GUI学习手记第二版》</p>]]></content>
      
      
      <categories>
          
          <category> MATLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc使用简介</title>
      <link href="/2019/09/07/archived_gcc/"/>
      <url>/2019/09/07/archived_gcc/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前-言">前 言</a></li><li><a href="#make-file-的使用">make file 的使用</a></li><li><a href="#gdb调试-调试过程极度不爽">gdb调试 (调试过程极度不爽)</a><ul><li><a href="#运行">运行</a></li><li><a href="#设置断点">设置断点</a></li><li><a href="#查看源代码">查看源代码</a></li><li><a href="#打印表达式">打印表达式</a></li><li><a href="#查询运行信息">查询运行信息</a></li><li><a href="#分割窗口">分割窗口</a></li></ul></li><li><a href="#gnu-make-的编写">GNU make 的编写</a></li></ul><!-- vim-markdown-toc --><h1 id="前-言"><a href="#前-言" class="headerlink" title="前 言"></a>前 言</h1><p> <span id="inline-green">编译 </span> 是指把一个是纯文本的源代码的“程序”. 比如 C 或 C++这种编程语言,  转变成机器码,  即用于控制计算机的中央处理单元(CPU)的 1 和 0 的序列。这种机器码被存放在称为可执行文件的文件中,  有时候也被称为二进制文件。</p><p>我们假设源代码被存放在“test.c”的文件中。用 gcc 编译“test.c”文件,  可以用下面的命令:</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">test</span>.c  或者 gcc -Wall <span class="keyword">test</span>.c -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p>span id=”inline-red”&gt; 说明 &lt;/span&gt; ：“-o”选项可以指定存储机器码的输出文件,  该选项通常是命令行上的最后一个参数。如果省略它,  输出将被写到默认文件“a.out”中;命令行选项“-c”用于把源码文件编译成对象文件。  <span id="inline-green">“-Wall” </span>    选项打开所有最常用到的编译警告。也是可以在 C 编程中发现最常见的错误。 #include “FILE.h”和“#include <FILE.h>”这两种 include 声明形式的含义是有差异的,  前者是先在当前目录搜索“FILE.h”,  然后再查看包含系统头文件的目录。#include <FILE.h>这种 include 声明是搜索系统目录的头文件, 默认情况下不会在当前目录下查找头文件。</p><p>当程序被存储在一个个单独的源文件中时, 只有那些修改过源码的文件才需要重新编译。用这种方法, 源文件被分开一个个编译, 然后再链接在一起。 此过程分为两个步骤。在第一阶段, 文件被编译但不生成可执行文件。生成的结果被称为对象文件(obj 文件), 用 GCC 时有“.o”后缀名。在第二阶段, 各个对象文件由一个被称为链接器的单独的程序合成在一起。链接器把所有的对象文件组合在一起生成单个的可执行文件。对象文件包含的是机器码, 其中任何对在其他文件中的函数(或变量)的内存地址的引用都留着没有被解析。这样就允许在互相之间不直接引用的情况下编译各个源代码文件。链接器在生成可执行文件时会填写这些还缺少的地址。</p><h1 id="make-file-的使用"><a href="#make-file-的使用" class="headerlink" title="make file 的使用"></a>make file 的使用</h1><p><span id="inline-red"> Makefile </span> 简单的来说是自动化编译的脚本, 在一个大的工程文件中, 各个文件分别放在不同的文件夹中, 一个个的编译起来是十分费事的, 使用这个这个自动化脚本的好处就是只需要一个make命令, 整个工程完全自动编译, 极大的提高了软件开发的效率。而make是一个解释makefile中指令的命令工具, 这个在b站中可以详细的了解到, 不过作者在视频最后有故意贬低vim的意思, 他说的功能, 完全是可以自定义的呀, 所以。。。。没必要, vim还是非常非常优秀的编辑器, 也是个人最喜欢的编辑器(没有之一)。下面就摘抄如下<a href="https://blog.csdn.net/haoel/article/details/2886">博客</a>的内容, 因为自己的理解太浅, 写起来错误会很多。</p><p>源文件首先会生成中间目标文件, 再由中间目标文件生成执行文件。在编译时, 编译器只检测程序语法, 和函数、变量是否被声明。如果函数未被声明, 编译器会给出一个警告, 但可以生成Object File。而在链接程序时, 链接器会在所有的Object File中找寻函数的实现, 如果找不到, 那到就会报链接错误码(Linker Error)。</p><p>对于大型工程, 就要用到cmake了(针对c/c++)</p><h1 id="gdb调试-调试过程极度不爽"><a href="#gdb调试-调试过程极度不爽" class="headerlink" title="gdb调试 (调试过程极度不爽)"></a>gdb调试 (调试过程极度不爽)</h1><p>该内容搬运与<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">此</a></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>对C/C++程序的调试, 需要在编译前就加上-g选项:</p><p>需要说明的如下：</p><p>1,  run：简记为 r , 其作用是运行程序, 当遇到断点后, 程序会在断点处停止运行, 等待用户输入下一步的命令。</p><p>2,  continue (简写c )：继续执行, 到下一个断点处(或运行结束)</p><p>3,  next：(简写 n), 单步跟踪程序, 当遇到函数调用时, 也不进入此函数体；此命令同 step 的主要区别是, step 遇到用户自定义的函数, 将步进到函数中去运行, 而 next 则直接调用函数, 不会进入到函数体内。</p><p>4,  step (简写s)：单步调试如果有函数调用, 则进入函数；与命令n不同, n是不进入调用的函数的</p><p>5,  until：当你厌倦了在一个循环体内单步跟踪时, 这个命令可以运行程序直到退出循环体。</p><p>6,  until+行号： 运行至某行, 不仅仅用来跳出循环</p><p>7,  finish： 运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回值及参数值等信息。</p><p>8,  call 函数(参数)：调用程序中可见的函数, 并传递“参数”, 如：call gdb_test(55)</p><p>9,  quit：简记为 q , 退出gdb</p><h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><p>1,  break n (简写b n):在第n行处设置断点</p><p>2,  delete 断点号n：删除第n个断点</p><p>3,  disable 断点号n：暂停第n个断点</p><p>4,  enable 断点号n：开启第n个断点</p><p>5,  clear 行号n：清除第n行的断点</p><p>6,  info b (info breakpoints) ：显示当前程序的断点设置情况</p><p>7,  delete breakpoints：清除所有断点：</p><h2 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h2><p>1,  list ：简记为 l , 其作用就是列出程序的源代码, 默认每次显示10行。</p><p>2,  list 行号：将显示当前文件以“行号”为中心的前后10行代码, 如：list 12</p><p>3,  list 函数名：将显示“函数名”所在函数的源代码, 如：list main</p><p>4,  list ：不带参数, 将接着上一次 list 命令的, 输出下边的内容。</p><h2 id="打印表达式"><a href="#打印表达式" class="headerlink" title="打印表达式"></a>打印表达式</h2><p>1,   print 表达式：简记为 p , 其中“表达式”可以是任何当前正在被测试程序的有效表达式, 比如当前正在调试C语言的程序, 那么“表达式”可以是任何C语言的有效表达式, 包括数字, 变量甚至是函数调用。</p><p>2,   print a：将显示整数 a 的值</p><p>3,   print ++a：将把 a 中的值加1, 并显示出来</p><p>4,   print name：将显示字符串 name 的值</p><p>5,   print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</p><p>6,   print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</p><p>7,   display 表达式：在单步运行时将非常有用, 使用display命令设置一个表达式后, 它将在每次单步进行指令后, 紧接着输出被设置的表达式及值。如： display a</p><p>8,   watch 表达式：设置一个监视点, 一旦被监视的“表达式”的值改变, gdb将强行终止正在被调试的程序。如： watch a</p><p>9,   whatis ：查询变量或函数</p><p>10,   info function： 查询函数</p><p>11,   扩展info locals： 显示当前堆栈页的所有变量</p><h2 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h2><p>1,  where/bt ：当前运行的堆栈列表；</p><p>2,  bt backtrace 显示当前调用堆栈</p><p>3,  up/down 改变堆栈显示的深度</p><p>4,  set args 参数:指定运行时的参数</p><p>5,  show args：查看设置好的参数</p><p>6,  info program： 来查看程序的是否在运行, 进程号, 被暂停的原因。</p><h2 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h2><p>1,  layout：用于分割窗口, 可以一边查看代码, 一边测试：</p><p>2,  layout src：显示源代码窗口</p><p>3,  layout asm：显示反汇编窗口</p><p>4,  layout regs：显示源代码/反汇编和CPU寄存器窗口</p><p>5,  layout split：显示源代码和反汇编窗口</p><p>6,  Ctrl + L：刷新窗口</p><h1 id="GNU-make-的编写"><a href="#GNU-make-的编写" class="headerlink" title="GNU make 的编写"></a>GNU make 的编写</h1><p>把之前写的内容给删掉了,  换成chatGPT给我的答案会更容易理解一些</p><p>Makefile是一种用于自动化构建和编译软件的工具。以下是编写一个简单Makefile的步骤：</p><p>1,  决定需要编译的源文件和生成的目标文件。比如, 你可能有一个源文件main.c和一个库文件lib.c, 需要编译成目标文件main.o和lib.o。</p><p>2,  确定编译器和编译选项。比如, 你可能要使用GCC编译器, 并且需要加上-Wall和-O2选项。</p><p>3,  定义目标和依赖关系。例如, 你的目标可能是生成可执行文件app, 它依赖于main.o和lib.o。你可以在Makefile中使用规则来描述这些依赖关系：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">vbnetCopy <span class="selector-tag">code</span></span><br><span class="line">app: <span class="selector-tag">main</span><span class="selector-class">.o</span> lib<span class="selector-class">.o</span></span><br><span class="line">gcc -o app <span class="selector-tag">main</span><span class="selector-class">.o</span> lib.o</span><br></pre></td></tr></table></figure><p>4,  对于每个源文件, 定义其对应的编译规则。例如, 你可能需要为main.c和lib.c编写如下规则：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">lessCopy <span class="selector-tag">code</span></span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.o</span>: <span class="selector-tag">main</span><span class="selector-class">.c</span></span><br><span class="line">gcc -c <span class="selector-tag">main</span><span class="selector-class">.c</span></span><br><span class="line"></span><br><span class="line">lib<span class="selector-class">.o</span>: lib<span class="selector-class">.c</span></span><br><span class="line">gcc -c lib.c</span><br></pre></td></tr></table></figure><p>其中, -c选项表示编译成目标文件而不是可执行文件。</p><p>5, 最后, 你可以定义一些伪目标(.PHONY), 以便在命令行中执行。例如, 你可以定义一个名为clean的伪目标, 用于删除生成的目标文件：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">makefileCopy code</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o app</span><br></pre></td></tr></table></figure><p>完整的Makefile代码如下：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">makefileCopy <span class="selector-tag">code</span></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -O2</span><br><span class="line"></span><br><span class="line">app: <span class="selector-tag">main</span><span class="selector-class">.o</span> lib<span class="selector-class">.o</span></span><br><span class="line">$(CC) -o app <span class="selector-tag">main</span><span class="selector-class">.o</span> lib<span class="selector-class">.o</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.o</span>: <span class="selector-tag">main</span><span class="selector-class">.c</span></span><br><span class="line">$(CC) $(CFLAGS) -c <span class="selector-tag">main</span><span class="selector-class">.c</span></span><br><span class="line"></span><br><span class="line">lib<span class="selector-class">.o</span>: lib<span class="selector-class">.c</span></span><br><span class="line">$(CC) $(CFLAGS) -c lib<span class="selector-class">.c</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.PHONY</span>: clean</span><br><span class="line">clean:</span><br><span class="line">rm -f *<span class="selector-class">.o</span> app</span><br></pre></td></tr></table></figure><p>要执行Makefile, 请在命令行中切换到Makefile所在目录, 并运行make命令。它将自动构建和编译你的软件, 并根据需要更新目标文件。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tools </tag>
            
            <tag> dots </tag>
            
            <tag> GNU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 初探</title>
      <link href="/2019/09/04/archived_linux2019/"/>
      <url>/2019/09/04/archived_linux2019/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#远程ssh">远程ssh</a></li><li><a href="#说明">说明</a></li><li><a href="#shell-脚本编程">SHELL 脚本编程</a><ul><li><a href="#if-then-语句">if-then 语句</a></li></ul></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记得一开始入门Linux是因为在windows中安装ros太折腾了,虽然最终安装ok了(后来却没有去学习),但过程很不爽,一气之下就转战了ubuntu(2018年夏),真的时间不等人啊,使用这个系统,基本上就是工作在一个黑框下,配置着绿色的字体(嗯,原谅绿),  当然,为了简化日常操作,通过<a href="https://ohmyz.sh/">oh-my-zsh</a>配置了自己的zsh(说好的折腾呢？),下面是自己的插件,plugins=(git  zsh-autosuggestions wd extract z) ,就说一个extract吧,一个x基本就能解压所有压缩格式了,是不是。。。很方便？感兴趣的自己去搜搜吧,插件不要太多,就像vim一样,插件太多了,会适得其反。 当然值得一提的还是zsh-autosuggestions, 自知记性不太好,有的时候只是知道个模糊的开头,这个工具就可以大大的简化自己的日常操作,很是过瘾啊。 扯个题外话,git是非常值得拥有的工具,可以将自己的本地的文本<strong>免费</strong>的托管到github,即使换其他的电脑也不耽误事,很是方便。 也许多年之后返回来看一些东西,别有另一番的感觉呢？</p><p>另外值得推荐的工具就是<a href="https://github.com/soimort/you-get">you-get</a> 了, 要学习很多视频,很多视频是值得收藏与学习的,用you-get可以从命令行中下载自己想要的视频,是不是很过瘾呢,感兴趣的自己搜一下吧,如果想下载其他的alias这个工具也是不错的。 突然又想到了个事,文件的权限问题,有时不要乱给文件赋予高级权限(比如随手sudo chmod +777 给一个文件,早晚得吃亏),万一那个文件是间谍咋整。。。。。</p><p>偶尔会去调试别人发布在github中的python程序(好奇心的驱使),安装需要依赖的包的时候以及管理python环境时anconda是个非常不错的选择。主要是方便管理环境,貌似在Windows里面不只是要把bin文件目录添加到环境变量中,还有其他的东西要添加,比较折腾. 还有比如you-get这类工具是对python的环境是有依赖的,所以了解ananconda还是能节省些时间,总不想在配置环境的时候就耽误很多时间吧。 </p><h1 id="远程ssh"><a href="#远程ssh" class="headerlink" title="远程ssh"></a>远程ssh</h1><p>ssh用起来是非常方便的,下面搬运<a href="https://yangbingdong.com/2017/note-of-linux-command/">yangbingdong</a>博客里的内容。安装ssh</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install ssh</span><br><span class="line"><span class="built_in">sudo</span> apt install openssh-server</span><br></pre></td></tr></table></figure><p>查看启动成功: <code>ps -e|grep ssh</code>, 如果看到<code>sshd</code>那代表成功了, 如果没有, 执行:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span>/etc/init.d/ssh start</span><br></pre></td></tr></table></figure><p>ssh的配置文件位于<code>/etc/ssh/sshd_config</code>, 修改后需要重启ssh:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> /etc/init.d/ssh resart</span><br></pre></td></tr></table></figure><p>生成SSH密钥和公钥,在这里说明一点为什么要生成密钥和公钥(用自己的看法),如果经常远程操作一台电脑的话,每次都要输入密码,这个就比较费事,如果将这个公钥写入~/.ssh/authorized_keys中,就可以免密码登入了。生成SSH密钥和公钥可用如下指令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your_email@youremail.com&quot;</span></span><br></pre></td></tr></table></figure><p>默认的<code>RSA</code>长度是2048位, 如果非常注重安全, 那么可以指定4096位的长度,剩下的基本一路Enter.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -b 4096 -t rsa -C <span class="string">&quot;your_email@youremail.com&quot;</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>1, linux内核是操作系统的核心,分进程管理,储存管理,文件管理,设备管理和网络管理。进程管理:进程控制、进程同步、进程通信、死锁处理、处理机调度等。内存管理:内存分配、地址映射、内存保护与共享、虚拟内存等。 文件管理:文件存储空间的管理、目录管理、文件读写管理和保护等。设备管理:完成用户的 I/O 请求,方便用户使用各种设备,并提高设备的利用率。</p><p>2,  用 /  代替 cd / ；用 .. 代替 cd .. ；用 …. 代替 cd ../..；用 ~  代替 cd ~。复制ctrl shift c</p><p>3, 远程传输文件可以用scp指令,将文件/文件夹 从远程服务器拷至本地(,这里采用默认的端口,换端口用-P指令就行)</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">scp -r username<span class="variable">@192</span>.<span class="number">168.0</span>.<span class="number">1</span><span class="symbol">:/home/username/remotefile</span>.txt</span><br><span class="line">反之 scp -r  username<span class="variable">@192</span>.<span class="number">168.0</span>.<span class="number">1</span><span class="symbol">:/home/username/someFile</span> /home/username/someWhere。</span><br></pre></td></tr></table></figure><p>4, 找到重复文件并进行相关处理的工具rdfind,使用命令rdfind ∼/Downloads,结果存储到当前工作目录下一个名为 results.txt的文件中。可以在 results.txt 文件中看到可能是重复文件的名字。删除重复文件,就运行：  rdfind -deleteduplicates true ∼/Downloads。</p><p>5, tree 工具。它能够以一种美观的方式展示目录、子目录及其中的文件。如果需要了解目录结构,尤其是在删除目录之前,这款工具正好能派上用场(自己的系统中无,需要安装)。</p><p>6, 递归下载抓取整个网站内容wget -r -p -k -np <URL>。其中,<code>-p</code>: 下载所有用于显示 HTML 页面的图片之类的元素,-k<code>: 在转换文件 X 前先将它备份为</code>X.orig,<code>-np</code>: 不追溯至父目录。</p><p>7, df 和 du 这两个指令可以方便的查看磁盘或者是文件的的空间大小。</p><p>8,  ‘&gt;’会覆盖原有文件的内容,而’&gt;&gt;’会追加在文件的后面,比如添加一个新的路径,用了’&gt;’然后source ~/.zshrc后,等着哭吧.</p><p>9, 使用ctrl-r搜索命令历史记录,反复按ctrl-r循环切换更多匹配,按Enter键执行找到的命令。当然,如果安装了<span id = "inline-blue"> autosuggestions </span>这个插件,会自动显示出来,所以说是个非常推荐的zsh插件。</p><p>10, 使用ctrl-w删除最后一个单词；使用ctrl-u将当前光标中的内容删除回行的开头；ctrl -a将光标移动到行首；ctrl -e将光标移动到行尾；ctrl -k删除到行尾,ctrl -l 清除屏幕。</p><p>11, 返回到上一次的文件夹中可以使用cd -指令, 对于进程的树状形式可以使用指令pstree -p, 查看哪些用户在此电脑上一个w就O了,如果嫌一个指令太长,可以将那个指令通过alias简化,并输入到SHELL配置文件中(.bashrc,.zshrc)。</p><p>12, 超快的文件搜索工具<a href="https://github.com/ggreer/the_silver_searcher">Ag</a>,并在vim的配置文件中输入let g:ackprg = ‘ag —vimgrep’,　这样搜索片段的时候会快的很多。 </p><p>13, touch 创建多个文件比如 touch test_{1..100}.txt, 配合着seq命令使用,有很好的效果,比如 touch $(seq -f ‘vel%g.txt’ 1 10), 或者是中间加一个间隔touch $(seq -f ‘vel%g.txt’ 1 2 10),这个对于自己在做实物测试数据的时候起到了不少的帮助。</p><p>14, 常见的Linux顶层虚拟目录名及其内容</p><details><summary>展开</summary><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;table&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;tabular&#125; &#123;ll&#125;</span><br><span class="line">        <span class="keyword">\hline</span></span><br><span class="line">    目录<span class="built_in">&amp;</span>　　　　　用途                                                        <span class="keyword">\\</span>   <span class="keyword">\hline</span></span><br><span class="line">/       <span class="built_in">&amp;</span>    虚拟目录的根目录。通常不会在这里存储文件                          <span class="keyword">\\</span></span><br><span class="line">/bin    <span class="built_in">&amp;</span>    二进制目录,存放许多用户级的GNU工具                                <span class="keyword">\\</span></span><br><span class="line">/boot   <span class="built_in">&amp;</span>       启动目录,存放启动文件                                          <span class="keyword">\\</span></span><br><span class="line">/dev    <span class="built_in">&amp;</span>      设备目录,Linux在这里创建设备节点                                <span class="keyword">\\</span></span><br><span class="line">/etc    <span class="built_in">&amp;</span>     系统配置文件目录                                                 <span class="keyword">\\</span></span><br><span class="line">/home   <span class="built_in">&amp;</span>     主目录,Linux在这里创建用户目录                                   <span class="keyword">\\</span></span><br><span class="line">/lib    <span class="built_in">&amp;</span>    库目录,存放系统和应用程序的库文件                                 <span class="keyword">\\</span></span><br><span class="line">/media  <span class="built_in">&amp;</span>    媒体目录,可移动媒体设备的常用挂载点                               <span class="keyword">\\</span></span><br><span class="line">/mnt    <span class="built_in">&amp;</span>      挂载目录,另一个可移动媒体设备的常用挂载点                       <span class="keyword">\\</span></span><br><span class="line">/opt    <span class="built_in">&amp;</span>      可选目录,常用于存放第三方软件包和数据文件                       <span class="keyword">\\</span></span><br><span class="line">/proc   <span class="built_in">&amp;</span>      进程目录,存放现有硬件及当前进程的相关信息                       <span class="keyword">\\</span></span><br><span class="line">/root   <span class="built_in">&amp;</span>      root用户的主目录                                                <span class="keyword">\\</span></span><br><span class="line">/sbin   <span class="built_in">&amp;</span>   系统二进制目录,存放许多GNU管理员级工具                             <span class="keyword">\\</span></span><br><span class="line">/run    <span class="built_in">&amp;</span>     运行目录,存放系统运作时的运行时数据                              <span class="keyword">\\</span></span><br><span class="line">/srv    <span class="built_in">&amp;</span>  服务目录,存放本地服务的相关文件                                     <span class="keyword">\\</span></span><br><span class="line">/sys    <span class="built_in">&amp;</span>  系统目录,存放系统硬件信息的相关文件                                 <span class="keyword">\\</span></span><br><span class="line">/tmp    <span class="built_in">&amp;</span>  临时目录,可以在该目录中创建和删除临时工作文件                       <span class="keyword">\\</span></span><br><span class="line">/usr    <span class="built_in">&amp;</span>  用户二进制目录,大量用户级的GNU工具和数据文件都存储在这里            <span class="keyword">\\</span></span><br><span class="line">/var    <span class="built_in">&amp;</span>  可变目录,用以存放经常变化的文件,比如日志文件                        <span class="keyword">\\</span>  <span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;table&#125;</span><br></pre></td></tr></table></figure></details><p>这种分类,给自己编程带来了很多的便利,当然,写一两个函数时候当然无所谓,当函数比较多的时候,就有一点费劲了,将一些函数分类,比如专门存放输出数据的放在一起,方便后续编程来处理这些数据等等.</p><p>top 指令根据进程的属主(用户还是系统)和进程的状态(运行、空闲还是等待)将CPU利用率分成几类输出。显示的结果代表的意思：</p><details><summary>展开</summary><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line">    <span class="keyword">\item</span> PID:进程的ID。</span><br><span class="line">    <span class="keyword">\item</span> USER:进程属主的名字。</span><br><span class="line">    <span class="keyword">\item</span> PR:进程的优先级。</span><br><span class="line">    <span class="keyword">\item</span> NI:进程的谦让度值。</span><br><span class="line">    <span class="keyword">\item</span> VIRT:进程占用的虚拟内存总量。</span><br><span class="line">    <span class="keyword">\item</span> RES:进程占用的物理内存总量。</span><br><span class="line">    <span class="keyword">\item</span> SHR:进程和其他进程共享的内存总量。</span><br><span class="line">    <span class="keyword">\item</span> S:进程的状态(D代表可中断的休眠状态,R代表在运行状态,S代表休眠状态,T代表</span><br><span class="line">    <span class="keyword">\item</span> 踪状态或停止状态,Z代表僵化状态)</span><br><span class="line">    <span class="keyword">\item</span> <span class="keyword">\%</span>CPU:进程使用的CPU时间比例。                                               </span><br><span class="line">    <span class="keyword">\item</span> <span class="keyword">\%</span>MEM:进程使用的内存占可用内存的比例。</span><br><span class="line">    <span class="keyword">\item</span> TIME+:自进程启动到目前为止的CPU时间总量。</span><br><span class="line">    <span class="keyword">\item</span> COMMAND:进程所对应的命令行名称,也就是启动的程序名。</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br></pre></td></tr></table></figure></details><p>结束进程指令kill,kill 命令可通过进程ID(PID)给进程发信号。默认情况下, kill 命令会向命令行中列出的全部PID发送一个 TERM 信号。</p><details><summary>展开</summary><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\begin&#123;table&#125;</span></span><br><span class="line">    <span class="string">\begin&#123;tabular&#125;&#123;lll&#125;</span></span><br><span class="line">        <span class="string">\hline</span></span><br><span class="line">信号　&amp;　　　 名称       　　&amp;  　描述                               <span class="string">\\</span>  <span class="string">\hline</span></span><br><span class="line"><span class="number">1</span>     &amp;       HUP            &amp;    挂起                                <span class="string">\\</span></span><br><span class="line"><span class="number">2</span>     &amp;       INT            &amp;    中断                                <span class="string">\\</span></span><br><span class="line"><span class="number">3</span>     &amp;       QUIT           &amp;    结束运行                           <span class="string">\\</span></span><br><span class="line"><span class="number">9</span>     &amp;       KILL           &amp;    无条件终止                         <span class="string">\\</span></span><br><span class="line"><span class="number">11</span>    &amp;       SEGV           &amp;    段错误                             <span class="string">\\</span></span><br><span class="line"><span class="number">15</span>    &amp;       TERM           &amp;    尽可能终止                         <span class="string">\\</span></span><br><span class="line"><span class="number">17</span>    &amp;       STOP           &amp;    无条件停止运行,但不终止            <span class="string">\\</span></span><br><span class="line"><span class="number">18</span>    &amp;       TSTP           &amp;    停止或暂停,但继续在后台运行        <span class="string">\\</span></span><br><span class="line"><span class="number">19</span>    &amp;       CONT           &amp;    在 STOP 或 TSTP 之后恢复执行       <span class="string">\\</span>  <span class="string">\hline</span></span><br><span class="line">    <span class="string">\end&#123;tabular&#125;</span></span><br><span class="line">    <span class="string">\caption&#123;linux进程信号&#125;</span></span><br><span class="line"><span class="string">\end&#123;table&#125;</span></span><br></pre></td></tr></table></figure></details><p>当然使用kill的一种好的方法就是配合着 ps 与grep, 通过查找特定进程来将程序关闭。</p><p>一般在Linux中绘制流程图会使用<a href="plantuml.com">plantUML</a>, 当然 ,还是为了提高些效率 ,记不得之前在哪写过关于这方面的东西了, 先不管了, 如果嫌弃自带的分辨率太低的话, 可以使用如下方式更改其分辨率的大小, 比如</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scale</span> <span class="attribute">x</span>*<span class="attribute">y</span></span><br></pre></td></tr></table></figure><p>入手了MBP后,仍旧想使用自己的老年机(没错,快上大学的时候买的), 于是就想办法怎么去格式化启动盘,下面给出一种方式,在命令行下复制如下代码( 使用diskutil后发现自己的启动盘名称为disk2,其中U盘分了两个区,要不也不会有这段内容了, disk2前面就是格式化完成后的名字了), 话说这个还走了不少弯路。。。。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo gpt <span class="built_in">remove</span> -i 1 disk2</span><br></pre></td></tr></table></figure><p>这样的话,就可以把EFI分区给合并了。 然后再对其格式化后,输入如下的指令</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo dd <span class="attribute">if</span>=/Users/lsqyRobot/Downloads/archlinux-2020.01.01-x86_64.iso <span class="attribute">of</span>=/dev/disk2 <span class="attribute">bs</span>=1m</span><br></pre></td></tr></table></figure><p>其中 if 后面跟的是文件的下载路径,后面的就是挂载的u盘了,bs代表着写入的时间。 至于为什么这样做,肯定是有原因的,这个就是为老年机安装了linux mint后,又突发奇想,用了那么久的linux mint 自然想换换口味,就选择arch linux吧,至于分区挂载什么的,之前安装破解一些软件的时候就很熟了,所以想必对自己也不是什么难事。</p><h1 id="SHELL-脚本编程"><a href="#SHELL-脚本编程" class="headerlink" title="SHELL 脚本编程"></a>SHELL 脚本编程</h1><p>许多程序要求对shell脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为结构化命令(structured command)。 </p><h2 id="if-then-语句"><a href="#if-then-语句" class="headerlink" title="if-then 语句"></a>if-then 语句</h2><p>最基本的结构化命令就是if-then语句。if-then语句有如下格式。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if command </span><br><span class="line">then</span><br><span class="line">commands </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码(参见第11章)是0 (该命令成功运行),位于then部分的命令就会被执行。如果该命令的退出状态码是其他值, then 部分的命令就不会被执行,bash shell会继续执行脚本中的下一个命令。fi语句用来表示if-then 语句到此结束。</p><p>鉴于shell脚本不是一两句话就能写完的, 以后专门用一篇或几篇文章记录一下一些shell脚本的编写和使用；</p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tools </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex 学习笔记(一)</title>
      <link href="/2019/09/03/archived_latex_2019/"/>
      <url>/2019/09/03/archived_latex_2019/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc Marked --><ul><li><a href="#前言">前言</a></li><li><a href="#知识点">知识点</a></li><li><a href="#遇到的困难">遇到的困难</a><ul><li><a href="#自定义页眉与页脚">自定义页眉与页脚</a></li><li><a href="#指定页眉内容">指定页眉内容</a></li><li><a href="#给封面加图片">给封面加图片</a></li></ul></li><li><a href="#表格">表格</a><ul><li><a href="#简单表格">简单表格</a></li><li><a href="#宽度控制">宽度控制</a></li><li><a href="#跨行跨列">跨行跨列</a></li><li><a href="#彩色表格">彩色表格</a></li></ul></li><li><a href="#计数器">计数器</a></li><li><a href="#文档分类处理">文档分类处理</a></li><li><a href="#小技巧">小技巧</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果不想折腾,可以去网站下载相关书籍的模板比如: <a href="https://www.latextemplates.com/cat/books">latex template</a>,<a href="https://www.overleaf.com/gallery/tagged/book">overleaf</a>, 实践是学习这个工具的最好方法。 这主要是方便自己以后看的,所以也没有好好的整理,等到积累到一定程度的时候,再好好的整理一下。 现在纠结一个问题,要不要好好学习下tikz的,学习好了自然对于美化样式有极大的帮助,但是似乎又偏离了自己的初衷—尽量的节省时间。这篇文章会记录一些自己认为有用的相关知识,便于查阅,所以对新手来说是相当的不友好。。。。。不过网络上的教程那么多,自己感觉也没什么必要另写一份教程了,最好的学习方式,就是去用。</p><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>1,利用 \hfill 容易使单行文本左对齐、右对齐或居中对齐。</p><p>2,\dotfill,\hrulefill 分别用点线和实线填充空白。</p><p>3,段落首行缩进的距离由长度\parindent决定,对于中文, 命令 \setlength{\parindent}{2em}可使每段首行缩进两个汉字的距离, 若使首行不缩进,可在开始放上命令 \noindent. 但是每一节的第一段的首行并不会缩进,可在第一段的开始放上命令 \usepackage{indentfirst}即可</p><p>4,按照输入的文本原样输出, 可以使用verbatim环境.</p><p>5,\input 命令可以把整体划分为各个单元,这样在写比较长的的文章,比如毕业论文的时候就非常的有用了,而且结构清晰,方便自己理清写作思路,也方便自己将一些收集出来的资料进行分类,所以还是挺有用处的。 </p><p>6,\let指令的作用相当于给现有的指令起一个别名以避免的死循环, 可以用在一个单元或章节重新计数用。</p><p>7,LaTex内部有一批计数器,储存当前的章节号,它们的名称就是相应的章节,如果想改变章节计数器的初始值,可用如下形式的命令</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\setcounter</span><span class="template-variable">&#123;章节计数器的名称&#125;</span><span class="template-variable">&#123;数&#125;</span></span><br></pre></td></tr></table></figure><p>这个命令应放在章节命令之前,新的章节的序号值是这个初始值加 1</p><p>8, 有的时候将图片放在一个文件夹中显得有一些混乱,可以使用如下指令将图片放在名字为figure的文件夹下(windows的目录斜杆正好是反着来的)。</p><figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\graphicspath</span><span class="template-variable">&#123;&#123;<span class="name">./figure</span>/&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>9, 如果感觉目录显示的太少,想将一些目录的深度和编号都加一级,实现的方式就是在导言前加入如下命令</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\setcounter</span><span class="template-variable">&#123;seecnumdepth&#125;</span><span class="template-variable">&#123;4&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\setcounter</span><span class="template-variable">&#123;tocdepth&#125;</span><span class="template-variable">&#123;4&#125;</span></span><br></pre></td></tr></table></figure><p>10,如果可以,尽量选择安装texlive而不是miktex作为LaTex的包管理器,虽然texlive比miktex要大的多的多,不过总不想因为安装包的缘故,而导致心情的不畅吧,另外想说的是,尽管texlive里面的包已经非常非常多了,可有的时候还是不能够满足我们的需求,这个时候还是得安装一些在texlive中没有安装的那些包,可以通过借助texlive的包管理工具 tlmgr 来安装一些没有的包,具体的使用如下</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">tlmgr <span class="keyword">install</span> somePackage</span><br></pre></td></tr></table></figure><p>注意而不是 somePackage.sty</p><p>11, hyperref 宏包提供了一些超链接功能。给文档内部的交叉引用和参考文献自动加上了超链接。</p><h1 id="遇到的困难"><a href="#遇到的困难" class="headerlink" title="遇到的困难"></a>遇到的困难</h1><p>在定义页眉页脚时遇到了些困难,并记录一些笔记。在一个页面上排放文本的区域分成 4 部分：页眉(Header)、页芯(Body)、页脚(footer)和边注(Margin Notes)2, 在它们的外部是页边空白区域,各部分的尺寸以及相互之间的距离参见下一页的图形。该图形显示的是在 A4 纸上排版 article 类文章时的页面布局,对于 book 类或 report 类的页面,除了各部分的尺寸与 article 类有所不同外,边注区的位置还与奇偶页码有关,使得装订成书后边注总是在外侧控制页面版式的命令通常放在导言区,命令格式为 </p> <figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\pagestyle</span><span class="template-variable">&#123;板式&#125;</span></span><br></pre></td></tr></table></figure><p>其中版式有如下几种(默认下的)</p><p>1, plain 这是默认的页面版式,即当导言区没有\pagestyle时,相当于在导言区放上了命令\pagestyle{plain｝。排版输出时页面的页眉区是空的,页码居中放在页脚区。</p><p>2, empty 页面的页眉和页脚都是空的,并且不显示页码。</p><p>3, headings 页眉由页码和页眉标题组成,对于 book 类和 report 类,页眉标题含有章和节的标题,对于 article 类,只有节标题,这些标题是从当前页自动提取的,但每一章的第一页不显示页眉</p><p>4, 页码的编号可以用阿拉伯数字、罗马数字或拉丁字母,指定页码样式的命令是</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\pagenumbering</span><span class="template-variable">&#123;数字形式&#125;</span></span><br></pre></td></tr></table></figure><p>系统内部有一个页码计数器,记录当前页的页码。每生成一页,计数器就自动加 1, 这个新值就是新页的页码。如果想使起始页码不从 1 开始,或者使当前页从新的值开始计数,可使用如下命令重置计数器的值：</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\frontmatter</span></span><br></pre></td></tr></table></figure><p>把页码切换成罗马数字格式,并且不再对章进行自动编号,这个命令通常放在前言和目录前面。命令</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\mainmatter</span></span><br></pre></td></tr></table></figure><p>把页码切换成阿拉伯数字,并对章进行自动编号,这个命令通常放在正文主体前面命令</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\backmatter</span></span><br></pre></td></tr></table></figure><p>通常放在参考文献和索引前面,它不再对章进行自动编号,但不改变页码数字格式,不重设页码计数器。</p><h2 id="自定义页眉与页脚"><a href="#自定义页眉与页脚" class="headerlink" title="自定义页眉与页脚"></a>自定义页眉与页脚</h2><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\usepackage</span><span class="template-variable">&#123;fancyhdr&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\pagestyle</span><span class="template-variable">&#123;fancy&#125;</span></span><br></pre></td></tr></table></figure><p>这个宏包把页面分为奇数页(Odd page)和偶数页(Even page)。把页眉和页脚都分成三个区域,分别称为左区(Left field)、中区(Center field)和右区(Right field),这三个区域之间没有分界线,放在左区的内容对齐在页眉(脚)的左边界,放在右区的内容对齐在页眉(脚)的右边界,中区的内容则在页眉(脚)的整个区域里居中放置,各区中的内容不可过长,以避免发生重叠现象。 设置页眉(header)和页脚(footer)的命令分别是</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\fancyhead</span></span><br><span class="line"><span class="string">\fancyfoot</span></span><br></pre></td></tr></table></figure><p>命令</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\headrulewidth</span></span><br><span class="line"><span class="string">\footrulewidth</span></span><br></pre></td></tr></table></figure><p>分别表示页眉和页脚与正文之间装饰性分隔线的粗细,默认值分别是 0.4pt 和0pt 改变其值需要使用\renewcommand。命令而不是\setlength 命令。在单独成页的 chapter 这一页。会自动应用 plain 风格。因此如果希望改变章首页的样式,则应该定义 plain 样式(这句话是重点,如果发现改动不了单独成页的那栏,可以好好考虑这一句话。</p><h2 id="指定页眉内容"><a href="#指定页眉内容" class="headerlink" title="指定页眉内容"></a>指定页眉内容</h2><p>对于页面版式myheadings,可用下面的命令来指定页眉标题内容：</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\markright</span><span class="template-variable">&#123;rightMark&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\markboth</span><span class="template-variable">&#123;leftMark&#125;</span><span class="template-variable">&#123;rightMark&#125;</span></span><br></pre></td></tr></table></figure><h2 id="给封面加图片"><a href="#给封面加图片" class="headerlink" title="给封面加图片"></a>给封面加图片</h2><p>具体的图片大小格式,就自己调整吧。。。。首先在\begin{document}前写下</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\usepackage&#123;eso-pic&#125;</span></span><br><span class="line"><span class="string">\newcommand\BackgroundPic&#123;</span></span><br><span class="line"><span class="string">\put(0,</span> <span class="number">0</span>)&#123;</span><br><span class="line"><span class="string">\parbox[t]&#123;\textwidth&#125;&#123;</span></span><br><span class="line"><span class="string">\includegraphics[scale=1,keepaspectratio]&#123;Logo.jpg&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想给图片加一点文字,可以这么操作</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\usepackage&#123;overpic&#125;</span>  %% 用于给图片添加文字的</span><br><span class="line"><span class="string">\usepackage&#123;eso-pic&#125;</span>  %% 用于给封面添加图片的</span><br><span class="line"><span class="string">\newcommand\BackgroundPic&#123;</span></span><br><span class="line"><span class="string">\put(0,</span> <span class="number">0</span>)&#123;</span><br><span class="line"><span class="string">\parbox[t]&#123;\textwidth&#125;&#123;</span></span><br><span class="line"><span class="string">\begin&#123;overpic&#125;[scale=1,</span> keepaspectratio]&#123;Logo.jpg&#125;</span><br><span class="line">    <span class="string">\put(60,5)&#123;</span> <span class="string">\color&#123;orange&#125;&#123;\bf</span> yorQuote&#125;&#125;</span><br><span class="line"><span class="string">\end&#123;overpic&#125;</span></span><br><span class="line">%<span class="string">\includegraphics[scale=1,keepaspectratio]&#123;eftLogo.jpg&#125;%</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：这里面的\put是起摆放位置的作用 然后在\begin{document}后写上</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\AddToShipoutPicture\*</span><span class="template-variable">&#123;\setlength&#123;\unitlength&#125;</span><span class="template-variable">&#123;1cm&#125;</span><span class="language-xml">\BackgroundPic&#125;</span></span><br></pre></td></tr></table></figure><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>LaTex的表格写起来还是有些费劲的,个人一般先去<a href="https://www.tablesgenerator.com/">https://www.tablesgenerator.com/</a>自动生成表格,然后再手动调整下,要不就太费时了。下面就详细的说明下表格的语法,对照着网站,自然就一目了然,不需要举例。内容摘选了包太雷的《LaTex Notes》,也是早期接触到LaTex看的书了。</p><h2 id="简单表格"><a href="#简单表格" class="headerlink" title="简单表格"></a>简单表格</h2><p>tabular环境提供了最简单的表格功能。它用\hline 命令表示横线,|表示竖线；用 &amp; 来分列,用 \ 来换行；每列可以采用居中、居左、居右等 横向对齐方式,分别用 l、c、r 来表示。不过\hline的线条都是一样粗的,可以使用 \toprule、\midrule 、\bottomrule 指令改善这一情况。tabular 环境中的行可以采用居顶、居中、居底等纵向对齐方式,分别用 t、c、b 来表示,缺省的是居中对齐。列之间的分隔符也可以改用其他符 号,比如用 || 来画双竖线。</p><h2 id="宽度控制"><a href="#宽度控制" class="headerlink" title="宽度控制"></a>宽度控制</h2><p>有时我们需要控制某列的宽度,可以将其对齐方式参数从 l、c、r 改为p{宽度}。这时纵向对齐方式是居顶,t、c、b 等参数失效。使用宽度控制参数之后,表格内容缺省居左对齐。可以用列前置命令 &gt;{} 配合 \centering、\raggedleft 命令来把横向对齐方式改成居中或 居右。列前置命令仅对紧邻其后的一列有效,其语法为：：>{命令}列参数</p><h2 id="跨行跨列"><a href="#跨行跨列" class="headerlink" title="跨行跨列"></a>跨行跨列</h2><p>有时表格某单元格需要横跨几列,我们可以使用 \multicolumn 命令,同时使用 booktabs 宏包的 \cmidrule 命令来画横跨几列的横线。语法如下：</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\multicolumn</span><span class="template-variable">&#123;横跨列数&#125;</span><span class="template-variable">&#123;对齐方式&#125;</span><span class="template-variable">&#123;内容&#125;</span><span class="language-xml"> </span></span><br><span class="line"><span class="language-xml">\cmidrule</span><span class="template-variable">&#123;起始列-结束列&#125;</span></span><br></pre></td></tr></table></figure><p>跨行表格可以使用 multirow 宏包的 \multirow 命令,其语法如下,</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\multirow</span><span class="template-variable">&#123;竖跨行数&#125;</span><span class="template-variable">&#123;宽度&#125;</span><span class="template-variable">&#123;内容&#125;</span></span><br></pre></td></tr></table></figure><h2 id="彩色表格"><a href="#彩色表格" class="headerlink" title="彩色表格"></a>彩色表格</h2><p>若想给表格增加点色彩,可以使用 Carlisle 的 colortbl 宏包。它提供<br>的 \columncolor、\rowcolor、\cellcolor 命令可以分别设置列、行、单 元格的颜色。这三个命令的基本语法相似：</p><p>columncolor 需要放到列前置命令里,rowcolor、cellcolor 分别放到行、单元格之前。colortbl 宏包可以使用 xcolor 宏包的色彩模型；两 者同时,前者不能直接加载,需要通过后者的选项 table 来加载。三个命令 同时使用时,它们的优先顺序为：单元格、行、列。。xcolor 宏包的 rowcolors 命令 (需要 colortbl 宏包的支持) 可以 分别设置奇偶行的颜色,语法如下：</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="template-variable">&#123;beginRow&#125;</span><span class="template-variable">&#123;oddRowColor&#125;</span><span class="template-variable">&#123;evenRowColor&#125;</span><span class="language-xml"> </span></span><br></pre></td></tr></table></figure><h1 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h1><p>含有计数器的比如有</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">part <span class="keyword">subsection </span><span class="keyword">subparagraph </span>footnote chapter </span><br><span class="line"><span class="keyword">subsubsection </span>page section paragraph equation</span><br></pre></td></tr></table></figure><p>如果我们需要改变计数器的值,可以用如下指令</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\seccounter</span><span class="template-variable">&#123;name&#125;</span><span class="template-variable">&#123;number&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\addtocounter</span><span class="template-variable">&#123;name&#125;</span><span class="template-variable">&#123;number&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\stepcounter</span><span class="template-variable">&#123;name&#125;</span></span><br></pre></td></tr></table></figure><p>这里的名字没有转义,其中\seccounter是给计数器赋值,\addtocounter是把指定的值加到计数器上,\stepcounter则把指定计数器值加1,同时使下属计数器的值置0,例如执行\setpcounter{section}后,section计数器的值增加1,同时它下面的计数器subsection, paragraph等都被置零。 可以自定义一些新的计数器,命令为</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">\newcounter&#123;newName&#125;<span class="selector-attr">[counterName]</span></span><br></pre></td></tr></table></figure><h1 id="文档分类处理"><a href="#文档分类处理" class="headerlink" title="文档分类处理"></a>文档分类处理</h1><p>对于短文章,单独处理是比较容易的,但是对于写一本书而言,放在一个文件里就会显得结构不是那么清晰,而且处理起来也很慢。可以分成几个文件来分别处理,最后再结合起来。 \input{fileName}可以把名未fileName的文件内容读取到当前文档中,默认的拓展名是tex.这里有一点不好的就是当在一个文件中修改了一点,但是所有的文件都需要被重新的编译,这个时候使用\include{fileName}就可以只重新处理被修改的那个文件。</p><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><p>1,\usepackage不能在\documentclass之前使用,而\RequirePackage可以。</p><p>2,\NeedsTeXFormat告诉编译器这个宏包是属于LaTeX的哪个版本的。</p><p>3,\ProvidesClass提供宏包的一些信息。第一个参数为自定义的cls文件,第二个参数是可选的,这个将出现在日志或者其他地方。</p><p>4,边注可以使用\marginpar 命令。单面排版时, 边注缺省排在页面右边空白处;双面排版时,边注在外侧,也就是左页的左边或右页的右边;双栏页面的边注排在最近的页边。如要切换边注的方向,可以使用\reversemarginpar 和 \normalmarginpar 命令。</p><p>5,对于大段注释,可以是使用verbatim 宏包的comment 环境。</p><p>6,设置文字的颜色可以使用 \textcolor 命令 语法: \textcolor{名称}|[模式]{代码}{文字}。</p><p>7,可以用 \pagestyle 和 \thispagestyle 命令来设置整个文档或单独某页的样式。</p><p>8,保持文本的原样输出,可以使用verbatim指令。对于不超过一行的文本,可以简化成\verb|文本|。</p><p>9,在页边上的注释可用命令\marginpar命令生成</p><p>10,主控文档中引用子文档可以用\include命令。注意 \include 命令会新起一页,如果不想要新页可以改用 \input 命令。</p><p>11,表格某列的宽度,可以将其对齐方式参数从 l、c、r 改为p{宽度}。这时纵向对齐方式是居顶,t、c、b 等参数失效。</p><p>12,latex设置页面边距,比如　\geometry{a4paper,left=2cm,right=2cm,top=1cm,bottom=1cm}</p><p>13,行距的设置：使用最多的是setspace宏包,举一个例子：设置行间距为22pt,就可以这样设置 \usepackage{setspace}</p><p>自定义命令\newcommand格式：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\newcommand</span>&#123;新命令&#125;[参数数量][默认值]&#123;定义内容&#125;</span><br></pre></td></tr></table></figure><p>使用这个命令遇到过一次问题,就是当定义内容里含有lstlisting时候会报错,错误如下! Missing \endcsname inserted.<to be read again> ,目测是和其他的包冲突了,所以导致折腾了好一会都没解决掉。 利用宏包 geometry设置上、下、左、右的页边距以及标题和正文之间的间距(梅木秀雄)</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[paperwidth =100mm,paperheight=150mm,margin=20mm]&#123;geometry&#125;</span><br></pre></td></tr></table></figure><p>显示目录：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\tableofcontents</span></span><br></pre></td></tr></table></figure><p>另外说明下,这个命令放在哪里,目录就会出现在哪里。和交叉引用相同的一个特点就是需要编译两次。类似地,可以使用 \listoffigures 和 \listoftables 命令来生图目录和表目录。 在文章中间位置修改链接格式(颜色)：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hypersetup</span>&#123;linkcolor=red&#125;</span><br></pre></td></tr></table></figure><p>部分Latex命令简介</p><table id="ver-zebra" summary="Most Favorite Movies">                                         <colgroup>                                                                                <col class="vzebra-odd" />                                                            <col class="vzebra-even" />                                                           <col class="vzebra-odd" />                                                            <col class="vzebra-even" />                                                           </colgroup>                                                                               <tbody>                                                                                   <tr>                                                                                  <td>\" </td>                                                          <td> 产生重音号 </td>                                                            </tr>                                                                                 <tr>                                                                                  <td> # </td>                                                           <td> 在用户自定义命令或环境时被用作变量替换符 </td>                                                                </tr>                                                                                 <tr>                                                                                  <td> \|            </td>                                                              <td> 产生　|| </td>                                                                     </tr>                                                                                 <tr>                                                                                  <td> ~ </td>                                                         <td> 产生单词间的正常空格,但是禁止在这里换行 </td>                                                                </tr>                                                                                 </tbody>                                                                                  </table>                                                                                     <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] 《LaTex 入门与提高》 陈志杰等</p>]]></content>
      
      
      <categories>
          
          <category> LATEX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启程</title>
      <link href="/2019/09/01/archived_goTheSociety/"/>
      <url>/2019/09/01/archived_goTheSociety/</url>
      
        <content type="html"><![CDATA[<h1 id="旅程"><a href="#旅程" class="headerlink" title="旅程"></a>旅程</h1><p>即将进入社会,自然内心五味杂陈,有害怕,有恐惧,有期待。也许是吧,真正的失去才知道拥有的好,得到什么,注定会失去其他的。悲剧发生的其中一点,可能就是患得患失吧。加油哇,未来的路那么长,挫折难免,磕磕碰碰,总会达到期待彼岸望见闪烁着的绿光！</p><p>害怕告别校园,心里非常的清楚,这一去,就永远都回不来了。蓦然回首那时会带着些许忧伤,思念像江水那样长,怎么忘？恐惧着从未接触过的生活,在社会的大染缸中,如何独善其身,会不会变成当初自己最讨厌的样子,一日日的重复着,也许不知觉,只是为活着而活,不是为生活而活。期待的是可以尝试,尝试着去生活,去接触从未接触过的一切,有更多的时间去发展兴趣,希望变成自己想要成为的人。</p><p>希望可以一直记录下去,希望可以痛快的在这个世界咳嗽几声。靡不有初鲜克有终,坚持始终是最困难的事。无论是生活还是学习,总会遇到许许多多的困惑与不解,这些希望在未来的岁月中给予我答案。在岁月的长河中,已经发生了许多的事,教会了自己一些做人的方法,也许是对原来自己的一种妥协,对错与否,已经做出了决定,为自己的抉择负责。</p><p>年轻的时候是不是会有非常多的期待？是不是因为有了许多的幻想,便有了很多的追求？在追求中消磨着时光,在挫折与痛苦中成长,再无所谓的感慨,一切都是人生必经之事。相信自己能从事自己热爱的方向,做一个有价值的人！</p><p>关于爱情,认为这是个可遇而不可求的事,建立在信任的基础之上且彼此相互欣赏,那样走的才会长远一些,有舍才有得,因果相连。 该怎样才能让自己不悲伤呢？唯有努力吧。有些事,回头看都是注定了的,过很长一段时间再去想,也许是自己做出的最好的选择。现在看来,过去得到不到的,都是在为现在最好的铺路。</p><p>好好的去记录,思考,感受与探索。未来如果可知,岂不是少了些许乐趣？ </p><p>在生日的那天,听到了温柔的歌声,这份感动足以慰余生。这个话题,就结束于此吧。</p>]]></content>
      
      
      <categories>
          
          <category> LIFE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> dots </tag>
            
            <tag> memory </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim 学习笔记(一)</title>
      <link href="/2019/04/27/archived_vim2019/"/>
      <url>/2019/04/27/archived_vim2019/</url>
      
        <content type="html"><![CDATA[<!-- vim-markdown-toc GFM --><ul><li><a href="#前言">前言</a></li><li><a href="#定制vim">定制VIM</a><ul><li><a href="#更改字体">更改字体</a></li><li><a href="#修改配色方案">修改配色方案</a><ul><li><a href="#用彩色标记某列后面的文字">用彩色标记某列后面的文字</a></li></ul></li><li><a href="#补全方式">补全方式</a></li><li><a href="#加密文件">加密文件</a></li><li><a href="#搜索文件夹中含有的特定代码">搜索文件夹中含有的特定代码</a></li></ul></li><li><a href="#编写库脚本">编写库脚本</a></li><li><a href="#用寄存器实现删除复制与粘贴操作">用寄存器实现删除,复制与粘贴操作</a></li><li><a href="#搜集的技巧">搜集的技巧</a></li><li><a href="#参考">参考</a></li></ul><!-- vim-markdown-toc --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>花时间找易用的工具,不如花时间掌握强大的工具. 收集了一些自己经常使用的一些指令, 这个工具强大之处在于尽可能的按照想法去实现． 不一定是程序员才用VIM, 如此高效的工具是值得去学的. 笔记很多来自于《VIM中文手册》《Practical Vim》《VIM 7.2》。 里面摘抄部分自己经常查阅的内容, 以便于日后翻阅, 也希望能够给那些想入坑的提供些参考. 想想那时是18年开始使用的这个工具, 不觉感慨时间飞逝, 现在还不断的学习相关的知识, 发现很多神奇的操作。</p><p>如果仅仅是为了能够实现一些其他IDE的功能进而安装大量的插件, 而忽略了VIM本身, 那还是直接用其他IDE吧。现成的工具也是极其优秀的。 有的时候自己在怀疑自己,学这个有什么用….可能就是喜欢单纯的折腾吧, 毋庸置疑的是, 这个工具确实可以帮到自己提升效率, 就像屠龙刀一样, 自己并不排斥其他的编辑器, 比如vscode, 但是绝大多数的时间, 还是以vim作为自己的主力。 这个视频<a href="https://www.youtube.com/watch?v=wlR5gYd6um0">Mastering the Vim Language</a>里可以学到很多东西。</p><h1 id="定制VIM"><a href="#定制VIM" class="headerlink" title="定制VIM"></a>定制VIM</h1><h2 id="更改字体"><a href="#更改字体" class="headerlink" title="更改字体"></a>更改字体</h2><p>这个是自己在工作中遇到的问题,由于公司配的电脑使用的windows系统,在公司工作的时候用的编辑器就是GVim了,但是默认的GVIM的字体是挺小的,看起来挺吃力的。下面说明下如何更改字体。在LINUX和windows上还是有些区别。其主要的指令还是guifont</p><p>在 Linux 中,</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="attribute">guifont</span>=yourFont\ 18 </span><br></pre></td></tr></table></figure><p>可以把 yourFont替换成你喜欢的任意一种字体的名字,字体大小根据自己的需求更改。在Windows：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="attribute">guifont</span>=yourFont:h18 </span><br></pre></td></tr></table></figure><h2 id="修改配色方案"><a href="#修改配色方案" class="headerlink" title="修改配色方案"></a>修改配色方案</h2><p>在默认情况下,Vim 的窗口颜色与打开它的控制台相同不仅难看,而且还很苍白。。。。为了把配色方案修改成某个系统中已有的方案,只需要执行</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">colorscheme mycolors</span></span><br></pre></td></tr></table></figure><p>在这个命令中,mycolors 是系统中已安装的某个配色方案的名字,自己选择的是经典的molokai主题。</p><p><img src="/img/postImg/42_vim/my_colorScheme.png" width="70%" height="50%"></p><p>除了前景色与背景色,配色方案还会影响代码高亮,错误标记,以及文件中的其他可视化标记。根据自己的需求,去选择适合自己的主题,要不就自己配。。。。</p><h3 id="用彩色标记某列后面的文字"><a href="#用彩色标记某列后面的文字" class="headerlink" title="用彩色标记某列后面的文字"></a>用彩色标记某列后面的文字</h3><p>第一次见到这种做法的时候,是在油管的一个vim讲座里出现的,正巧在《vim 7.2》这本书看到了,举得例子都很棒,就全抄下来吧。。。。</p><p>当你在一行内写出的字符数超过某个上限时,只需要下面这个命令就可以给出提示</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">match</span> ErrorMsg /\%&gt;<span class="number">73</span>v.\+/</span><br></pre></td></tr></table></figure><p>执行该命令后,一行内的第 73 个字符之后的那些字符都会被标记成错误. 匹配命令中含有一个正则表达式, 这个表达式可以拆成:</p><div class="table-container"><table><thead><tr><th>命令                    &emsp;</th><th>内容</th></tr></thead><tbody><tr><td>\%&gt; 匹配该列之后的内容, &emsp;</td><td>匹配该列之后的内容, 列号紧跟在尖括号的右边</td></tr><tr><td>73                      &emsp;</td><td>列号</td></tr><tr><td>v                       &emsp;</td><td>只能工作在可见的列上面</td></tr><tr><td>.+                     &emsp;</td><td>匹配一个或多个任意的字符</td></tr></tbody></table></div><h2 id="补全方式"><a href="#补全方式" class="headerlink" title="补全方式"></a>补全方式</h2><p>vim 的补全命令比较多,建议使用一些插件,比如ycm</p><details><summary>展开</summary><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">ctrl+x +l       整行补全</span><br><span class="line">ctrl+x +n根据当前文件里关键字补全</span><br><span class="line">ctrl+x +k根据字典补全  实现创建好字典(或下载):<span class="keyword">set</span> dictionary+=/path/to/dictionary/file/with/words</span><br><span class="line">ctrl+x <span class="comment">+t</span>根据同义词字典补全</span><br><span class="line">ctrl+x <span class="comment">+i</span>根据头文件内关键字补全</span><br><span class="line">ctrl+x <span class="comment">+]</span>根据标签补全</span><br><span class="line">ctrl+x <span class="comment">+f</span>补全文件名</span><br><span class="line">ctrl+x <span class="comment">+d</span>补全宏定义</span><br><span class="line">ctrl+x <span class="comment">+v</span>补全<span class="comment">vim</span>命令</span><br><span class="line">ctrl+x <span class="comment">+u</span>用户自定义补全方式</span><br><span class="line">ctrl+x <span class="comment">+s</span>拼写建议</span><br><span class="line">ctrl+n|p   代码内基本补全</span><br></pre></td></tr></table></figure></details><p>组合键ctrl+n所做的工作是向前搜索匹配的单词. 如果用户知道自己刚刚才输入过同样的单词, 那么用ctrl+p会更快一点, 因为这个组合键是向后搜索匹配. 一般来说, 除非文件非常大, 或者可能的匹配非常多, 否则ctrl+n与ctrl+p对用户来说并没有太大的区别.  对于补全的插件也很多,自己用的是ycm(编译这个得看自己的环境了MBP编译了N次都是提示个莫名奇妙的错误,用macMINI一次就好了),使用起来感觉还行。</p><h2 id="加密文件"><a href="#加密文件" class="headerlink" title="加密文件"></a>加密文件</h2><p>加密文件的方式是当使用vim打或新建,加上-x参数使用以下命令,可以查看当前使用的加密算法:set cm?使用以下命令,可以切换使用的不同加密算法：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> <span class="attribute">cm</span>=zip</span><br><span class="line">:<span class="built_in">set</span> <span class="attribute">cm</span>=blowfish</span><br><span class="line">:<span class="built_in">set</span> <span class="attribute">cm</span>=blowfish2</span><br></pre></td></tr></table></figure><br>使用以下命令将选项key置空,解除加密:set key=</p><h2 id="搜索文件夹中含有的特定代码"><a href="#搜索文件夹中含有的特定代码" class="headerlink" title="搜索文件夹中含有的特定代码"></a>搜索文件夹中含有的特定代码</h2><p>使用vimgrep可以搜索文件夹下的文件含有特定文字/代码,方式如下</p><details><summary>展开</summary><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">vimgrep <span class="regexp">/匹配模式/</span>[g][j] 要搜索的文件/范围 </span><br><span class="line">g：表示是否把每一行的多个匹配结果都加入</span><br><span class="line">j：表示是否搜索完后定位到第一个匹配位置</span><br><span class="line">vimgrep <span class="regexp">/pattern/</span> %           在当前打开文件中查找</span><br><span class="line">vimgrep <span class="regexp">/pattern/</span> <span class="string">\*</span>             在当前目录下查找所有</span><br><span class="line">vimgrep <span class="regexp">/pattern/</span> <span class="string">\*\*</span>            在当前目录及子目录下查找所有(目前这个自己用的比较多)</span><br><span class="line">vimgrep <span class="regexp">/pattern/</span> <span class="string">\*.c</span>          查找当前目录下所有.c文件</span><br><span class="line">vimgrep <span class="regexp">/pattern/</span> <span class="string">\*\*/\*</span>         只查找子目录</span><br></pre></td></tr></table></figure></details><h1 id="编写库脚本"><a href="#编写库脚本" class="headerlink" title="编写库脚本"></a>编写库脚本</h1><p>有些功能会在多个地方调用。如果这已经不是一两行的代码,你可能会希望把这些代码放进脚本,然后被许多其它脚本使用。我们把这种脚本称为库脚本。 可以手动载入库脚本,只要你不要重复调用它就行了。用 |exists()| 函数可以判断。</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !exists(<span class="string">&#x27;*MyLibFunction&#x27;</span>)</span><br><span class="line"><span class="keyword">runtime</span> library/mylibscript.<span class="keyword">vim</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">call</span> MyLibFunction(arg)</span><br></pre></td></tr></table></figure><p>这里你需要知道 MyLibFunction() 在脚本 “library/mylibscript.vim” 里定义,该脚本 在 ’runtimepath’ 的某个目录里。 为了稍稍简化,Vim 提供了自动载入机制。如下所示：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> mylib#myfunction(arg)</span><br></pre></td></tr></table></figure><p>下面的内容源自于书籍HACKINGVIM. 在Vim中, 与高亮相关的技术是匹配(matching).匹配通过下面这个命令完成:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">match</span> Group /pattern/</span><br></pre></td></tr></table></figure><p>比如超过一行内的11个字符以后的字符被标记为错误</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">match</span> ErrorMsg /\%&gt;<span class="number">11</span>v.\+/</span><br></pre></td></tr></table></figure><p>其中\%&gt; 匹配该列之后的内容, 列号紧跟在尖括号的右边;v 只能工作在可见的列上面;.+ 匹配一个或多个任意的字符, 想匹配有效的 IP 地址, 只需要执行:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> todo</span><br><span class="line">/\(\(<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]\|<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>][<span class="number">0</span>-<span class="number">9</span>]\|[<span class="number">01</span>]\?[<span class="number">0</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]\?\)\.\)\\\&#123;<span class="number">3</span>\&#125;\(<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]\|<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>][<span class="number">0</span>-<span class="number">9</span>]\|[<span class="number">01</span>]\?[<span class="number">0</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]\?\)/</span><br></pre></td></tr></table></figure><p>打开拼写检查的命令是</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> spell</span><br></pre></td></tr></table></figure><p>命令使用默认的语言 (英语) 打开拼写检查, 如果想要使用其他语言, 只需要把 spelllang 设置成该语言的代号即可;语言的名字甚至可以是专业名词, 比如 medical. 如果 Vim 无法识别用户输入的语言名字, 那么在执行属性设置命令时, 它就会高亮显示无法识别的语言名字.</p><p>为了避免多次输入同一个内容, 用户可以使用缩写 (abbreviations).根据不同的使用模式, 可以使用以下三个命令来创建缩写:</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">abbreviate:</span> 创建在所有模式中均可使用的缩写</span><br><span class="line"><span class="symbol">iabbrev:</span> 创建只能在插入模式中使用的缩写</span><br><span class="line"><span class="symbol">cabbrev:</span> 创建只能在命令行中使用的缩写</span><br></pre></td></tr></table></figure><p>为了避免每次都执行一次缩写命令, 用户可以把它们放在 VIMHOME 的某个文件中, 假设文件名就叫 abbreviations.vim, 然后在文件 vimrc 使用命令 source 来使能该文件 (需确保该文件是可读的) <code>:source $VIM/abbreviations.vim</code></p><p>比如写个编程模板(tex,等等都是可以自定义的)<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">iabbr forx <span class="keyword">for</span>(<span class="keyword">x</span>=<span class="number">0</span>;<span class="keyword">x</span>&lt;<span class="number">100</span>;<span class="keyword">x</span>++)&#123;<span class="symbol">&lt;cr&gt;</span><span class="symbol">&lt;cr&gt;</span>&#125;</span><br></pre></td></tr></table></figure></p><h1 id="用寄存器实现删除-复制与粘贴操作"><a href="#用寄存器实现删除-复制与粘贴操作" class="headerlink" title="用寄存器实现删除,复制与粘贴操作"></a>用寄存器实现删除,复制与粘贴操作</h1><p>在技巧里面说了一小部分,但是没有系统的说明,在这里详细的补充一下。通常情况下, 在许多程序与操作系统中, 用户只能利用一个剪贴板来完成文本的剪切与复制. 在 Vim 中不会出现这种情况,因为用户可以访问多达 9 种不同的剪贴板, 更准确来说, 应该是 9 种不的寄存器类型.  vim 缺省使用无名寄存器。无名寄存器用引号表示。</p><p>有些寄存器类型的工作领域有所重叠, 但还有一些则拥有自己独特的目的. 用户可以在多种不同的命令或操 作中 (比如复制, 删除, 粘贴) 使用寄存器. 寄存器的名字都以双引号 “ 开始, 比如 “x, 所以, 现在让我们来看一下 如何使用一个寄存器. 假设我们现在要用的寄存器是 “x 为了把某段文本复制到寄存器中, 可以用命令 y 来完成, 不过这次有所不同, 在复制之前, 我们先告诉 Vim 被 复制文本的存放位置: “xy (用 “xyy 可以复制一整行) 对于用来剪切文本的命令 x 也是一样的: “xx 对于删除文本的命令 d 则是: “xd 现在, 用户已经在寄存器 “x 中存放了一段文本, 并且想要把这段文本粘贴到正式文本中, 可以用命令 P (粘贴 在光标位置之前) 或 p (粘贴在光标位置之后), 但在粘贴之前, 我们要先指定寄存器: “xP 或 “xp 如果用户忘记自己使用了哪些寄存器, 可以执行命令: :registers.更多的内容可以通过网络搜索获得,这里就不加赘述了。</p><details><summary>展开</summary><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">命令   &amp;            用途                                         </span><br><span class="line">c      &amp;           修改                                          </span><br><span class="line">d      &amp;           删除                                          </span><br><span class="line">y      &amp;           复制到寄存器                                  </span><br><span class="line">g~     &amp;            反转大小写                                   </span><br><span class="line">gu     &amp;            转换为小写                                   </span><br><span class="line">gU     &amp;            转换为大写                                   </span><br><span class="line">&gt;      &amp;            增加缩进                                     </span><br><span class="line">&lt;      &amp;            减小缩进                                     </span><br><span class="line"><span class="section">=      &amp;            自动缩进                                     </span></span><br><span class="line">!      &amp;            使用外部程序过滤&#123;motion&#125;所跨越的行           </span><br></pre></td></tr></table></figure></details><details><summary>展开</summary><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">目的                        &amp;   操作                   &amp;  重复              &amp;    回退   </span><br><span class="line">做出一个修改                &amp;  &#123;edit&#125;                  &amp;   .              &amp;   u       </span><br><span class="line">在行内查找下一指定字符      &amp;  f&#123;<span class="built_in">char</span>&#125;/<span class="built_in">t</span>&#123;<span class="built_in">char</span>&#125;         &amp;   ;              &amp;    ,      </span><br><span class="line">在行内查找上一指定字符      &amp;  F&#123;<span class="built_in">char</span>&#125;/<span class="built_in">T</span>&#123;<span class="built_in">char</span>&#125;         &amp;   ;              &amp;    ,      </span><br><span class="line">在文档中查找下一处匹配项    &amp;  /pattern                &amp;    <span class="built_in">n</span>             &amp;    <span class="built_in">N</span>      </span><br><span class="line">在文档中查找上一处匹配项    &amp;  ?pattern                &amp;    <span class="built_in">n</span>             &amp;    <span class="built_in">N</span>      </span><br><span class="line">执行替换                    &amp;   <span class="symbol">:s</span>/target/replacement  &amp;   \&amp;             &amp;    u      </span><br><span class="line">执行一系列修改              &amp;   qx&#123;changes&#125;q           &amp;   @x             &amp;    u      </span><br></pre></td></tr></table></figure></details><h1 id="搜集的技巧"><a href="#搜集的技巧" class="headerlink" title="搜集的技巧"></a>搜集的技巧</h1><p>1,gd 快速跳转到当前光标所在变量或者函数名的定义处. gD: 跳转到全局变量的定义处,从当前文件开头开始搜索； 类似的还有gf,来打开被包含的文件。</p><p>2,<code>:g /word/d</code> 删除所有含有word的单词所在行. 相反的可以<code>:v /abc/d</code>,也就是删除没有word这个字母所在行, 删除空行可以用 <code>:g /^\s*$/d</code>, 其中^表示开头,\s 表示空格, * 代表匹配任意字符,$ 代表末尾。</p><p>3,autocmd可以用这个命令实现对不同的文件格式应用不同的配置; 可以在新建文件时自动添加上版权声明等等. 这些命令一般定义在 ~/.vimrc 这样的配置文件里面。</p><p>4,在打开一个文件编辑后才知道登录的用户对该文件没有写权,不能存盘, 可以执行vim file :w /tmp/1,先临时存到/tmp/1 中, 然后进行后续的操作。</p><p>5,按v键进入选择模式,然后移动光标选择你要的文本,按u转小写,按U转大写,把光标移动到 { 处.按%光标会自动跳到与之成对的 } 上面.反之也可以.把函数体折叠起来：把光标移动到函数开始的 { 处, 然后(normal mode)输入zf来创建函数折叠；在已经折叠的加号位置输入zc 来打开折叠的函数。当要把打开的函数再折叠就输入zx关闭(第二次折叠)shift+v块选以后,输入zf——实现块折叠. [z 到当前打开的折叠的开始处。 zj 向下移动。到达下一个折疊的开始处。关闭的折疊也被计入. 删除折叠可以用zd或zD,一个用于删除光标下的折叠,另外一个是用于删除嵌套用的。</p><p>6,按 Ctrl + r 最后按 Ctrl + w。这个在光标下的单词会被拷贝, 这就省的在输入或是在查找一个单词的时候自己手动输入啦。</p><p>7,在Vim中直接进行转换文件编码,比如将一个文件转换成utf-8格式可用如下指令:set fileencoding=utf-8.</p><p>8,<code>\&gt;</code>是一个特殊的记号,表示只匹配单词末尾.类似地,<code>\&lt;</code> 只匹配单词的开头.所以要匹配一个完整的单词 “int”,只需：<code>/\&lt; int\&gt;</code></p><p>9, 对同一个文件夹下的文件批量处理方法,以.m文件为例(因为有的时候,需要转换文件编码方式),<code>:args ./\*.m ;  :argdo set fileencoding=utf-8</code> (之所以写这个,是因为小董问我要代码,而自己电脑里的编码方式又和windows不一样,自己又懒,文件一多就不想让每个都转化格式,所以就…..)</p><p>10,可以用 = 符号指明使用表达式寄存器.在插入模式中,输入 <C-r>= 就可以访问这一寄存器.这条命令会在屏幕的下方显示一个提示符,我们可以在其后输入要执行的表达式.输入表达式后敲一下 <CR>, Vim 就会把执行的结果插入到文档的当前位置了。</p><p>11,替换目标字符串前加一个\&lt;,它就会匹配一个word的起始位置,>可以用来指示一个word的结束位置。</p><p>12,:write !wc  统计字数;J 命令则用来把当前行和下一行连接在一起.”yas” 命令拷贝一个句子。</p><p>13,宏的录制,在Normal模式下先按q,录制的符号可以在[a-z]中选择(假设这里选择了a),就像标记m那样,一系列胡乱操作后,在Normal模式下按q停止,想重复录制的内容,按下@a就行,喜欢重复的又不想连续按@a的可以输入<code>.</code>,来重复上一过程。</p><p>14,在当前行正好处于窗口顶部或底部时,有时我会滚动一下屏幕,以便看到更多的上下文.用 zz (用<strong>智障</strong>记忆,很快的…)命令可以重绘屏幕,并把当前行显示在窗口正中,这样就能够阅读当前行之上及之下的半屏内容。</p><p>15,:Sex  水平分割一个窗口,浏览文件系统； :Vex  垂直分割一个窗口,浏览文件系统；(安装了插件后,就没用过这个功能了),有必要补充一句,如果在mac中,感觉分割窗口并不是必须的,如果屏幕比较小,看起来挺难受的,ctrl+N, 这样就另开了一个命令行,然后通过触摸板,用手势即可切换,长时间的编辑,有的时候受不了那种强度,所以换换口味也挺好。</p><p>16,m{a-z}: 标记光标所在位置,局部标记,只用于当前文件.m{A-Z}: 标记光标所在位置,全局标记.标记之后,退出Vim, 重新启动,标记仍然有效.:marks 显示所有标记.  :delmarks!  删除当前缓冲区的所有标记。</p><p>17,<code>&#39;&#39;</code>: 移动到上次离开的地方。</p><p>18,%: 不仅能移动到匹配的(),{}或[]上,而且能在#if,#else, #endif之间跳跃。</p><p>19,:r !date 在光标处插入当前日期与时间.同理,:r !command可以将其它shell命令的输出插入当前文档。</p><p>20,w: 移到下一个单词的首字母; b: 移到前一个单词的首字母;e: 移到单词的末尾;这些命令可以互相组合, 比如, 用户想要移到下一个单词的末尾, 只需要执行we。</p><p>21,所有类型的变量都是通过命令 :let 定义。 置位 <code>ruler</code> 选项.这会在 Vim 窗口的右下角显示当前光标的位置。</p><p>22,自动缩进的一种简洁形式gg=G。</p><p>23,Vim 有一套功能非常强大的命令,可以完成所有功能。但有些东西外部命令能够完成得更好或者更快。命令 “!{motion}{program}” 用一个外部程序对一个文本块进行过滤。换句话说,它用一个文本块作为输入,执行一个由{program}指定的外部命令,然后用该程序的输出替代选中的文本块。</p><p>24,在插入模式,当我们按下<CTRL> + R键,再加上相应的寄存器的名字,就可以插入寄存器中的内容了。 无名寄存器用(“)来标识,如果没指定的话,复制(y),剪切(x,s,d,c和他们的大写),粘贴(p)命令都会将内容存放到这个寄存器里面,或是从这个寄存器里面来读取内容。查看寄存器:reg,　这个用起来会非常方便,就像把一些自己会用到的内容放在一个寄存器中,想调出来”” + 寄存器名字　＋操作”即可。</p><p>25,如果厌倦了使用ESC,<c-[>,<c-c>来切换,不妨更改一下映射关系,自己是这么做的： :imap oo <esc>, 买了HHKB后,这个语句就从配置文件中消失了。。。。。还有,HHKB真香,不过适用的群体真的很小众,如果是用来打游戏,还是别了,会让你失望的。</p><p>26,<code>&gt;&gt;</code> 当前行增加缩进 <code>&lt;&lt;</code>当前行减少缩进, 个人比较喜欢在可视模式中使用这个。</p><p>27,set ts=4  (注：ts是tabstop的缩写,设TAB宽4个空格) set expandtab</p><p>28,G 命令会增加从当前行到文档末尾处的缩进层级。</p><p>29,gv 命令是个有用的快捷键,它用来重选上一次由可视模式所选择的文本范围。不管上个选区是面向字符的、面向行的,或是面向列块的,g 命令都能够正确地工作。不过如果上次的选区被删除了,它也许会工作得不太正常.</p><p>30,o:切换高亮选区的活动端(可视模式下)。</p><p>31,it 命令是一种被称为文本对象。</p><p>32,ctrl+w+s 可以水平切分此窗口,类似的,ctrl+w+s 可以进行垂直切分,且不受次数限制(用了这么久才知道T_T 该死的vsplit),ctrl+w可以切换这两个窗口。</p><p>33,命令模式下 按g 再按 Ctrl+g 可以统计字数。</p><p>34,only 命令关闭除活动窗口外的所有其他窗口。</p><p>35,要想跳到上次文档中被更改过的地方,我们可以按 g；。它会跳到上次完成编辑时光标所在的行及列上,其结果与按 u <C-r>类似,只是它不会对文档造成暂态的改变。</p><p>36,每次用 gf 命令时,vim 都会在跳转列表中增添一条记录,因此可以用Ctrl+o 命令返回原处。</p><p>37, <code>vim -d file1 file2</code> 的时候,如果感觉左或者右边的窗口太小,可通过命令 <code>vertical res +20</code>, 来改变窗口大小。</p><p>38,文本倒序: <code>:g /^/m0</code>。</p><p>下面是问chatGPT给我的一些技巧,有些还挺实用的</p><p>39, 插入模式下,按 <code>Ctrl</code> + <code>h</code> 可以删除前一个字符,按 <code>Ctrl</code> + <code>w</code> 可以删除前一个单词,按 <code>Ctrl</code> + <code>u</code> 可以删除整行。</p><p>40, 在普通模式下,按 <code>i</code> 进入插入模式,按 <code>a</code> 在光标后插入,按 <code>o</code> 在下一行插入,按 <code>O</code> 在上一行插入。</p><p>41, 在普通模式下,按 <code>x</code> 删除当前光标所在的字符,按 <code>dw</code> 删除当前光标所在的单词,按 <code>dd</code> 删除当前光标所在的整行。</p><p>42, 在普通模式下,按 <code>yy</code> 复制当前光标所在的整行,按 <code>p</code> 将剪贴板中的内容粘贴到当前光标所在的位置。</p><p>43, 在普通模式下,按 <code>Ctrl</code> + <code>f</code> 可以向下翻页,按 <code>Ctrl</code> + <code>b</code> 可以向上翻页。</p><p>44, 在普通模式下,按 <code>gg</code> 跳到文件的第一行,按 <code>G</code> 跳到文件的最后一行。</p><p>45, 在普通模式下,按 <code>:w</code> 可以保存文件,按 <code>:q</code> 可以退出 Vim,按 <code>:wq</code> 可以保存并退出 Vim。</p><p>46, 在普通模式下,按 <code>u</code> 可以撤销上一步操作,按 <code>Ctrl</code> + <code>r</code> 可以重做上一步操作。</p><p>47, 在普通模式下,按 <code>.</code> 可以重复上一次操作。</p><p>48,在普通模式下,按 <code>%</code> 可以匹配括号(包括圆括号、方括号和花括号),并跳转到匹配的括号处。</p><p>49, 在普通模式下,按 <code>*</code> 可以匹配当前光标所在的单词,并向下跳转到下一次出现该单词的位置,按 <code>#</code> 则是向上跳转到上一次出现该单词的位置。</p><p>50, 在普通模式下,按 <code>:set nu</code> 可以显示行号,按 <code>:set nonu</code> 可以隐藏行号。</p><p>51, 在普通模式下,按 <code>:set paste</code> 可以开启粘贴模式,使得从外部复制内容时可以避免自动缩进等问题,按 <code>:set nopaste</code> 可以关闭粘贴模式。</p><p>52, 在普通模式下,按 <code>:set incsearch</code> 可以开启增量搜索,使得在搜索时可以实时匹配输入的字符,按 <code>:set noincsearch</code> 可以关闭增量搜索</p><p>53, 在普通模式下,按 <code>:set hlsearch</code> 可以开启搜索高亮,使得在搜索时匹配到的内容会被高亮显示,按 <code>:set nohlsearch</code> 可以关闭搜索高亮。</p><p>54, 在普通模式下,按 <code>Ctrl</code> + <code>g</code> 可以显示当前文件的信息,包括文件名、文件类型、文件行数等。</p><p>55, 在普通模式下,按 <code>:tabnew</code> 可以新建一个标签页,按 <code>gt</code> 可以切换到下一个标签页,按 <code>gT</code> 可以切换到上一个标签页。</p><p>56, 在普通模式下,按 <code>:vsp</code> 可以在垂直方向上分割窗口,按 <code>Ctrl</code> + <code>w</code> + <code>w</code> 可以在窗口之间切换,按 <code>:q</code> 可以关闭当前窗口</p><p>57,在普通模式下,按 <code>:r !date</code> 可以将当前时间插入到当前光标所在行的下一行。</p><p>58,在普通模式下,按 <code>:g/foo/d</code> 可以删除所有包含字符串 <code>foo</code> 的行。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] 《VIM中文手册》<br>[2] 《Practical Vim》<br>[3] 《VIM 7.2》</p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tools </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
