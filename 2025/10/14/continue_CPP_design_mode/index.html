<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/favicon.ico"/>
	<link rel="shortcut icon" href="/img/favicon.ico">
		<!-- Modified by lsqyRobot -->
    <title>
    Beyond The Memory
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="google-site-verification" content="Mbr82TZaQktpHzJ9Wt0AZ4B9JFdVUi1Xjxs8gf20DDM" />
    <link rel="stylesheet" href="/css/lsqy_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="mathematica,robotics,manipulator,ros,vim,matlab,C/C++,python,git,control theory,lsqyRobot" />
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/myCover.png') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/dytitle.js"></script>
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/fireworks.js"></script>
    <script src="/js/codeBlockFuction.js"></script>
    <script src="/js/cursor-heart.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>
		


<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<body class="is-loading">
    <div id="wrapper" class="fade-in">
        <header id="header">
    <a href="/" class="logo">
        <span id="typewriter-text"></span>
        <span id="cursor">|</span>
    </a>
</header>

<style>
    #typewriter-text {
        display: inline;
    }

    #cursor {
        animation: blink 1s infinite;
        font-weight: 100;
        opacity: 1;
    }

    @keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
    }
</style>

<script>
(function() {
    // 打字机文本数组
    const texts = [
        
            
                "DOTS...",
            
                "CODING...",
            
                "THINKING...",
            
                "CREATING...",
            
                "EXPLORING..."
            
        
    ];

    // 打字机设置
    const settings = {
        typeSpeed: 100,
        deleteSpeed: 50,
        pauseTime: 1500,
        startDelay: 500
    };

    const typewriterElement = document.getElementById('typewriter-text');
    const cursorElement = document.getElementById('cursor');
    let textIndex = 0;
    let charIndex = 0;
    let isDeleting = false;

    function typeWriter() {
        const currentText = texts[textIndex];

        if (!isDeleting) {
            // 打字阶段
            if (charIndex < currentText.length) {
                typewriterElement.innerHTML = currentText.substring(0, charIndex + 1);
                charIndex++;
                setTimeout(typeWriter, settings.typeSpeed);
            } else {
                // 完成打字，等待一段时间后开始删除
                setTimeout(() => {
                    isDeleting = true;
                    typeWriter();
                }, settings.pauseTime);
            }
        } else {
            // 删除阶段
            if (charIndex > 0) {
                typewriterElement.innerHTML = currentText.substring(0, charIndex - 1);
                charIndex--;
                setTimeout(typeWriter, settings.deleteSpeed);
            } else {
                // 完成删除，切换到下一个文本
                isDeleting = false;
                textIndex = (textIndex + 1) % texts.length;
                setTimeout(typeWriter, 200); // 切换文本的间隔
            }
        }
    }

    // 页面加载完成后开始打字效果
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(typeWriter, settings.startDelay);
    });
})();
</script>

        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow"><img src="/img/home.png"></a>
	        </li>

			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1"><img src="/img/folder.png"></a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/ALGORITHM/">ALGORITHM</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/CONFIG/">CONFIG</a></li><li><a class="category-link" href="/categories/CONTROL/">CONTROL</a></li><li><a class="category-link" href="/categories/CPP/">CPP</a></li><li><a class="category-link" href="/categories/GIT/">GIT</a></li><li><a class="category-link" href="/categories/HEXO/">HEXO</a></li><li><a class="category-link" href="/categories/ISAAC-LAB/">ISAAC LAB</a></li><li><a class="category-link" href="/categories/LATEX/">LATEX</a></li><li><a class="category-link" href="/categories/LIFE/">LIFE</a></li><li><a class="category-link" href="/categories/LINUX/">LINUX</a></li><li><a class="category-link" href="/categories/MAC-BOOK/">MAC BOOK</a></li><li><a class="category-link" href="/categories/MATLAB/">MATLAB</a></li><li><a class="category-link" href="/categories/PYTHON/">PYTHON</a></li><li><a class="category-link" href="/categories/ROBOTICS/">ROBOTICS</a></li><li><a class="category-link" href="/categories/ROS/">ROS</a></li><li><a class="category-link" href="/categories/TOOLS/">TOOLS</a></li><li><a class="category-link" href="/categories/dataStruct/">dataStruct</a></li><li><a class="category-link" href="/categories/robotics/">robotics</a>
	                    </ul>
	        </li>
	        


	        <!-- about 关于我   --> 
			<li>
	        
	            <a href="/about/" ><img src="/img/about.png"></a>
	        
			</li>



	        <!-- about 关于我的朋友   --> 
			<li>
	        
	            <a href="/friend/" ><img src="/img/friend.png"></a>
	        
			</li>




	        <!-- about 关于格言   --> 
			<li>
	        
	            <a href="/quote/" ><img src="/img/quote.png"></a>
	        
			</li>


	        <!-- about 关于搜索栏   --> 
			<li>
	        
	            <a href="/search/" ><img src="/img/search.png"></a>
	        
			</li>



	        <!-- my lover--> 
			<li>
	        
	            <a href="/dudu/" ><img src="/img/myLoverLogo.png"></a>
	        
			</li>

	        <!-- my tags--> 
			<li>
	        
			</li>


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
			</ul>
</nav>


        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(/img/postImg/18_CPP/logo/2024-11-11-11-13-39-1152x768_used.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >策略模式</h2></a>
            </div>

            <div class="typo" style="padding: 3rem;">
                <!-- vim-markdown-toc GFM -->
<ul>
<li><a href="#介绍">介绍</a></li>
<li><a href="#案例">案例</a><ul>
<li><a href="#基础示例---数学运算">基础示例 - 数学运算</a></li>
<li><a href="#实际应用案例---支付处理系统">实际应用案例 - 支付处理系统</a></li>
<li><a href="#数据排序策略示例">数据排序策略示例</a></li>
<li><a href="#现代c特性示例">现代C++特性示例</a><ul>
<li><a href="#使用模板和lambda表达式">使用模板和Lambda表达式</a></li>
<li><a href="#使用c20概念的策略模式">使用C++20概念的策略模式</a></li>
<li><a href="#使用变参模板的策略组合">使用变参模板的策略组合</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#性能分析与最佳实践">性能分析与最佳实践</a><ul>
<li><a href="#性能考虑">性能考虑</a><ul>
<li><a href="#虚函数调用开销">虚函数调用开销</a></li>
<li><a href="#内存管理优化">内存管理优化</a></li>
</ul>
</li>
<li><a href="#最佳实践">最佳实践</a><ul>
<li><a href="#1-策略接口设计">1. 策略接口设计</a></li>
<li><a href="#2-异常安全">2. 异常安全</a></li>
<li><a href="#3-线程安全">3. 线程安全</a></li>
<li><a href="#4-策略工厂模式">4. 策略工厂模式</a></li>
<li><a href="#5-策略链模式">5. 策略链模式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#相关设计模式对比">相关设计模式对比</a><ul>
<li><a href="#与工厂模式的区别">与工厂模式的区别</a></li>
<li><a href="#状态模式-state-pattern">状态模式 (State Pattern)</a></li>
<li><a href="#模板方法模式-template-method-pattern">模板方法模式 (Template Method Pattern)</a></li>
<li><a href="#命令模式-command-pattern">命令模式 (Command Pattern)</a></li>
<li><a href="#各模式对比总结">各模式对比总结</a></li>
</ul>
</li>
<li><a href="#常见问题和陷阱">常见问题和陷阱</a><ul>
<li><a href="#常见问题解答-faq">常见问题解答 (FAQ)</a><ul>
<li><a href="#q1-策略模式会增加太多类吗">Q1: 策略模式会增加太多类吗？</a></li>
<li><a href="#q2-什么时候不应该使用策略模式">Q2: 什么时候不应该使用策略模式？</a></li>
<li><a href="#q3-如何选择虚函数还是模板实现">Q3: 如何选择虚函数还是模板实现？</a></li>
</ul>
</li>
<li><a href="#常见陷阱和错误">常见陷阱和错误</a><ul>
<li><a href="#陷阱1-策略接口设计过于宽泛">陷阱1: 策略接口设计过于宽泛</a></li>
<li><a href="#陷阱2-忘记处理异常安全">陷阱2: 忘记处理异常安全</a></li>
<li><a href="#陷阱3-内存泄漏风险">陷阱3: 内存泄漏风险</a></li>
<li><a href="#陷阱4-线程安全问题">陷阱4: 线程安全问题</a></li>
<li><a href="#陷阱5-过度设计">陷阱5: 过度设计</a></li>
</ul>
</li>
<li><a href="#最佳实践总结">最佳实践总结</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>目的: 定义一系列的算法(行为),把它们一个个封装起来,并且使它们可以互替换(继承接口).</p>
<p>关键: 实现同一个接口.</p>
<p>优点:</p>
<ol>
<li>算法之间可以互相替换;</li>
<li>可以避免多重条件判断;</li>
<li>扩展性良好.</li>
</ol>
<p>缺点:</p>
<ol>
<li>策略类会比较多;</li>
<li>所有策略都需要对外暴露.</li>
</ol>
<p>使用场景:</p>
<ol>
<li>一个对象可能存在多种行为,需要使用多重条件判断时;</li>
<li>系统需要在几种算法中选择一种.</li>
</ol>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="基础示例-数学运算"><a href="#基础示例-数学运算" class="headerlink" title="基础示例 - 数学运算"></a>基础示例 - 数学运算</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doOperate</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法实现1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyAdd</span> : <span class="keyword">public</span> Strategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doOperate</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法实2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategySub</span> : <span class="keyword">public</span> Strategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doOperate</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件选择</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Context</span>(std::shared_ptr&lt;Strategy&gt; Strategy) : <span class="built_in">Strategy_</span>(Strategy)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Strategy&gt; <span class="title">GetStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Strategy_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetStrategy</span><span class="params">(std::shared_ptr&lt;Strategy&gt; Strategy)</span> </span>&#123;</span><br><span class="line">        Strategy_ = Strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doOperate</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Strategy_-&gt;<span class="built_in">doOperate</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Strategy&gt; Strategy_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">(std::make_shared&lt;StrategyAdd&gt;())</span></span>;</span><br><span class="line">    std::cout &lt;&lt; context.<span class="built_in">doOperate</span>(<span class="number">10</span>, <span class="number">100</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    context.<span class="built_in">SetStrategy</span>(std::<span class="built_in">make_shared</span>&lt;StrategySub&gt;());</span><br><span class="line">    std::cout &lt;&lt; context.<span class="built_in">doOperate</span>(<span class="number">10</span>, <span class="number">100</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实际应用案例-支付处理系统"><a href="#实际应用案例-支付处理系统" class="headerlink" title="实际应用案例 - 支付处理系统"></a>实际应用案例 - 支付处理系统</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支付策略接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PaymentStrategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">processPayment</span><span class="params">(<span class="type">double</span> amount)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getPaymentMethod</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信用卡支付策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreditCardPayment</span> : <span class="keyword">public</span> PaymentStrategy &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string cardNumber_;</span><br><span class="line">    std::string holderName_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CreditCardPayment</span>(<span class="type">const</span> std::string&amp; cardNumber, <span class="type">const</span> std::string&amp; holderName)</span><br><span class="line">        : <span class="built_in">cardNumber_</span>(cardNumber), <span class="built_in">holderName_</span>(holderName) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">processPayment</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing credit card payment of $&quot;</span> &lt;&lt; amount</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; for &quot;</span> &lt;&lt; holderName_</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; (Card: ****&quot;</span> &lt;&lt; cardNumber_.<span class="built_in">substr</span>(cardNumber_.<span class="built_in">length</span>()<span class="number">-4</span>)</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 模拟支付处理逻辑</span></span><br><span class="line">        <span class="keyword">return</span> amount &gt; <span class="number">0</span> &amp;&amp; amount &lt;= <span class="number">10000</span>; <span class="comment">// 假设信用卡限额10000</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getPaymentMethod</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Credit Card&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PayPal支付策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PayPalPayment</span> : <span class="keyword">public</span> PaymentStrategy &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string email_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PayPalPayment</span>(<span class="type">const</span> std::string&amp; email) : <span class="built_in">email_</span>(email) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">processPayment</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing PayPal payment of $&quot;</span> &lt;&lt; amount</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; for &quot;</span> &lt;&lt; email_ &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 模拟PayPal支付处理</span></span><br><span class="line">        <span class="keyword">return</span> amount &gt; <span class="number">0</span> &amp;&amp; amount &lt;= <span class="number">5000</span>; <span class="comment">// PayPal限额5000</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getPaymentMethod</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PayPal&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行转账支付策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankTransferPayment</span> : <span class="keyword">public</span> PaymentStrategy &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string bankAccount_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BankTransferPayment</span>(<span class="type">const</span> std::string&amp; bankAccount)</span><br><span class="line">        : <span class="built_in">bankAccount_</span>(bankAccount) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">processPayment</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing bank transfer of $&quot;</span> &lt;&lt; amount</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; from account &quot;</span> &lt;&lt; bankAccount_ &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 银行转账通常没有限额但处理时间长</span></span><br><span class="line">        <span class="keyword">return</span> amount &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getPaymentMethod</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bank Transfer&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支付上下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentProcessor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;PaymentStrategy&gt; strategy_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPaymentStrategy</span><span class="params">(std::shared_ptr&lt;PaymentStrategy&gt; strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">processOrder</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strategy_) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No payment method selected!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using &quot;</span> &lt;&lt; strategy_-&gt;<span class="built_in">getPaymentMethod</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; payment method.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> strategy_-&gt;<span class="built_in">processPayment</span>(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PaymentProcessor processor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小额支付用PayPal</span></span><br><span class="line">    <span class="keyword">auto</span> paypal = std::<span class="built_in">make_shared</span>&lt;PayPalPayment&gt;(<span class="string">&quot;user@example.com&quot;</span>);</span><br><span class="line">    processor.<span class="built_in">setPaymentStrategy</span>(paypal);</span><br><span class="line">    processor.<span class="built_in">processOrder</span>(<span class="number">299.99</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; std::<span class="built_in">string</span>(<span class="number">50</span>, <span class="string">&#x27;-&#x27;</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大额支付用银行转账</span></span><br><span class="line">    <span class="keyword">auto</span> bankTransfer = std::<span class="built_in">make_shared</span>&lt;BankTransferPayment&gt;(<span class="string">&quot;123456789&quot;</span>);</span><br><span class="line">    processor.<span class="built_in">setPaymentStrategy</span>(bankTransfer);</span><br><span class="line">    processor.<span class="built_in">processOrder</span>(<span class="number">15000.00</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; std::<span class="built_in">string</span>(<span class="number">50</span>, <span class="string">&#x27;-&#x27;</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中等金额用信用卡</span></span><br><span class="line">    <span class="keyword">auto</span> creditCard = std::<span class="built_in">make_shared</span>&lt;CreditCardPayment&gt;(<span class="string">&quot;1234567890123456&quot;</span>, <span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">    processor.<span class="built_in">setPaymentStrategy</span>(creditCard);</span><br><span class="line">    processor.<span class="built_in">processOrder</span>(<span class="number">1999.99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据排序策略示例"><a href="#数据排序策略示例" class="headerlink" title="数据排序策略示例"></a>数据排序策略示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序策略接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SortStrategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuickSortStrategy</span> : <span class="keyword">public</span> SortStrategy &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);</span><br><span class="line">            <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot = arr[high];</span><br><span class="line">        <span class="type">int</span> i = (low - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt;= high - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                std::<span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]);</span><br><span class="line">        <span class="keyword">return</span> (i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">quickSort</span>(data, <span class="number">0</span>, data.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Quick Sort&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MergeSortStrategy</span> : <span class="keyword">public</span> SortStrategy &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">mergeSort</span>(arr, left, mid);</span><br><span class="line">            <span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">            <span class="built_in">merge</span>(arr, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1 = mid - left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n2 = right - mid;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">leftArr</span><span class="params">(n1)</span>, <span class="title">rightArr</span><span class="params">(n2)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">            leftArr[i] = arr[left + i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">            rightArr[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftArr[i] &lt;= rightArr[j]) &#123;</span><br><span class="line">                arr[k] = leftArr[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k] = rightArr[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">            arr[k] = leftArr[i];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">            arr[k] = rightArr[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">mergeSort</span>(data, <span class="number">0</span>, data.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Merge Sort&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STL排序策略(通常是introsort，混合算法)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">STLSortStrategy</span> : <span class="keyword">public</span> SortStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;STL Sort&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序上下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sorter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;SortStrategy&gt; strategy_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(std::shared_ptr&lt;SortStrategy&gt; strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">performSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strategy_) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;No sorting strategy selected!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        strategy_-&gt;<span class="built_in">sort</span>(data);</span><br><span class="line">        <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> duration = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line">        std::cout &lt;&lt; strategy_-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; completed in &quot;</span></span><br><span class="line">                  &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="现代C-特性示例"><a href="#现代C-特性示例" class="headerlink" title="现代C++特性示例"></a>现代C++特性示例</h2><h3 id="使用模板和Lambda表达式"><a href="#使用模板和Lambda表达式" class="headerlink" title="使用模板和Lambda表达式"></a>使用模板和Lambda表达式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板化策略接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Input, <span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Strategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Output <span class="title">execute</span><span class="params">(<span class="type">const</span> Input&amp; input)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用std::function的轻量级策略系统</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Input, <span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FunctionStrategy</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::function&lt;Output(<span class="type">const</span> Input&amp;)&gt; strategy_func_;</span><br><span class="line">    std::string name_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FunctionStrategy</span>(std::function&lt;<span class="built_in">Output</span>(<span class="type">const</span> Input&amp;)&gt; func, <span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">strategy_func_</span>(func), <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Output <span class="title">execute</span><span class="params">(<span class="type">const</span> Input&amp; input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strategy_func_</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略上下文 - 使用模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Input, <span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyContext</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Strategy&lt;Input, Output&gt;&gt; strategy_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(std::shared_ptr&lt;Strategy&lt;Input, Output&gt;&gt; strategy)</span> </span>&#123;</span><br><span class="line">        strategy_ = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Output <span class="title">executeStrategy</span><span class="params">(<span class="type">const</span> Input&amp; input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strategy_) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;No strategy set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strategy_-&gt;<span class="built_in">execute</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串处理策略示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringProcessor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, std::function&lt;std::string(<span class="type">const</span> std::string&amp;)&gt;&gt; strategies_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StringProcessor</span>() &#123;</span><br><span class="line">        <span class="comment">// 使用Lambda表达式定义策略</span></span><br><span class="line">        strategies_[<span class="string">&quot;uppercase&quot;</span>] = [](<span class="type">const</span> std::string&amp; input) &#123;</span><br><span class="line">            std::string result = input;</span><br><span class="line">            std::<span class="built_in">transform</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        strategies_[<span class="string">&quot;lowercase&quot;</span>] = [](<span class="type">const</span> std::string&amp; input) &#123;</span><br><span class="line">            std::string result = input;</span><br><span class="line">            std::<span class="built_in">transform</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        strategies_[<span class="string">&quot;reverse&quot;</span>] = [](<span class="type">const</span> std::string&amp; input) &#123;</span><br><span class="line">            std::string result = input;</span><br><span class="line">            std::<span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        strategies_[<span class="string">&quot;capitalize&quot;</span>] = [](<span class="type">const</span> std::string&amp; input) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input.<span class="built_in">empty</span>()) <span class="keyword">return</span> input;</span><br><span class="line">            std::string result = input;</span><br><span class="line">            std::<span class="built_in">transform</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line">            result[<span class="number">0</span>] = std::<span class="built_in">toupper</span>(result[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">process</span><span class="params">(<span class="type">const</span> std::string&amp; input, <span class="type">const</span> std::string&amp; strategy_name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = strategies_.<span class="built_in">find</span>(strategy_name);</span><br><span class="line">        <span class="keyword">if</span> (it != strategies_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;<span class="built_in">second</span>(input);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Unknown strategy: &quot;</span> + strategy_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addStrategy</span><span class="params">(<span class="type">const</span> std::string&amp; name, std::function&lt;std::string(<span class="type">const</span> std::string&amp;)&gt; strategy)</span> </span>&#123;</span><br><span class="line">        strategies_[name] = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">getAvailableStrategies</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::vector&lt;std::string&gt; names;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : strategies_) &#123;</span><br><span class="line">            names.<span class="built_in">push_back</span>(pair.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringProcessor processor;</span><br><span class="line"></span><br><span class="line">    std::string text = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用预定义策略</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Uppercase: &quot;</span> &lt;&lt; processor.<span class="built_in">process</span>(text, <span class="string">&quot;uppercase&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lowercase: &quot;</span> &lt;&lt; processor.<span class="built_in">process</span>(text, <span class="string">&quot;lowercase&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reverse: &quot;</span> &lt;&lt; processor.<span class="built_in">process</span>(text, <span class="string">&quot;reverse&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Capitalize: &quot;</span> &lt;&lt; processor.<span class="built_in">process</span>(text, <span class="string">&quot;capitalize&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态添加新的策略</span></span><br><span class="line">    processor.<span class="built_in">addStrategy</span>(<span class="string">&quot;remove_spaces&quot;</span>, [](<span class="type">const</span> std::string&amp; input) &#123;</span><br><span class="line">        std::string result;</span><br><span class="line">        std::<span class="built_in">copy_if</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(result),</span><br><span class="line">                     [](<span class="type">char</span> c) &#123; <span class="keyword">return</span> c != <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Remove spaces: &quot;</span> &lt;&lt; processor.<span class="built_in">process</span>(text, <span class="string">&quot;remove_spaces&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 列出所有可用策略</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAvailable strategies: &quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> strategies = processor.<span class="built_in">getAvailableStrategies</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; strategy : strategies) &#123;</span><br><span class="line">        std::cout &lt;&lt; strategy &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用C-20概念的策略模式"><a href="#使用C-20概念的策略模式" class="headerlink" title="使用C++20概念的策略模式"></a>使用C++20概念的策略模式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++20概念定义策略接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Input, <span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="keyword">concept</span> StrategyType = <span class="built_in">requires</span>(T strategy, <span class="type">const</span> Input&amp; input) &#123;</span><br><span class="line">    &#123; strategy.<span class="built_in">execute</span>(input) &#125; -&gt; std::same_as&lt;Output&gt;;</span><br><span class="line">    &#123; strategy.<span class="built_in">getName</span>() &#125; -&gt; std::convertible_to&lt;std::string&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础策略接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Input, <span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BaseStrategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Output <span class="title">execute</span><span class="params">(<span class="type">const</span> Input&amp; input)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数学运算策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathStrategy</span> : <span class="keyword">public</span> BaseStrategy&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MathStrategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddStrategy</span> : <span class="keyword">public</span> MathStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; input)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.first + input.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Addition&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiplyStrategy</span> : <span class="keyword">public</span> MathStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; input)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.first * input.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Multiplication&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代C++策略上下文，使用概念约束</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Strategy, <span class="keyword">typename</span> Input, <span class="keyword">typename</span> Output&gt;</span><br><span class="line"><span class="keyword">requires</span> StrategyType&lt;Strategy, Input, Output&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModernStrategyContext</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Strategy&gt; strategy_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">setStrategy</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">        strategy_ = std::<span class="built_in">make_unique</span>&lt;Strategy&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Output <span class="title">executeStrategy</span><span class="params">(<span class="type">const</span> Input&amp; input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!strategy_) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;No strategy set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Executing strategy: &quot;</span> &lt;&lt; strategy_-&gt;<span class="built_in">getName</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> strategy_-&gt;<span class="built_in">execute</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用完美转发的工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Strategy, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">makeStrategy</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Strategy&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用变参模板的策略组合"><a href="#使用变参模板的策略组合" class="headerlink" title="使用变参模板的策略组合"></a>使用变参模板的策略组合</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略组合器 - 可以组合多个策略</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Strategies&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyComposer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::tuple&lt;Strategies...&gt; strategies_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StrategyComposer</span>(Strategies... strategies) : <span class="built_in">strategies_</span>(strategies...) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Input&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> Input&amp; input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">executeImpl</span>(input, std::index_sequence_for&lt;Strategies...&gt;&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Input, <span class="type">size_t</span>... Is&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">executeImpl</span><span class="params">(<span class="type">const</span> Input&amp; input, std::index_sequence&lt;Is...&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(std::<span class="built_in">get</span>&lt;Is&gt;(strategies_).<span class="built_in">execute</span>(input)...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道式策略执行器</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Input, <span class="keyword">typename</span>... Strategies&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">executePipeline</span><span class="params">(Input&amp;&amp; input, Strategies&amp;&amp;... strategies)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (strategies.<span class="built_in">execute</span>(std::forward&lt;Input&gt;(input)), ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：字符串处理管道</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UppercaseStrategy</span> &#123;</span><br><span class="line">    <span class="function">std::string <span class="title">execute</span><span class="params">(<span class="type">const</span> std::string&amp; input)</span> </span>&#123;</span><br><span class="line">        std::string result = input;</span><br><span class="line">        std::<span class="built_in">transform</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TrimStrategy</span> &#123;</span><br><span class="line">    <span class="function">std::string <span class="title">execute</span><span class="params">(<span class="type">const</span> std::string&amp; input)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> start = input.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (start == std::string::npos) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">size_t</span> end = input.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> input.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="性能分析与最佳实践"><a href="#性能分析与最佳实践" class="headerlink" title="性能分析与最佳实践"></a>性能分析与最佳实践</h1><h2 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h2><h3 id="虚函数调用开销"><a href="#虚函数调用开销" class="headerlink" title="虚函数调用开销"></a>虚函数调用开销</h3><p>策略模式使用虚函数，存在一定的性能开销：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统虚函数方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">VirtualStrategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">int</span> x)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVirtual</span> : <span class="keyword">public</span> VirtualStrategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + <span class="number">2</span> * x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板方式（编译期多态）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Strategy&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemplateContext</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Strategy strategy_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy_.<span class="built_in">compute</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConcreteTemplate</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x + <span class="number">2</span> * x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能测试</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">performanceTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iterations = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚函数测试</span></span><br><span class="line">    <span class="keyword">auto</span> virtualStrategy = std::<span class="built_in">make_unique</span>&lt;ConcreteVirtual&gt;();</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> result1 = <span class="number">0</span>;  <span class="comment">// volatile防止编译器优化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; ++i) &#123;</span><br><span class="line">        result1 += virtualStrategy-&gt;<span class="built_in">compute</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> virtualTime = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板测试</span></span><br><span class="line">    TemplateContext&lt;ConcreteTemplate&gt; templateContext;</span><br><span class="line">    start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> result2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; ++i) &#123;</span><br><span class="line">        result2 += templateContext.<span class="built_in">compute</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> templateTime = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Virtual function time: &quot;</span> &lt;&lt; virtualTime.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Template time: &quot;</span> &lt;&lt; templateTime.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Template is &quot;</span> &lt;&lt; (<span class="type">double</span>)virtualTime.<span class="built_in">count</span>() / templateTime.<span class="built_in">count</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot;x faster&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存管理优化"><a href="#内存管理优化" class="headerlink" title="内存管理优化"></a>内存管理优化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory_resource&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用对象池减少内存分配开销</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Strategy&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Strategy&gt;&gt; available_;</span><br><span class="line">    <span class="type">size_t</span> max_size_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StrategyPool</span>(<span class="type">size_t</span> max_size = <span class="number">10</span>) : <span class="built_in">max_size_</span>(max_size) &#123;</span><br><span class="line">        available_.<span class="built_in">reserve</span>(max_size_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    std::shared_ptr&lt;Strategy&gt; <span class="title">acquire</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (available_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Strategy&gt;(</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">Strategy</span>(std::forward&lt;Args&gt;(args)...),</span><br><span class="line">                [<span class="keyword">this</span>](Strategy* ptr) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">release</span>(std::<span class="built_in">unique_ptr</span>&lt;Strategy&gt;(ptr)); &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> strategy = std::<span class="built_in">shared_ptr</span>&lt;Strategy&gt;(</span><br><span class="line">            available_.<span class="built_in">back</span>().<span class="built_in">release</span>(),</span><br><span class="line">            [<span class="keyword">this</span>](Strategy* ptr) &#123; <span class="keyword">this</span>-&gt;<span class="built_in">release</span>(std::<span class="built_in">unique_ptr</span>&lt;Strategy&gt;(ptr)); &#125;</span><br><span class="line">        );</span><br><span class="line">        available_.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">(std::unique_ptr&lt;Strategy&gt; strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (available_.<span class="built_in">size</span>() &lt; max_size_) &#123;</span><br><span class="line">            available_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(strategy));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果池满了，直接删除对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用PMR（多态内存资源）优化内存分配</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PMRStrategy</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::pmr::memory_resource* resource_;</span><br><span class="line">    std::pmr::vector&lt;<span class="type">int</span>&gt; data_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PMRStrategy</span>(std::pmr::memory_resource* resource = std::pmr::<span class="built_in">get_default_resource</span>())</span><br><span class="line">        : <span class="built_in">resource_</span>(resource), <span class="built_in">data_</span>(resource_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; input)</span> </span>&#123;</span><br><span class="line">        data_.<span class="built_in">clear</span>();</span><br><span class="line">        data_.<span class="built_in">reserve</span>(input.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : input) &#123;</span><br><span class="line">            data_.<span class="built_in">push_back</span>(val * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::<span class="function">pmr::vector&lt;<span class="type">int</span>&gt;&amp; <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-策略接口设计"><a href="#1-策略接口设计" class="headerlink" title="1. 策略接口设计"></a>1. 策略接口设计</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 好的设计：接口专一，职责明确</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompressionStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CompressionStrategy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">compress</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getCompressionRatio</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不好的设计：接口过于宽泛</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BadStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doEverything</span><span class="params">(<span class="type">void</span>* data)</span> </span>= <span class="number">0</span>;  <span class="comment">// 过于宽泛</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>= <span class="number">0</span>;               <span class="comment">// 不明确的返回类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-异常安全"><a href="#2-异常安全" class="headerlink" title="2. 异常安全"></a>2. 异常安全</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SafeStrategy</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供强异常安全保证</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">(Data&amp; data)</span> </span>&#123;</span><br><span class="line">        Data backup = data;  <span class="comment">// 备份原数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">executeImpl</span>(data);</span><br><span class="line">        &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            data = std::<span class="built_in">move</span>(backup);  <span class="comment">// 回滚</span></span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">executeImpl</span><span class="params">(Data&amp; data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用RAII确保资源管理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceAwareStrategy</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ResourceGuard</span> &#123;</span><br><span class="line">        <span class="type">void</span>* resource;</span><br><span class="line">        <span class="built_in">ResourceGuard</span>(<span class="type">void</span>* r) : <span class="built_in">resource</span>(r) &#123;&#125;</span><br><span class="line">        ~<span class="built_in">ResourceGuard</span>() &#123; <span class="keyword">if</span> (resource) <span class="built_in">cleanup</span>(resource); &#125;</span><br><span class="line">        <span class="built_in">ResourceGuard</span>(<span class="type">const</span> ResourceGuard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        ResourceGuard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ResourceGuard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">void</span>* resource = <span class="built_in">acquire_resource</span>();</span><br><span class="line">        <span class="function">ResourceGuard <span class="title">guard</span><span class="params">(resource)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行策略逻辑...</span></span><br><span class="line">        <span class="comment">// 资源会自动清理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3. 线程安全"></a>3. 线程安全</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeStrategyContext</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::shared_mutex mutex_;</span><br><span class="line">    std::shared_ptr&lt;Strategy&gt; strategy_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; strategy_changed_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(std::shared_ptr&lt;Strategy&gt; new_strategy)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        strategy_ = new_strategy;</span><br><span class="line">        strategy_changed_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">getStrategy</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> strategy_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">executeStrategy</span><span class="params">(Args&amp;&amp;... args)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> current_strategy = <span class="built_in">getStrategy</span>();  <span class="comment">// 获取当前策略的副本</span></span><br><span class="line">        <span class="keyword">if</span> (!current_strategy) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;No strategy set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current_strategy-&gt;<span class="built_in">execute</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasStrategyChanged</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy_changed_.<span class="built_in">exchange</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-策略工厂模式"><a href="#4-策略工厂模式" class="headerlink" title="4. 策略工厂模式"></a>4. 策略工厂模式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Strategy&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::function&lt;std::unique_ptr&lt;Strategy&gt;()&gt;&gt; creators_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ConcreteStrategy, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">registerStrategy</span><span class="params">(<span class="type">const</span> std::string&amp; name, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">        creators_[name] = [args...]() -&gt; std::unique_ptr&lt;Strategy&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ConcreteStrategy&gt;(args...);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Strategy&gt; <span class="title">createStrategy</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = creators_.<span class="built_in">find</span>(name);</span><br><span class="line">        <span class="keyword">if</span> (it != creators_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;<span class="built_in">second</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Unknown strategy: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">getAvailableStrategies</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::vector&lt;std::string&gt; names;</span><br><span class="line">        names.<span class="built_in">reserve</span>(creators_.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : creators_) &#123;</span><br><span class="line">            names.<span class="built_in">push_back</span>(pair.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasStrategy</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> creators_.<span class="built_in">find</span>(name) != creators_.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demonstrateFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StrategyFactory&lt;PaymentStrategy&gt; factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册不同的支付策略</span></span><br><span class="line">    factory.<span class="built_in">registerStrategy</span>&lt;CreditCardPayment&gt;(<span class="string">&quot;credit_card&quot;</span>, <span class="string">&quot;1234567890123456&quot;</span>, <span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">    factory.<span class="built_in">registerStrategy</span>&lt;PayPalPayment&gt;(<span class="string">&quot;paypal&quot;</span>, <span class="string">&quot;user@example.com&quot;</span>);</span><br><span class="line">    factory.<span class="built_in">registerStrategy</span>&lt;BankTransferPayment&gt;(<span class="string">&quot;bank_transfer&quot;</span>, <span class="string">&quot;987654321&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据配置或用户选择创建策略</span></span><br><span class="line">    std::string paymentMethod = <span class="string">&quot;credit_card&quot;</span>;  <span class="comment">// 可能来自配置文件</span></span><br><span class="line">    <span class="keyword">auto</span> strategy = factory.<span class="built_in">createStrategy</span>(paymentMethod);</span><br><span class="line"></span><br><span class="line">    PaymentProcessor processor;</span><br><span class="line">    processor.<span class="built_in">setPaymentStrategy</span>(std::<span class="built_in">move</span>(strategy));</span><br><span class="line">    processor.<span class="built_in">processOrder</span>(<span class="number">299.99</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-策略链模式"><a href="#5-策略链模式" class="headerlink" title="5. 策略链模式"></a>5. 策略链模式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将多个策略串联执行</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Input, <span class="keyword">typename</span> Output = Input&gt;</span><br><span class="line"><span class="keyword">class</span> StrategyChain &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Strategy&lt;Input, Output&gt;&gt;&gt; strategies_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addStrategy</span><span class="params">(std::unique_ptr&lt;Strategy&lt;Input, Output&gt;&gt; strategy)</span> </span>&#123;</span><br><span class="line">        strategies_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(strategy));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Output <span class="title">execute</span><span class="params">(Input input)</span> </span>&#123;</span><br><span class="line">        Output result = input;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; strategy : strategies_) &#123;</span><br><span class="line">            result = strategy-&gt;<span class="built_in">execute</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategies_.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategies_.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="相关设计模式对比"><a href="#相关设计模式对比" class="headerlink" title="相关设计模式对比"></a>相关设计模式对比</h1><h2 id="与工厂模式的区别"><a href="#与工厂模式的区别" class="headerlink" title="与工厂模式的区别"></a>与工厂模式的区别</h2><p>策略模式初看和工厂模式其实是有点像的,但是细看其实区别很大:</p>
<ul>
<li><strong>工厂模式</strong>：创建型模式,它的作用就是创建对象；<strong>策略模式</strong>：行为型模式,它的作用是让一个对象在许多行为中选择一种行为</li>
<li><strong>工厂模式</strong>关注对象创建,实际创建对象是被封装的,用户不可见；<strong>策略模式</strong>更多是关注行为的替换,创建对象其实是对用户可见的</li>
</ul>
<h2 id="状态模式-State-Pattern"><a href="#状态模式-State-Pattern" class="headerlink" title="状态模式 (State Pattern)"></a>状态模式 (State Pattern)</h2><p>状态模式与策略模式结构相似，但意图不同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VendingMachine</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">State</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">insertCoin</span><span class="params">(VendingMachine* machine)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">selectProduct</span><span class="params">(VendingMachine* machine)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dispenseProduct</span><span class="params">(VendingMachine* machine)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getStateName</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待投币状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitingState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertCoin</span><span class="params">(VendingMachine* machine)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectProduct</span><span class="params">(VendingMachine* machine)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Please insert coin first!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispenseProduct</span><span class="params">(VendingMachine* machine)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Please insert coin and select product first!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getStateName</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Waiting for coin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动售货机上下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VendingMachine</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;State&gt; current_state_;</span><br><span class="line">    <span class="type">int</span> coin_count_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VendingMachine</span>() &#123;</span><br><span class="line">        current_state_ = std::<span class="built_in">make_shared</span>&lt;WaitingState&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(std::shared_ptr&lt;State&gt; state)</span> </span>&#123;</span><br><span class="line">        current_state_ = state;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;State changed to: &quot;</span> &lt;&lt; state-&gt;<span class="built_in">getStateName</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertCoin</span><span class="params">()</span> </span>&#123; current_state_-&gt;<span class="built_in">insertCoin</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectProduct</span><span class="params">()</span> </span>&#123; current_state_-&gt;<span class="built_in">selectProduct</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispenseProduct</span><span class="params">()</span> </span>&#123; current_state_-&gt;<span class="built_in">dispenseProduct</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addCoin</span><span class="params">()</span> </span>&#123; coin_count_++; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeCoin</span><span class="params">()</span> </span>&#123; coin_count_--; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCoinCount</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> coin_count_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态模式 vs 策略模式：</span></span><br><span class="line"><span class="comment">// 策略模式：客户端主动选择算法，策略之间独立</span></span><br><span class="line"><span class="comment">// 状态模式：状态根据条件自动转换，状态间有依赖关系</span></span><br></pre></td></tr></table></figure>
<h2 id="模板方法模式-Template-Method-Pattern"><a href="#模板方法模式-Template-Method-Pattern" class="headerlink" title="模板方法模式 (Template Method Pattern)"></a>模板方法模式 (Template Method Pattern)</h2><p>定义算法骨架，让子类实现具体步骤：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据处理模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataProcessor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 模板方法 - 定义算法骨架</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">const</span> std::string&amp; source)</span> </span>&#123;</span><br><span class="line">        std::vector&lt;std::string&gt; data = <span class="built_in">loadData</span>(source);</span><br><span class="line">        <span class="built_in">validateData</span>(data);</span><br><span class="line">        std::vector&lt;std::string&gt; processedData = <span class="built_in">transformData</span>(data);</span><br><span class="line">        <span class="built_in">saveResults</span>(processedData);</span><br><span class="line">        <span class="built_in">cleanup</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 抽象方法 - 子类必须实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::vector&lt;std::string&gt; <span class="title">loadData</span><span class="params">(<span class="type">const</span> std::string&amp; source)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::vector&lt;std::string&gt; <span class="title">transformData</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">saveResults</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; results)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法 - 子类可以选择性重写</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">validateData</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Validating &quot;</span> &lt;&lt; data.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; records...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cleaning up resources...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CSV处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSVProcessor</span> : <span class="keyword">public</span> DataProcessor &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">loadData</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Loading data from CSV file: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;row1,data1&quot;</span>, <span class="string">&quot;row2,data2&quot;</span>, <span class="string">&quot;row3,data3&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">transformData</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; data)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Transforming CSV data...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::vector&lt;std::string&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; row : data) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="string">&quot;Processed: &quot;</span> + row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">saveResults</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; results)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Saving results to CSV format...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; result : results) &#123;</span><br><span class="line">            std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板方法模式 vs 策略模式：</span></span><br><span class="line"><span class="comment">// 模板方法：定义算法结构，变化点在具体步骤</span></span><br><span class="line"><span class="comment">// 策略模式：整个算法都可替换</span></span><br></pre></td></tr></table></figure>
<h2 id="命令模式-Command-Pattern"><a href="#命令模式-Command-Pattern" class="headerlink" title="命令模式 (Command Pattern)"></a>命令模式 (Command Pattern)</h2><p>将请求封装为对象，支持撤销、队列等操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Command</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getDescription</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文本编辑器 (接收者)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string content_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertText</span><span class="params">(<span class="type">const</span> std::string&amp; text)</span> </span>&#123; content_ += text; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteText</span><span class="params">(<span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= content_.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            content_.<span class="built_in">erase</span>(content_.<span class="built_in">length</span>() - length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getContent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> content_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入文本命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InsertCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TextEditor* editor_;</span><br><span class="line">    std::string text_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">InsertCommand</span>(TextEditor* editor, <span class="type">const</span> std::string&amp; text)</span><br><span class="line">        : <span class="built_in">editor_</span>(editor), <span class="built_in">text_</span>(text) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; editor_-&gt;<span class="built_in">insertText</span>(text_); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; editor_-&gt;<span class="built_in">deleteText</span>(text_.<span class="built_in">length</span>()); &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getDescription</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Insert: &#x27;&quot;</span> + text_ + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令调用者 (支持撤销)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EditorInvoker</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;std::shared_ptr&lt;Command&gt;&gt; history_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeCommand</span><span class="params">(std::shared_ptr&lt;Command&gt; command)</span> </span>&#123;</span><br><span class="line">        command-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        history_.<span class="built_in">push</span>(command);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Executed: &quot;</span> &lt;&lt; command-&gt;<span class="built_in">getDescription</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!history_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> command = history_.<span class="built_in">top</span>();</span><br><span class="line">            history_.<span class="built_in">pop</span>();</span><br><span class="line">            command-&gt;<span class="built_in">undo</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Undid: &quot;</span> &lt;&lt; command-&gt;<span class="built_in">getDescription</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令模式 vs 策略模式：</span></span><br><span class="line"><span class="comment">// 命令模式：封装请求，支持撤销、日志、队列</span></span><br><span class="line"><span class="comment">// 策略模式：封装算法，运行时替换行为</span></span><br></pre></td></tr></table></figure>
<h2 id="各模式对比总结"><a href="#各模式对比总结" class="headerlink" title="各模式对比总结"></a>各模式对比总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>意图</th>
<th>何时使用</th>
<th>与策略模式区别</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>策略模式</strong></td>
<td>封装算法家族，使它们可以互换</td>
<td>有多种方式实现同一功能</td>
<td>基准模式</td>
</tr>
<tr>
<td><strong>状态模式</strong></td>
<td>对象行为随内部状态改变</td>
<td>对象行为依赖于状态，且状态间有转换</td>
<td>状态自动转换 vs 客户端选择策略</td>
</tr>
<tr>
<td><strong>模板方法</strong></td>
<td>定义算法骨架，延迟步骤到子类</td>
<td>算法结构固定，但某些步骤实现变化</td>
<td>继承 vs 组合</td>
</tr>
<tr>
<td><strong>命令模式</strong></td>
<td>将请求封装为对象</td>
<td>需要参数化、排队、撤销请求</td>
<td>封装请求 vs 封装算法</td>
</tr>
</tbody>
</table>
</div>
<h1 id="常见问题和陷阱"><a href="#常见问题和陷阱" class="headerlink" title="常见问题和陷阱"></a>常见问题和陷阱</h1><h2 id="常见问题解答-FAQ"><a href="#常见问题解答-FAQ" class="headerlink" title="常见问题解答 (FAQ)"></a>常见问题解答 (FAQ)</h2><h3 id="Q1-策略模式会增加太多类吗？"><a href="#Q1-策略模式会增加太多类吗？" class="headerlink" title="Q1: 策略模式会增加太多类吗？"></a>Q1: 策略模式会增加太多类吗？</h3><p><strong>A:</strong> 确实会增加类的数量，但这是值得的：</p>
<ul>
<li>每个策略职责单一，易于理解和测试</li>
<li>可以使用Lambda表达式或std::function减少简单策略的类数量</li>
<li>复杂策略确实需要独立的类来管理</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单策略用Lambda</span></span><br><span class="line">strategies_[<span class="string">&quot;simple&quot;</span>] = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复杂策略用独立类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComplexStrategy</span> : <span class="keyword">public</span> Strategy &#123;</span><br><span class="line">    <span class="comment">// 复杂的状态和逻辑</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Q2-什么时候不应该使用策略模式？"><a href="#Q2-什么时候不应该使用策略模式？" class="headerlink" title="Q2: 什么时候不应该使用策略模式？"></a>Q2: 什么时候不应该使用策略模式？</h3><p><strong>A:</strong> 在以下情况下避免使用策略模式：</p>
<ul>
<li>算法很简单，只有2-3个分支</li>
<li>策略之间有复杂的依赖关系</li>
<li>算法变化很少，不需要运行时切换</li>
<li>团队成员不熟悉设计模式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单场景，直接用条件判断更合适</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processOrder</span><span class="params">(OrderType type, Order&amp; order)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == OrderType::PREMIUM) &#123;</span><br><span class="line">        order.<span class="built_in">applyDiscount</span>(<span class="number">0.1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        order.<span class="built_in">applyDiscount</span>(<span class="number">0.05</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Q3-如何选择虚函数还是模板实现？"><a href="#Q3-如何选择虚函数还是模板实现？" class="headerlink" title="Q3: 如何选择虚函数还是模板实现？"></a>Q3: 如何选择虚函数还是模板实现？</h3><p><strong>A:</strong> 选择依据：</p>
<ul>
<li><strong>虚函数</strong>：需要运行时多态，策略类型在编译时不确定</li>
<li><strong>模板</strong>：追求性能，策略类型在编译时确定，可以内联优化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行时选择 - 使用虚函数</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Strategy&gt; <span class="title">createStrategy</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="string">&quot;fast&quot;</span>) <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;FastStrategy&gt;();</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;DefaultStrategy&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时确定 - 使用模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Strategy&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWithStrategy</span><span class="params">(<span class="type">const</span> Data&amp; data)</span> </span>&#123;</span><br><span class="line">    Strategy strategy;</span><br><span class="line">    strategy.<span class="built_in">process</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见陷阱和错误"><a href="#常见陷阱和错误" class="headerlink" title="常见陷阱和错误"></a>常见陷阱和错误</h2><h3 id="陷阱1-策略接口设计过于宽泛"><a href="#陷阱1-策略接口设计过于宽泛" class="headerlink" title="陷阱1: 策略接口设计过于宽泛"></a>陷阱1: 策略接口设计过于宽泛</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 不好的设计</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BadStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doSomething</span><span class="params">(<span class="type">void</span>* data)</span> </span>= <span class="number">0</span>;  <span class="comment">// 参数类型不明确</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>= <span class="number">0</span>;               <span class="comment">// 返回值含义不清</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 好的设计</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodStrategy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> CompressionResult <span class="title">compress</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; input)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getCompressionRatio</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="陷阱2-忘记处理异常安全"><a href="#陷阱2-忘记处理异常安全" class="headerlink" title="陷阱2: 忘记处理异常安全"></a>陷阱2: 忘记处理异常安全</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 有问题的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeContext</span> &#123;</span><br><span class="line">    Strategy* strategy_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(Strategy* s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> strategy_;  <span class="comment">// 如果s构造失败，原策略已删除</span></span><br><span class="line">        strategy_ = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 异常安全的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeContext</span> &#123;</span><br><span class="line">    std::unique_ptr&lt;Strategy&gt; strategy_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(std::unique_ptr&lt;Strategy&gt; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s) &#123;  <span class="comment">// 先检查新策略有效性</span></span><br><span class="line">            strategy_ = std::<span class="built_in">move</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="陷阱3-内存泄漏风险"><a href="#陷阱3-内存泄漏风险" class="headerlink" title="陷阱3: 内存泄漏风险"></a>陷阱3: 内存泄漏风险</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 容易内存泄漏</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeakyContext</span> &#123;</span><br><span class="line">    Strategy* strategy_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(Strategy* s)</span> </span>&#123; strategy_ = s; &#125;</span><br><span class="line">    <span class="comment">// 忘记在析构函数中删除strategy_</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 使用智能指针自动管理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeContext</span> &#123;</span><br><span class="line">    std::unique_ptr&lt;Strategy&gt; strategy_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(std::unique_ptr&lt;Strategy&gt; s)</span> </span>&#123;</span><br><span class="line">        strategy_ = std::<span class="built_in">move</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自动清理，无需手动delete</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="陷阱4-线程安全问题"><a href="#陷阱4-线程安全问题" class="headerlink" title="陷阱4: 线程安全问题"></a>陷阱4: 线程安全问题</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 线程不安全</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeContext</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;Strategy&gt; strategy_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(std::shared_ptr&lt;Strategy&gt; s)</span> </span>&#123;</span><br><span class="line">        strategy_ = s;  <span class="comment">// 多线程下可能导致竞态条件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy_-&gt;<span class="built_in">process</span>();  <span class="comment">// strategy_可能在这时被另一线程修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 线程安全</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeContext</span> &#123;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mutex_;</span><br><span class="line">    std::shared_ptr&lt;Strategy&gt; strategy_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setStrategy</span><span class="params">(std::shared_ptr&lt;Strategy&gt; s)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        strategy_ = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::shared_ptr&lt;Strategy&gt; current_strategy;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            current_strategy = strategy_;  <span class="comment">// 复制策略指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current_strategy) &#123;</span><br><span class="line">            current_strategy-&gt;<span class="built_in">process</span>();  <span class="comment">// 在锁外执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="陷阱5-过度设计"><a href="#陷阱5-过度设计" class="headerlink" title="陷阱5: 过度设计"></a>陷阱5: 过度设计</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 过度设计 - 为简单逻辑使用策略模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OverEngineered</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum class</span> <span class="title class_">MathOperation</span> &#123; ADD, SUBTRACT &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, MathOperation op)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建复杂的策略系统来处理简单的加减法</span></span><br><span class="line">        <span class="keyword">auto</span> factory = std::<span class="built_in">make_unique</span>&lt;MathStrategyFactory&gt;();</span><br><span class="line">        <span class="keyword">auto</span> strategy = factory-&gt;<span class="built_in">createStrategy</span>(op);</span><br><span class="line">        <span class="keyword">return</span> strategy-&gt;<span class="built_in">execute</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 简单直接</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, MathOperation op)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> MathOperation::ADD: <span class="keyword">return</span> a + b;</span><br><span class="line">            <span class="keyword">case</span> MathOperation::SUBTRACT: <span class="keyword">return</span> a - b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="最佳实践总结"><a href="#最佳实践总结" class="headerlink" title="最佳实践总结"></a>最佳实践总结</h2><ol>
<li><strong>接口设计</strong>：保持接口小而专注，避免上帝接口</li>
<li><strong>内存管理</strong>：使用智能指针，避免手动内存管理</li>
<li><strong>异常安全</strong>：确保策略切换过程中的异常安全</li>
<li><strong>线程安全</strong>：多线程环境下保护策略对象的访问</li>
<li><strong>性能考虑</strong>：频繁调用时考虑使用模板而非虚函数</li>
<li><strong>适度使用</strong>：不要为简单问题过度设计</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然也不要盲目追求设计模式,在行为类型并不多时,直接使用条件判断更加合理。</p>
<h2 id="策略模式对比表"><a href="#策略模式对比表" class="headerlink" title="策略模式对比表"></a>策略模式对比表</h2><div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>策略模式</th>
<th>条件判断</th>
</tr>
</thead>
<tbody>
<tr>
<td>扩展性</td>
<td>优秀</td>
<td>较差</td>
</tr>
<tr>
<td>可读性</td>
<td>良好</td>
<td>一般</td>
</tr>
<tr>
<td>性能</td>
<td>虚函数调用开销</td>
<td>条件判断开销</td>
</tr>
<tr>
<td>复杂度</td>
<td>较高</td>
<td>较低</td>
</tr>
</tbody>
</table>
</div>
<p>选择设计模式时应考虑：</p>
<ol>
<li><strong>复杂度</strong>：模式是否确实简化了设计？</li>
<li><strong>可维护性</strong>：是否更容易添加新功能？</li>
<li><strong>性能</strong>：是否有不可接受的性能损失？</li>
<li><strong>团队理解</strong>：团队是否熟悉该模式？</li>
</ol>

            </div>



</div>

   <div class="tag-cloud-tags">
    <a href="/tags/CMakeLists/" style="font-size: 10px; color: #f38181">CMakeLists</a> <a href="/tags/Eigen/" style="font-size: 10px; color: #f38181">Eigen</a> <a href="/tags/FCPX/" style="font-size: 10px; color: #f38181">FCPX</a> <a href="/tags/GNU/" style="font-size: 10px; color: #f38181">GNU</a> <a href="/tags/Gazebo/" style="font-size: 10px; color: #f38181">Gazebo</a> <a href="/tags/Git/" style="font-size: 10px; color: #f38181">Git</a> <a href="/tags/Interest/" style="font-size: 10px; color: #f38181">Interest</a> <a href="/tags/IsaacLab/" style="font-size: 10.83px; color: #eb8988">IsaacLab</a> <a href="/tags/KDL/" style="font-size: 10.83px; color: #eb8988">KDL</a> <a href="/tags/Life/" style="font-size: 10px; color: #f38181">Life</a> <a href="/tags/Linux/" style="font-size: 10.83px; color: #eb8988">Linux</a> <a href="/tags/Matrix/" style="font-size: 10px; color: #f38181">Matrix</a> <a href="/tags/ODE/" style="font-size: 10px; color: #f38181">ODE</a> <a href="/tags/PPO/" style="font-size: 10.83px; color: #eb8988">PPO</a> <a href="/tags/QoS/" style="font-size: 10px; color: #f38181">QoS</a> <a href="/tags/ROS/" style="font-size: 12.5px; color: #dc9996">ROS</a> <a href="/tags/Ros/" style="font-size: 10px; color: #f38181">Ros</a> <a href="/tags/UML/" style="font-size: 10px; color: #f38181">UML</a> <a href="/tags/Ubuntu/" style="font-size: 10px; color: #f38181">Ubuntu</a> <a href="/tags/VcXsrv/" style="font-size: 10px; color: #f38181">VcXsrv</a> <a href="/tags/algorithm/" style="font-size: 10.83px; color: #eb8988">algorithm</a> <a href="/tags/algorithms/" style="font-size: 10px; color: #f38181">algorithms</a> <a href="/tags/axis-angle/" style="font-size: 10px; color: #f38181">axis-angle</a> <a href="/tags/bode/" style="font-size: 10px; color: #f38181">bode</a> <a href="/tags/c/" style="font-size: 10px; color: #f38181">c++</a> <a href="/tags/calibration/" style="font-size: 10px; color: #f38181">calibration</a> <a href="/tags/chrome/" style="font-size: 10px; color: #f38181">chrome</a> <a href="/tags/control/" style="font-size: 13.33px; color: #d4a19c">control</a> <a href="/tags/cpp/" style="font-size: 17.5px; color: #adc9bf">cpp</a> <a href="/tags/dB/" style="font-size: 10px; color: #f38181">dB</a> <a href="/tags/data-struct/" style="font-size: 10px; color: #f38181">data_struct</a> <a href="/tags/dots/" style="font-size: 15.83px; color: #bcb9b1">dots</a> <a href="/tags/figure/" style="font-size: 10px; color: #f38181">figure</a> <a href="/tags/gdb/" style="font-size: 10px; color: #f38181">gdb</a> <a href="/tags/git/" style="font-size: 10px; color: #f38181">git</a> <a href="/tags/latex/" style="font-size: 10.83px; color: #eb8988">latex</a> <a href="/tags/launch/" style="font-size: 10px; color: #f38181">launch</a> <a href="/tags/life/" style="font-size: 16.67px; color: #b4c1b8">life</a> <a href="/tags/linux/" style="font-size: 18.33px; color: #a5d1c5">linux</a> <a href="/tags/mac/" style="font-size: 10px; color: #f38181">mac</a> <a href="/tags/math/" style="font-size: 14.17px; color: #cca9a3">math</a> <a href="/tags/matlab/" style="font-size: 11.67px; color: #e3918f">matlab</a> <a href="/tags/memory/" style="font-size: 15px; color: #c4b1aa">memory</a> <a href="/tags/motor/" style="font-size: 10.83px; color: #eb8988">motor</a> <a href="/tags/moveit/" style="font-size: 10px; color: #f38181">moveit</a> <a href="/tags/operator/" style="font-size: 10px; color: #f38181">operator</a> <a href="/tags/optimal-algorithm/" style="font-size: 10px; color: #f38181">optimal algorithm</a> <a href="/tags/python/" style="font-size: 15px; color: #c4b1aa">python</a> <a href="/tags/robot/" style="font-size: 12.5px; color: #dc9996">robot</a> <a href="/tags/robotics/" style="font-size: 14.17px; color: #cca9a3">robotics</a> <a href="/tags/ros/" style="font-size: 15px; color: #c4b1aa">ros</a> <a href="/tags/ros2/" style="font-size: 11.67px; color: #e3918f">ros2</a> <a href="/tags/rtb/" style="font-size: 10px; color: #f38181">rtb</a> <a href="/tags/simulation/" style="font-size: 10.83px; color: #eb8988">simulation</a> <a href="/tags/stl/" style="font-size: 10px; color: #f38181">stl</a> <a href="/tags/thread/" style="font-size: 10.83px; color: #eb8988">thread</a> <a href="/tags/tools/" style="font-size: 19.17px; color: #9dd9cc">tools</a> <a href="/tags/twist/" style="font-size: 10px; color: #f38181">twist</a> <a href="/tags/urdf/" style="font-size: 10px; color: #f38181">urdf</a> <a href="/tags/valgrind/" style="font-size: 10px; color: #f38181">valgrind</a> <a href="/tags/velocity/" style="font-size: 10px; color: #f38181">velocity</a> <a href="/tags/vim/" style="font-size: 14.17px; color: #cca9a3">vim</a> <a href="/tags/web/" style="font-size: 10px; color: #f38181">web</a> <a href="/tags/work/" style="font-size: 20px; color: #95e1d3">work</a> <a href="/tags/wsl/" style="font-size: 10px; color: #f38181">wsl</a> <a href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" style="font-size: 10.83px; color: #eb8988">强化学习</a> <a href="/tags/%E9%85%8D%E7%BD%AE%E7%B1%BB/" style="font-size: 10.83px; color: #eb8988">配置类</a>
</div>



<div align="center"> 
    <li id="footer-info-copyright">网站内容采用<a class="external" rel="nofollow noopener" target="_blank" href="https://www.gnu.org/copyleft/fdl.html">GNU自由文档许可证3或更高版本</a>授权</li> <img src="https://licensebuttons.net/l/by-nc-sa/3.0/88x31.png" alt="知识共享许可协议">



        </div>
    </div>
</body>


</html>
