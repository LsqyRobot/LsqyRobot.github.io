<!DOCTYPE HTML>
<html>

<head>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="bookmark"  type="image/x-icon"  href="/img/favicon.ico"/>
	<link rel="shortcut icon" href="/img/favicon.ico">
		<!-- Modified by lsqyRobot -->
    <title>
    Beyond The Memory
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="google-site-verification" content="Mbr82TZaQktpHzJ9Wt0AZ4B9JFdVUi1Xjxs8gf20DDM" />
    <link rel="stylesheet" href="/css/timeLine.css" />
    <link rel="stylesheet" href="/css/lsqy_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="mathematica,robotics,manipulator,ros,vim,matlab,C/C++,python,git,control theory,lsqyRobot" />
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url(https://api.dujin.org/bing/1366.php) center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/dytitle.js"></script>
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/fireworks.js"></script>
    <script src="/js/codeBlockFuction.js"></script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>
		


<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<body class="is-loading">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="wrapper" class="fade-in">
        <header id="header">
    <a href="/" class="logo">dots</a>
</header>

        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow"><img src="/img/home.png"></a>
	        </li>

			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1"><img src="/img/folder.png"></a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/Control/">Control</a></li><li><a class="category-link" href="/categories/Git/">Git</a></li><li><a class="category-link" href="/categories/Life/">Life</a></li><li><a class="category-link" href="/categories/Linux/">Linux</a></li><li><a class="category-link" href="/categories/Matlab/">Matlab</a></li><li><a class="category-link" href="/categories/Robot/">Robot</a></li><li><a class="category-link" href="/categories/VS/">VS</a></li><li><a class="category-link" href="/categories/Work/">Work</a></li><li><a class="category-link" href="/categories/latex/">latex</a></li><li><a class="category-link" href="/categories/life/">life</a></li><li><a class="category-link" href="/categories/math/">math</a></li><li><a class="category-link" href="/categories/ros/">ros</a></li><li><a class="category-link" href="/categories/rtb/">rtb</a></li><li><a class="category-link" href="/categories/tools/">tools</a></li><li><a class="category-link" href="/categories/work/">work</a>
	                    </ul>
	        </li>
	        


	        <!-- about 关于我   --> 
			<li>
	        
	            <a href="/about/" ><img src="/img/about.png"></a>
	        
			</li>



	        <!-- about 关于我的朋友   --> 
			<li>
	        
	            <a href="/friend/" ><img src="/img/friend.png"></a>
	        
			</li>




	        <!-- about 关于格言   --> 
			<li>
	        
	            <a href="/quote/" ><img src="/img/quote.png"></a>
	        
			</li>




	        <!-- tag --> 
			<li>
	        
			</li>










            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
			</ul>
</nav>


        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(/img/postImg/algorithm0/tree-736885_1280.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >算法学习笔记(一)</h2></a>
            </div>

            <div class="typo" style="padding: 3rem;">
                <!-- vim-markdown-toc GFM -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#常见的大-o-运行时间">常见的大 O 运行时间</a></li>
<li><a href="#二分查找">二分查找</a></li>
<li><a href="#选择排序">选择排序</a></li>
<li><a href="#递归">递归</a></li>
<li><a href="#快速排序">快速排序</a></li>
<li><a href="#哈希表">哈希表</a></li>
<li><a href="#广度优先搜索">广度优先搜索</a></li>
<li><a href="#参考">参考</a></li>
</ul>
<!-- vim-markdown-toc -->
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算法的重要性不言而喻，看到好的算法往往使得人眼前一亮，不由衷的感受到人与人之间的差距之大。这里仅作为自己的学习笔记，为了尽快的掌握算法而非拘泥于数据结构的细节，尽量选择以python作为练习算法的语言工具。</p>
<h1 id="常见的大-O-运行时间"><a href="#常见的大-O-运行时间" class="headerlink" title="常见的大 O 运行时间"></a>常见的大 O 运行时间</h1><p>下面按从快到慢的顺序列出了经常会遇到的5种大O运行时间。</p>
<p>1, <em>O</em>(log <em>n</em>)，也叫对数时间，这样的算法包括二分查找。</p>
<p>2, <em>O</em>(<em>n</em>)，也叫线性时间，这样的算法包括简单查找。</p>
<p>3,<em>O</em>(<em>n</em> <em> log </em>n*)，这样的算法包括快速排序。</p>
<p>4，<em>O</em>(n^2)，这样的算法包括选择排序。</p>
<p>5，<em>O</em>(<em>n</em>!)，这样的算法包括旅行商问题的解决方案。</p>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>仅当列表是有序的时候，二分查找才管用。因为这个思路比较简单，却是非常非常有用的一个算法，在日常生活中随处可见。是一种在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/有序数对">有序数组</a>中查找某一特定元素的搜索<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/算法">算法</a>。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>
<p>具体的python代码如下</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">def binarySearch(myList,<span class="keyword">item</span>):</span><br><span class="line">	low = <span class="number">0</span></span><br><span class="line">	high = <span class="built_in">len</span>(myList) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> low &lt;= high:</span><br><span class="line">		<span class="keyword">mid</span> = (low + high) / <span class="number">2</span>  <span class="comment">#为了防止益处，也可以这么写： low + (high - low) / 2 </span></span><br><span class="line">		guess = myList[<span class="keyword">mid</span>]</span><br><span class="line">		<span class="keyword">if</span> guess == <span class="keyword">item</span>:</span><br><span class="line">			<span class="literal">return</span> <span class="keyword">mid</span></span><br><span class="line">		<span class="keyword">if</span> guess &gt; <span class="keyword">item</span>:</span><br><span class="line">			high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">	<span class="literal">return</span> None</span><br></pre></td></tr></table></figure>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>算法思想</strong>：首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。主要分为三个过程</p>
<p>1， 从原序列中找到最小值，与数组第一个元素交换；</p>
<p>2，除第一个元素外，从剩下未排序的序列中找到最小值，与数组第二个元素交换；</p>
<p>3，共N-1趟，每趟都找到未排序的最小值，放到已排序的序列后面。</p>
<p><strong>时间、空间复杂度及稳定性分析：</strong></p>
<p>1，最好时间复杂度：最好情况是输入序列已经升序排列，需要比较n<em>(n-1)/2次，但不需要交换元素，即交换次数为：0；所以<strong>最好时间复杂度</strong>为<em>*O(n^2)</em></em>。</p>
<p>2， 最坏时间复杂度：最坏情况是输入序列是逆序的，则每一趟都需要交换。即需要比较n<em>(n-1)/2次，元素交换次数为：n-1次。所以<strong>最坏时间复杂度</strong>还是<em>*O(n^2)</em></em>。</p>
<p>3，<strong>平均时间复杂度：O(n^2)</strong>。</p>
<p>4，空间复杂度：只用到一个临时变量，所以<strong>空间复杂度</strong>为<strong>O(1)</strong>；</p>
<p>5，<strong>不稳定</strong>排序。</p>
<p>具体的python代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findSmallest</span>(<span class="params">arr</span>):</span><br><span class="line">    smallest = arr[<span class="number">0</span>]  <span class="comment"># 存储最小的值</span></span><br><span class="line">    smallest_index = <span class="number">0</span>  <span class="comment"># 存储最小元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; smallest:</span><br><span class="line">            smallest = arr[i]</span><br><span class="line">            smallest_index = i</span><br><span class="line">    <span class="keyword">return</span> smallest_index</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selectionSort</span>(<span class="params">arr</span>): <span class="comment">#对数组进行排序</span></span><br><span class="line">    newArr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        smallest = findSmallest(arr)  <span class="comment">#找出数组中最小的元素，并将其加入到新数组中</span></span><br><span class="line">        newArr.append(arr.pop(smallest))</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line"></span><br><span class="line">maxNum = <span class="number">10</span></span><br><span class="line">randomList = <span class="built_in">list</span>(np.random.randint(<span class="number">1</span>,maxNum,size=<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(selectionSort(randomList))</span><br></pre></td></tr></table></figure>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归只是让解决方案更清晰，并没有性能上的优势。Leigh Caldwell在Stack Overflow上说的一句话：“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。</p>
<p><strong>编写递归函数时，必须告诉它何时停止递归</strong>。正因为如此，每个递归函数都有两部分：基线条件(base case)和递归条件(recursive case)。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>在谈快排方法的时候不得不称赞下分治的思想，现今很多在日常生活中都会采用这种思想去处理一些事，把大问题化成小问题，然后一一击破，有些像道德经中的“天下难事，必作于易”。对排序算法来说，最简单的数组是根本不需要排序的数组。因此，基线条件为数组为空或只包含一个元素。在这种情况下，只需原样返回数组——根本就不用排序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">arr</span>):</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<p>对包含两个元素的数组进行排序也很容易。 只需要进行比较大小判断是否交换即可</p>
<p>包含三个元素的数组呢？这个时候就可以考虑分治的思路了。首先，从数组中选择一个元素，这个元素被称为基准值(pivot)。假如就选择第一个元素作为基准值。接下来，找出比基准值小的元素以及比基准值大的元素。这被称为分区(partitioning)。现在有：</p>
<p>1，一个由所有小于基准值的数字组成的子数组；</p>
<p>2，基准值；</p>
<p>3，一个由所有大于基准值的数组组成的子数组。</p>
<p>这里只是进行了分区，得到的两个子数组是无序的。但如果这两个数组是有序的，对整个数组进行排序将非常容易。如果子数组是有序的，就可以像下面这样合并得到一个有序的数组：左边的数组 + 基准值 + 右边的数组。</p>
<p>因此对于三个元素的数组进行排序了，步骤如下</p>
<p>1)选择基准值。</p>
<p>2)将数组分成两个子数组：小于基准值的元素和大于基准值的元素。</p>
<p>3)对这两个子数组进行快速排序。</p>
<p>这样任意长的数组，都可以被分成三个部分，基准值左边，基准值，基准值右边。通过这种方式，进行递归操作，就是快排的思路了。下面给出具体的代码实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:  <span class="comment">#基线条件：为空或只包含一个元素的数组是“有序”的</span></span><br><span class="line">        <span class="keyword">return</span> arr </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = arr[<span class="number">0</span>]</span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot] <span class="comment">#由所有小于基准值的元素组成的子数组</span></span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot] <span class="comment">#由所有大于基准值的元素组成的子数组</span></span><br><span class="line">        <span class="keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br><span class="line">maxNum = <span class="number">10</span></span><br><span class="line">randomList = <span class="built_in">list</span>(np.random.randint(<span class="number">1</span>, maxNum, size=<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(quicksort(randomList))</span><br></pre></td></tr></table></figure>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p><strong>哈希表</strong>(<strong>Hash table</strong>，也叫<strong>散列表</strong>)，是根据<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/鍵">键</a>(Key)而直接访问在内存储存位置的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/数据结构">数据结构</a>。也就是说，它通过计算一个关于键值的函数，将所需查询的数据<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/映射">映射</a>到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/散列函数">散列函数</a>，存放记录的数组称做<strong>散列表</strong>。</p>
<h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>广度优先搜索算法(英语：Breadth-First Search，缩写为BFS)，又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。</p>
<p><strong>持续更新中</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] 算法图解</p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/9dragon/p/10710735.html">图解选择排序与插入排序</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/二分搜尋演算法">中文维基百科</a></p>

            </div>

<div align="center"> 
<li id="footer-info-copyright">网站内容采用<a class="external" rel="nofollow noopener" target="_blank" href="https://www.gnu.org/copyleft/fdl.html">GNU自由文档许可证3或更高版本</a>授权</li> <img src="https://licensebuttons.net/l/by-nc-sa/3.0/88x31.png" alt="知识共享许可协议"></div>


        </div>
    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>


</html>
