<!DOCTYPE HTML>
<html>

<head>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="bookmark"  type="image/x-icon"  href="/img/favicon.ico"/>
	<link rel="shortcut icon" href="/img/favicon.ico">
		<!-- Modified by lsqyRobot -->
    <title>
    Beyond The Memory
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="google-site-verification" content="Mbr82TZaQktpHzJ9Wt0AZ4B9JFdVUi1Xjxs8gf20DDM" />
    <link rel="stylesheet" href="/css/timeLine.css" />
    <link rel="stylesheet" href="/css/lsqy_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="mathematica,robotics,manipulator,ros,vim,matlab,C/C++,python,git,control theory,lsqyRobot" />
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url(https://api.dujin.org/bing/1366.php) center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/dytitle.js"></script>
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/fireworks.js"></script>
    <script src="/js/codeBlockFuction.js"></script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>
		


<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<body class="is-loading">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="wrapper" class="fade-in">
        <header id="header">
    <a href="/" class="logo">dots</a>
</header>

        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow"><img src="/img/home.png"></a>
	        </li>

			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1"><img src="/img/folder.png"></a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/Control/">Control</a></li><li><a class="category-link" href="/categories/Git/">Git</a></li><li><a class="category-link" href="/categories/Life/">Life</a></li><li><a class="category-link" href="/categories/Linux/">Linux</a></li><li><a class="category-link" href="/categories/Matlab/">Matlab</a></li><li><a class="category-link" href="/categories/Robot/">Robot</a></li><li><a class="category-link" href="/categories/VS/">VS</a></li><li><a class="category-link" href="/categories/Work/">Work</a></li><li><a class="category-link" href="/categories/latex/">latex</a></li><li><a class="category-link" href="/categories/life/">life</a></li><li><a class="category-link" href="/categories/math/">math</a></li><li><a class="category-link" href="/categories/ros/">ros</a></li><li><a class="category-link" href="/categories/rtb/">rtb</a></li><li><a class="category-link" href="/categories/tools/">tools</a></li><li><a class="category-link" href="/categories/work/">work</a>
	                    </ul>
	        </li>
	        


	        <!-- about 关于我   --> 
			<li>
	        
	            <a href="/about/" ><img src="/img/about.png"></a>
	        
			</li>



	        <!-- about 关于我的朋友   --> 
			<li>
	        
	            <a href="/friend/" ><img src="/img/friend.png"></a>
	        
			</li>




	        <!-- about 关于格言   --> 
			<li>
	        
	            <a href="/quote/" ><img src="/img/quote.png"></a>
	        
			</li>




	        <!-- tag --> 
			<li>
	        
			</li>










            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
			</ul>
</nav>


        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(/img/postImg/linux1/linux1.jpeg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >linux 学习笔记(一)</h2></a>
            </div>

            <div class="typo" style="padding: 3rem;">
                <!-- vim-markdown-toc GFM -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#linux-文件权限">Linux 文件权限</a><ul>
<li><a href="#passwd-和-chpasswd">passwd 和 chpasswd</a></li>
<li><a href="#chshchfn-和-chage">chsh、chfn 和 chage</a></li>
<li><a href="#创建分区">创建分区</a></li>
<li><a href="#使用变量">使用变量</a><ul>
<li><a href="#环境变量">环境变量</a></li>
<li><a href="#用户变量">用户变量</a></li>
</ul>
</li>
<li><a href="#命令替换">命令替换</a></li>
<li><a href="#重定向输入和输出">重定向输入和输出</a></li>
<li><a href="#输入重定向">输入重定向</a></li>
<li><a href="#管道">管道</a></li>
</ul>
</li>
<li><a href="#结构化命令">结构化命令</a><ul>
<li><a href="#if-then-语句">if-then 语句</a></li>
<li><a href="#if-then-e1se-语句">if-then-e1se 语句</a></li>
</ul>
</li>
<li><a href="#技巧">技巧</a><ul>
<li><a href="#参考">参考</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>并非教程，留给自己平时查阅使用。</p>
<h1 id="Linux-文件权限"><a href="#Linux-文件权限" class="headerlink" title="Linux 文件权限"></a>Linux 文件权限</h1><p>用户权限是通过创建用户时分配的用户 ID (User ID，通常缩写为 UID)来跟踪的。UID 是数值，每个用户都有唯的 UID，但在登录系统时用的不是 UID，而是登录名。 Linux 系统使用一个专门的文件来将用户的登录名匹配到对应的 UID 值。这个文件就是 /etc/passwd 文件，它包含了一些与用户有关的信息。 root 用户账户是 Linux 系统的管理员，固定分配给它的 UID 是 0。Linux 系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户。这些账户叫作系统账户，是系统上运行的各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个系统用户账户登录到 Linux 系统.  /etc/passwd 文件中还有很多用户登录名和 UID 之外的信息。 /etc/passwd文件的字段包含了如下信息:</p>
<details>
<summary>
展开
</summary>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>, 登录用户名</span><br><span class="line"><span class="number">2</span>, 用户密码</span><br><span class="line"><span class="number">3</span>, 用户账户的 <span class="built_in">UID</span>(数字形式)</span><br><span class="line"><span class="number">4</span>, 用户账户的组 ID (GID)(数字形式)</span><br><span class="line"><span class="number">5</span>, 用户账户的文本描述(称为备注字段)</span><br><span class="line"><span class="number">6</span>, 用户 HOME 目录的位置</span><br><span class="line"><span class="number">7</span>, 用户的默认 shell</span><br></pre></td></tr></table></figure>
</details>

<p>出于安全考虑，现在，绝大多数 Linux 系统都将用户密码保存在另一个单独的文件中(叫作 shadow 文件，位置在/etc/shadow)。只有特定的程序(比如登录程序)才能访问这个文件.  /etc/shadow 文件对 Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow 文件，这让它比起 /etc/passwd安全许多。 etc/shadow 文件为系统上的每个用户账户都保存了一条记录。 在/et/shadow 文件的每条记录中都有 9 个字段：</p>
<details>
<summary>
展开
</summary>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>, 与<span class="regexp">/etc/</span>passwd 文件中的登录名字段对应的登录名</span><br><span class="line"><span class="number">2</span>, 加密后的密码</span><br><span class="line"><span class="number">3</span>, 自上次修改密码后过去的天数密码</span><br><span class="line"><span class="number">4</span>, 多少天后才能更改密码</span><br><span class="line"><span class="number">5</span>, 多少天后必须更改密码</span><br><span class="line"><span class="number">6</span>, 密码过期前提前多少天提醒用户更改密码</span><br><span class="line"><span class="number">7</span>, 密码过期后多少天禁用用户账户</span><br><span class="line"><span class="number">8</span>, 用户账户被禁用的日期</span><br><span class="line"><span class="number">9</span>, 预留字段给将来使用</span><br></pre></td></tr></table></figure>
</details>

<h2 id="passwd-和-chpasswd"><a href="#passwd-和-chpasswd" class="headerlink" title="passwd 和 chpasswd"></a>passwd 和 chpasswd</h2><p>改变用户密码的一个简便方法就是用 passwd 命令。 如果只用 passwd 命令，它会改你自己的密码。系统上的任何用户都能改自己的密码， root 用户オ有权限改别人的密码。 -e 选项能强制用户下次登录时修改密码。可以先给用户设置一个简单的密码，之后再强制在下次登录时改成他们能记住的更复杂的密码。 如果需要为系统中的大量用户修改密码，chpasswd 命令可以事半功倍。chpasswd 命令能从标准输入自动读取登录名和密码对(由冒号分割)列表，给密码加密，然后为用户账户设置。也可以用重定向命令来将含有 userid: passwd 对的文件重定向给该命令。比如</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">chpasswd</span> &lt; users.txt</span><br></pre></td></tr></table></figure>
<h2 id="chsh、chfn-和-chage"><a href="#chsh、chfn-和-chage" class="headerlink" title="chsh、chfn 和 chage"></a>chsh、chfn 和 chage</h2><p>chsh、chfn 和 chage 工具专门用来修改特定的账户信息。chsh 命令用来快速修改默认的用户登录 shell 使用时必须用 shell 的全路径名作为参数，不能只用 shell 名。这个在使用oh-my-zsh时会用到chsh这个指令。</p>
<p>chfn 命令提供了在/etc/passwd文件的备注字段中存储信息的标准方法。chfn命令会将用于 unix 的 finger 命令的信息存进备注字段，而不是简单地存入一些随机文本(比如名字或昵称之类的)，或是将备注字段留空。finger 命令可以非常方便地査看 linux 系统上的用户信息</p>
<p>chage命令中有个好用的功能是设置账户的过期日期。有了它，你就能创建在特定日期自动过期的临时用户，再也不需要记住删除用户了！过期的账户跟锁定的账户很相似：账户仍然存在， 但用户无法用它登录。</p>
<h2 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h2><p>一开始，你必须在存储设备上创建分区来容纳文件系统。分区可以是整个硬盘，也可以是部分硬盘，以容纳虚拟目录的一部分。 fdisk 工具用来帮助管理安装在系统上的任何存储设备上的分区。它是个交互式程序，允许你输人命令来逐步完成硬盘分区操作。 要启动 fdisk 命令，必须指定要分区的存储设备的设备名，另外还得有超级用户权限。</p>
<p>有时候，创建新磁盘分区最麻烦的事情就是找出安装在 Linux 系统中的物理磁盘。Linux 采用了一种标准格式来为硬盘分配设备名称，但是你得熟悉这种格式。对于老式的 IDE 驱动器，Linux 使用的是/dev/hdx。其中x表示一个字母,具体是什么要根据驱动器的检测顺序(第一个驱动器是 a，第二个驱动器是 b，以此类推)。对于较新的 SATA 驱动器和 SCSI 驱动器, Linux使用/dev/sdx。其中的x具体是什么也要根据驱动器的检测顺序(和之前一样，第一个驱动器是 a，第二个驱动器是 b，以此类推)。在格式化分区之前，最好再检查下是否正确指定了驱动器。</p>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>shell 护着一组环境变量，用来记录特定的系统信息。比如系统的名称、登录到系统上的用户名、用户的系统 ID(也称为 UID)、用户的认主目录以及 shell 査找程序的搜索路径。可以用 set 命令来显示一份完整的当前环境变量列表。 在脚本中，可以在环境变量名称之前加上美元符($)来使用这些环境变量。</p>
<h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>除了环境变量，shell 允许在脚本中定义和使用自己的变量。定义变量允许临时存储数据并在整个脚本中使用,用户变量可以是任何由字母、数字或下划线组成的文本字符串，长度不超过 20 个。用户变量区分大小写，所以变量 Var1 和变量 var1 是不同的。 使用等号将值赋给用户量。在变量、等号和值之间不能出现空格.  shell 脚本会自动決定変量值的数据类型。在脚本的整个生命周期里，shell 脚本中定义的变量会一直保持着它们的值，但在 shell 脚本结束时会被删除掉。</p>
<p>变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。没有美元符，shell 会将量名解释成普通的文本字符串.</p>
<h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><p>shell 本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。 有两种方法可以将命令输岀赋给变量</p>
<p>1, 反引号字符(‘)<br>2, $() 格式</p>
<p>命令替换允许你将 shell 命令的输出赋给变量。尽管这看起来并不那么重要，但它却是脚本编程中的一个主要组成部分。</p>
<p>要么用一对反引号把整个命令行命令围起来:</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">test </span>= &#x27;order&#x27;</span><br></pre></td></tr></table></figure>
<p>要么使用 $() 格式</p>
<p>shell 运行命令替换符号中的命令，并将其输出赋给变量 test. 注意，赋值等号和命令替换字符之间没有空格。</p>
<h2 id="重定向输入和输出"><a href="#重定向输入和输出" class="headerlink" title="重定向输入和输出"></a>重定向输入和输出</h2><p>最基本的重定向将命令的输出发送到一个文件中。bash shell 用大于号(&gt;)来完成这项功能. 显示器上出现的命令输出会被保存到指定的输出文件中。</p>
<p>有时，你可能并不想覆盖文件原有内容，而是想要将命令的输出追加到已有文件中，比如你正在创建一个记录系统上某个操作的日志文件。在这种情况下，可以用双大于号(&gt;&gt;)来追加数据</p>
<h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p>输人重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。输入重定向符号是小于号(&lt;) </p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>有时需要将一个命令的输出作为另一个命令的输入, 这个过程叫作管道连接(piping),管道符号是单个竖线(|)。</p>
<p>管道被放在命令之间，将一个命令的输出重定向到另一个命令中</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">command</span> | <span class="keyword">command</span>2</span><br></pre></td></tr></table></figure>
<p>Linux 系统实际上会同时运行这两个命令，在系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区。</p>
<h1 id="结构化命令"><a href="#结构化命令" class="headerlink" title="结构化命令"></a>结构化命令</h1><p>过某些命令。这样的命令通常称为结构化命令(structured command/“许多程序要求对 shel 脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳</p>
<h2 id="if-then-语句"><a href="#if-then-语句" class="headerlink" title="if-then 语句"></a>if-then 语句</h2><p>最基本的结构化命令就是 if-then 语句。if-then 语句有如下格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">	commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>bash shelll 的 if 语句会运行后面的那个命令。如果该命令的退出状态码是 0(该命令成功运行)，位于 then 部分的命令就会被执行。如果该命令的退出状态码是其他值，then部分的命令就不会被执行，bash shell 继续执行脚本中的下一个命令。fi 语句用来表示 if-then 语句到此结東</p>
<h2 id="if-then-e1se-语句"><a href="#if-then-e1se-语句" class="headerlink" title="if-then-e1se 语句"></a>if-then-e1se 语句</h2><p>在if-then 语句中，不管命令是否成功执行，你都只有一种选择。如果命令返回一个非零退出状态码，bash shelll 继续执行脚本中的下一条命令。在这种情况下，如果能够执行另一组命令就好了。这正是 if-then-else 语句的作用。</p>
<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>1, 要想知道系统中有哪些文件，可以使用列表命令(ls)。本节将描述ls命令和可用来格式化 其输出信息的选项。 要把隐藏文件和普通文件及目录一起显示出来，就得用到-a参数。 -R参数是ls命令可用的另一个参数，叫作递归选项。它列出了当前目录下包含的子目录中的文件。如果目录很多，这个输出就会很长。</p>
<p>2, 在基本的输出列表中，ls命令并未输出太多每个文件的相关信息。要显示附加信息，另一个常用的参数是-l。-l参数会产生长列表格式的输出，包含了目录中每个文件的更多相关信息。 这种长列表格式的输出在每一行中列出了单个文件或目录。除了文件名，输出中还有其他有用信息。</p>
<p>3, 文件类型，比如目录(d)、文件(-)、字符型文件(c)或块设备(b); ls命令还支持在命令行中定义过滤器。它会用过滤器来决定应该在输出中显示哪些文件 或目录。 这个过滤器就是一个进行简单文本匹配的字符串。可以在要用的命令行参数之后添加这个过滤器: 当用户指定特定文件的名称作为过滤器时，ls命令只会显示该文件的信息。ls命令能够识别标准通配符，并在过滤器中用它们进行模式匹配.  问号(?)代表一个字符;星号(*)代表零个或多个字符。 在过滤器中使用星号和问号被称为文件扩展匹配(file globbing)，指的是使用通配符进行模式匹配的过程。通配符正式的名称叫作元字符通配符(metacharacter wildcards)。除了星号和问号之外，还有更多的元字符通配符可用于文件扩展匹配。可以使用中括号。 另外，可以使用感叹号(!)将不需要的内容排除在外。</p>
<p>4, tree工具。它能够以一种美观的方式展示目录、子目录及其中的文件。 file命令能够探测文件的内部，并决定文件是什么类型的: tail命令会显示文件最后几行的内容(文件的“尾部”)。默认情况下，它会显示文件的末尾10行。 可以向tail命令中加入-n参数来修改所显示的行数。 -f参数是tail命令的一个突出特性。它允许你在其他进程使用该文件时查看文件的内容。 tail命令会保持活动状态，并不断显示添加到文件中的内容。这是实时监测系统日志的绝妙方式。</p>
<p>5, head命令，顾名思义，会显示文件开头那些行的内容。默认情况下，它会显示文件前10行的文本. touch命令非常有用，可以创建空文件和变更已有文件的访问时间或修改时间。</p>
<p>6, 有时你需要知道在某个设备上还有多少磁盘空间。df命令可以让你很方便地查看所有已挂载磁盘的使用情况。 df命令有一些命令行参数可用，但基本上不会用到。一个常用的参数是-h。它会把输出中的磁盘空间按照用户易读的形式显示</p>
<p>7, 如果在卸载设备时，系统提示设备繁忙，无法卸载设备，通常是有进程还在访问该设备或使用该设备上的文件。 这时可用lsof命令获得使用它的进程信息，然后在应用中停止使用该设备或停止该进程。</p>
<p>8, du命令可以显示某个特定目录(默认情况下是当前目录)的磁盘使用情况。这一方法可用来快速判断系统上某个目录下是不是有超大文件。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Linux 命令行与 shell 脚本编程大全》</p>

            </div>

<div align="center"> 
<li id="footer-info-copyright">网站内容采用<a class="external" rel="nofollow noopener" target="_blank" href="https://www.gnu.org/copyleft/fdl.html">GNU自由文档许可证3或更高版本</a>授权</li> <img src="https://licensebuttons.net/l/by-nc-sa/3.0/88x31.png" alt="知识共享许可协议"></div>


        </div>
    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>


</html>
