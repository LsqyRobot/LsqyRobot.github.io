<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/favicon.ico"/>
	<link rel="shortcut icon" href="/img/favicon.ico">
		<!-- Modified by lsqyRobot -->
    <title>
    Beyond The Memory
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="google-site-verification" content="Mbr82TZaQktpHzJ9Wt0AZ4B9JFdVUi1Xjxs8gf20DDM" />
    <link rel="stylesheet" href="/css/lsqy_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="mathematica,robotics,manipulator,ros,vim,matlab,C/C++,python,git,control theory,lsqyRobot" />
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/myCover.png') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/dytitle.js"></script>
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/fireworks.js"></script>
    <script src="/js/codeBlockFuction.js"></script>
    <script src="/js/cursor-heart.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>
		


<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<body class="is-loading">
    <div id="wrapper" class="fade-in">
        <header id="header">
    <a href="/" class="logo">
        <span id="typewriter-text"></span>
        <span id="cursor">|</span>
    </a>
</header>

<style>
    #typewriter-text {
        display: inline;
    }

    #cursor {
        animation: blink 1s infinite;
        font-weight: 100;
        opacity: 1;
    }

    @keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
    }
</style>

<script>
(function() {
    // 打字机文本数组
    const texts = [
        
            
                "DOTS...",
            
                "CODING...",
            
                "THINKING...",
            
                "CREATING...",
            
                "EXPLORING..."
            
        
    ];

    // 打字机设置
    const settings = {
        typeSpeed: 100,
        deleteSpeed: 50,
        pauseTime: 1500,
        startDelay: 500
    };

    const typewriterElement = document.getElementById('typewriter-text');
    const cursorElement = document.getElementById('cursor');
    let textIndex = 0;
    let charIndex = 0;
    let isDeleting = false;

    function typeWriter() {
        const currentText = texts[textIndex];

        if (!isDeleting) {
            // 打字阶段
            if (charIndex < currentText.length) {
                typewriterElement.innerHTML = currentText.substring(0, charIndex + 1);
                charIndex++;
                setTimeout(typeWriter, settings.typeSpeed);
            } else {
                // 完成打字，等待一段时间后开始删除
                setTimeout(() => {
                    isDeleting = true;
                    typeWriter();
                }, settings.pauseTime);
            }
        } else {
            // 删除阶段
            if (charIndex > 0) {
                typewriterElement.innerHTML = currentText.substring(0, charIndex - 1);
                charIndex--;
                setTimeout(typeWriter, settings.deleteSpeed);
            } else {
                // 完成删除，切换到下一个文本
                isDeleting = false;
                textIndex = (textIndex + 1) % texts.length;
                setTimeout(typeWriter, 200); // 切换文本的间隔
            }
        }
    }

    // 页面加载完成后开始打字效果
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(typeWriter, settings.startDelay);
    });
})();
</script>

        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow"><img src="/img/home.png"></a>
	        </li>

			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1"><img src="/img/folder.png"></a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/ALGORITHM/">ALGORITHM</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/CONFIG/">CONFIG</a></li><li><a class="category-link" href="/categories/CONTROL/">CONTROL</a></li><li><a class="category-link" href="/categories/CPP/">CPP</a></li><li><a class="category-link" href="/categories/GIT/">GIT</a></li><li><a class="category-link" href="/categories/HEXO/">HEXO</a></li><li><a class="category-link" href="/categories/ISAAC-LAB/">ISAAC LAB</a></li><li><a class="category-link" href="/categories/LATEX/">LATEX</a></li><li><a class="category-link" href="/categories/LIFE/">LIFE</a></li><li><a class="category-link" href="/categories/LINUX/">LINUX</a></li><li><a class="category-link" href="/categories/MAC-BOOK/">MAC BOOK</a></li><li><a class="category-link" href="/categories/MATLAB/">MATLAB</a></li><li><a class="category-link" href="/categories/PYTHON/">PYTHON</a></li><li><a class="category-link" href="/categories/ROBOTICS/">ROBOTICS</a></li><li><a class="category-link" href="/categories/ROS/">ROS</a></li><li><a class="category-link" href="/categories/TOOLS/">TOOLS</a></li><li><a class="category-link" href="/categories/dataStruct/">dataStruct</a></li><li><a class="category-link" href="/categories/robotics/">robotics</a>
	                    </ul>
	        </li>
	        


	        <!-- about 关于我   --> 
			<li>
	        
	            <a href="/about/" ><img src="/img/about.png"></a>
	        
			</li>



	        <!-- about 关于我的朋友   --> 
			<li>
	        
	            <a href="/friend/" ><img src="/img/friend.png"></a>
	        
			</li>




	        <!-- about 关于格言   --> 
			<li>
	        
	            <a href="/quote/" ><img src="/img/quote.png"></a>
	        
			</li>


	        <!-- about 关于搜索栏   --> 
			<li>
	        
	            <a href="/search/" ><img src="/img/search.png"></a>
	        
			</li>



	        <!-- my lover--> 
			<li>
	        
	            <a href="/dudu/" ><img src="/img/myLoverLogo.png"></a>
	        
			</li>

	        <!-- my tags--> 
			<li>
	        
			</li>


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
			</ul>
</nav>


        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(/img/postImg/9_Python/logo/moon-4450739_1280_used.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >python 学习(一)</h2></a>
            </div>

            <div class="typo" style="padding: 3rem;">
                <!-- vim-markdown-toc GFM -->
<ul>
<li><a href="#前言">前言</a><ul>
<li><a href="#基础知识">基础知识</a></li>
<li><a href="#读取文件">读取文件</a><ul>
<li><a href="#读取文件夹下所有的文件">读取文件夹下所有的文件</a></li>
</ul>
</li>
<li><a href="#序列函数">序列函数</a><ul>
<li><a href="#enumerate函数">enumerate函数</a></li>
<li><a href="#zip函数">zip函数</a></li>
</ul>
</li>
<li><a href="#字典">字典</a><ul>
<li><a href="#用序列创建字典">用序列创建字典</a></li>
<li><a href="#有效的键类型">有效的键类型</a></li>
</ul>
</li>
<li><a href="#集合">集合</a></li>
<li><a href="#列表集合和字典推导式">列表、集合和字典推导式</a></li>
<li><a href="#python-合并字典">Python 合并字典</a></li>
<li><a href="#函数">函数</a><ul>
<li><a href="#命名空间作用域">命名空间、作用域</a></li>
<li><a href="#生成器">生成器</a></li>
<li><a href="#生成器表达式">生成器表达式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#python字符串前面加urb的含义">python字符串前面加u,r,b的含义</a><ul>
<li><a href="#文件和操作系统">文件和操作系统</a><ul>
<li><a href="#python文件打开方式">python文件打开方式</a></li>
</ul>
</li>
<li><a href="#python绘图">python绘图</a><ul>
<li><a href="#matplotlib">matplotlib</a><ul>
<li><a href="#显示中文标题">显示中文标题</a></li>
<li><a href="#seaborn-的使用">seaborn 的使用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pandas的数据结构介绍">pandas的数据结构介绍</a><ul>
<li><a href="#series">Series</a></li>
<li><a href="#dataframe">DataFrame</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#参考">参考</a></li>
</ul>
<!-- vim-markdown-toc -->
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在18年的时候就把python的基本语法过了一遍了,无奈matlab和mathematica太好用了,所以python这个工具就一直被我给冷落了,现在重新拾起。文中的内容,有些是书本里面的,有些源自于菜鸟教程和一些零散的博客所汇聚而成,仅供自己学习和参考使用。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性,需通过类提供的接口进行访问,不能用 from xxx import * 而导入。 以双下划线开头的__foo 代表类的私有成员,以双下划线开头和结尾的 __foo__ 代表 Python 里特殊方法专用的标识,如 __init__() 代表类的构造函数。</p>
</li>
<li><p>if __name__ == ‘__main__‘的意思是：当.py文件被直接运行时,if __name__ == ‘__main__‘之下的代码块将被运行；当.py文件以模块形式被导入时,if __name__ == ‘__main__‘之下的代码块不被运行。</p>
</li>
<li><p>对程序计时可用如下两种方式：</p>
<p>1)time.time() 返回的是一个浮点型类型。这里获取的也是<strong>程序的执行时间</strong>。使用方法如下所示</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">start = <span class="type">time</span>.time()</span><br><span class="line">#^_^</span><br><span class="line">end = <span class="type">time</span>.time()</span><br><span class="line">print (<span class="keyword">end</span>-<span class="keyword">start</span>)</span><br></pre></td></tr></table></figure>
<p>2) time.clock()返回程序开始或第一次被调用clock()以来的CPU时间。这里获得的是<strong>CPU的执行时间</strong>。调用方式只需要把time.time()换成 time.clock()即可。</p>
</li>
</ol>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><h3 id="读取文件夹下所有的文件"><a href="#读取文件夹下所有的文件" class="headerlink" title="读取文件夹下所有的文件"></a>读取文件夹下所有的文件</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">os</span></span><br><span class="line">fileList = <span class="built_in">os</span>.listdir(<span class="built_in">path</span>)</span><br></pre></td></tr></table></figure>
<h2 id="序列函数"><a href="#序列函数" class="headerlink" title="序列函数"></a>序列函数</h2><h3 id="enumerate函数"><a href="#enumerate函数" class="headerlink" title="enumerate函数"></a>enumerate函数</h3><p>迭代一个序列时,你可能想跟踪当前项的序号。手动的方法可能是下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> collection:</span><br><span class="line">    <span class="comment"># do something with value </span></span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>因为这么做很常见,Python内建了一个 enumerate 函数,可以返回 (i, value) 元组序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(collection): </span><br><span class="line">	<span class="comment"># do something with value</span></span><br></pre></td></tr></table></figure>
<p>当你索引数据时,使用 enumerate 的一个好方法是计算序列(唯一的) dict 映射到位置的值。</p>
<h3 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h3><p>zip 可以将多个列表、元组或其它序列成对组合成一个元组列表。zip 可以处理任意多的序列,元素的个数取决于最短的序列。zip 的常见用法之一是同时迭代多个序列,可以结合 enumerate 使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(seq1, seq2)):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;: &#123;1&#125;, &#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(i, a, b))</span><br></pre></td></tr></table></figure>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典可能是Python最为重要的数据结构。它更为常见的名字是哈希映射或关联数组。它是键值对的大小可变集合,键和值都是Python对象。创建字典的方法之一是使用大括号,用冒号分隔键和值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">empty_dict = &#123;&#125; </span><br><span class="line">d1 = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="string">&#x27;some value&#x27;</span>, <span class="string">&#x27;b&#x27;</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>可以像访问列表或元组中的元素一样,访问、插入或设定字典中的元素,也可以用检查列表和元组是否包含某个值的方法,检查字典中是否包含某个键。keys 和 values 是字典的键和值的迭代器方法。虽然键值对没有顺序,这两个方法可以用相同的顺序输出键和值：用 update 方法可以将一个字典与另一个融合： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1.update(&#123;<span class="string">&#x27;b&#x27;</span> : <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;c&#x27;</span> : <span class="number">12</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>update 方法是原地改变字典,因此任何传递给 update 的键的旧的值都会被舍弃。</p>
<h3 id="用序列创建字典"><a href="#用序列创建字典" class="headerlink" title="用序列创建字典"></a>用序列创建字典</h3><p>可能想将两个序列配对组合成字典。下面是一种写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mapping = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">zip</span>(key_list, value_list): </span><br><span class="line">	mapping[key] = value</span><br></pre></td></tr></table></figure>
<p>因为字典本质上是2元元组的集合,dict可以接受2元元组的列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mapping = <span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">5</span>), <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">5</span>))))</span><br></pre></td></tr></table></figure>
<p>下面的逻辑很常见：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> some_dict: </span><br><span class="line">	value = some_dict[key]</span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">	value = default_value</span><br></pre></td></tr></table></figure>
<p>因此,dict的方法get和pop可以取默认值进行返回,上面的if-else语句可以简写成下面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = some_dict.get(key, default_value)</span><br></pre></td></tr></table></figure>
<h3 id="有效的键类型"><a href="#有效的键类型" class="headerlink" title="有效的键类型"></a>有效的键类型</h3><p>字典的值可以是任意Python 对象,而键通常是不可变的标量类型(整数、浮点型、字符串)或元组(元组中的对象必须是不可变的)。这被称为“可哈希性”。可以用 hash 函数检测一个对象是否是可哈希的。 要用列表当做键,一种方法是将列表转化为元组,只要内部元素可以被哈希,它也就可以被哈希。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是无序的不可重复的元素的集合。可以把它当做字典,但是只有键没有值。可以用两种方式创建集合：通过 set 函数或使用尖括号 set 语句.集合支持合并、交集、差分和对称差等数学集合运算. 合并是取两个集合中不重复的元素。可以用 union 方法,或者运算符|.交集的元素包含在两个集合中。可以用 intersection 或&amp;运算符.所有逻辑集合操作都有另外的原地实现方法,可以直接用结果替代集合的内容。对于大的集合,这么做效率更高.与字典类似,集合元素通常都是不可变的。要获得类似列表的元素,必须转换成元组.</p>
<h2 id="列表、集合和字典推导式"><a href="#列表、集合和字典推导式" class="headerlink" title="列表、集合和字典推导式"></a>列表、集合和字典推导式</h2><p>列表推导式允许用户方便的从一个集合过滤元素,形成列表在传递参数的过程中还可以修改元素。形式如下</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="string">[expr for val in collection if condition]</span></span><br></pre></td></tr></table></figure>
<p>它等同于下面的 for 循环:</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="built_in">result</span> = [ ]</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> collection:</span><br><span class="line">	<span class="keyword">if</span> condition:</span><br><span class="line">		<span class="built_in">result</span>.append(<span class="type">expr</span>)</span><br></pre></td></tr></table></figure>
<p>用相似的方法,还可以推导集合和字典。字典的推导式如下所示<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">dic = &#123;<span class="built_in">key</span>: value-<span class="keyword">expr</span> <span class="keyword">for</span> value in collection if condition&#125;</span><br></pre></td></tr></table></figure><br>集合的推导式与列表很像,只不过用的是尖括号</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">set_comp</span> = &#123;expr for value in collection if condition&#125;</span><br></pre></td></tr></table></figure>
<p>与列表推导式类似,集合与字典的推导也很方便,而且使代码的读写都很容易。来看前面的字符串列表。假如我们只想要字符串的长度,用集合推导式的方法非常方便.</p>
<h2 id="Python-合并字典"><a href="#Python-合并字典" class="headerlink" title="Python 合并字典"></a>Python 合并字典</h2><p>1,使用 <code>update()</code> 方法,第二个参数合并第一个参数</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">def <span class="built_in">Merge</span>(dict1, dict2): </span><br><span class="line">    <span class="built_in">return</span>(dict2.<span class="built_in">update</span>(dict1)) </span><br></pre></td></tr></table></figure>
<p>2,  使用 <code>**</code>, 函数将参数以字典的形式导入</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">def Merge(<span class="keyword">dict1, </span><span class="keyword">dict2): </span></span><br><span class="line">    res = &#123;**<span class="keyword">dict1, </span>**<span class="keyword">dict2&#125; </span></span><br><span class="line">    return res </span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数使用 def 关键字声明,用 return 关键字返回值,如果到达函数末尾时没有遇到任何一条return语句,则返回 None。 函数可以有一些位置参数(positional)和一些关键字参数(keyword)。关键字参数通常用于指定 默认值或可选参数。</p>
<h3 id="命名空间、作用域"><a href="#命名空间、作用域" class="headerlink" title="命名空间、作用域"></a>命名空间、作用域</h3><p>函数可以访问两种不同作用域中的变量：全局(global)和局部(local)。任何在函数中赋值的变量默认都是被分配到局部命名空间(local namespace)中的。局部命名空间是在函数被调用时创建的,函数参数会立即填入该命名空间。在函数执行完毕之后,局部命名空间就会被销毁</p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>能以一种一致的方式对序列进行迭代(比如列表中的对象或文件中的行)。通过一种叫做迭代器协议 iterator protocol,它是一种使对象可迭代的通用方式)的方式实现的,一个原生的使对象可迭代的方法。生成器(generator)是构造新的迭代对象的一种简单方式。一般的函数执行之后只会返回单个值,而生成器则是以延退的方式返回一个值序列,即每返回一个值之后暂停,直到下一个值被请求时再继续。要创建一个生成器,只需将函数中的 return 替换为 yeild 即可。调用该生成器时,没有任何代码会被立即执行。直到请求元素时,它オ会开始执行其代码。</p>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>另一种更简洁的构造生成器的方法是使用生成器表达式(generator expression)。这是一种类似于列表、字典、集合推导式的生成器。其创建方式为,把列表推导式两端的方括号改成圆括号。</p>
<h1 id="python字符串前面加u-r-b的含义"><a href="#python字符串前面加u-r-b的含义" class="headerlink" title="python字符串前面加u,r,b的含义"></a>python字符串前面加u,r,b的含义</h1><p>u/U:<code>表示unicode字符串</code>。不是仅仅是针对中文, 可以针对任何的字符串,代表是对字符串进行unicode编码。一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般不带u；但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。<br>建议所有编码方式采用utf8</p>
<p>r/R:<code>非转义的原始字符串</code>。与普通字符相比,其他相对特殊的字符,其中可能包含转义字符,即那些,反斜杠加上对应字母,表示对应的特殊含义的,比如最常见的”\n”表示换行,”\t”表示Tab等。而如果是以r开头,那么说明后面的字符,都是普通的字符了,即如果是“\n”那么表示一个反斜杠字符,一个字母n,而不是表示换行了。以r开头的字符,常用于正则表达式,对应着re模块。</p>
<p>b:<code>bytes</code>。python3.x里默认的str是(py2.x里的)unicode, bytes是(py2.x)的str, b”“前缀代表的就是bytespython2.x里, b前缀没什么具体意义, 只是为了兼容python3.x的这种写法。</p>
<h2 id="文件和操作系统"><a href="#文件和操作系统" class="headerlink" title="文件和操作系统"></a>文件和操作系统</h2><p>为了打开一个文件以便读写,可以使用内置的open函数以及一个相对或绝对的文件路径。从文件中取出的行都带有完整的行结束符(EOL),因此你常常会看到下面这样的代码(得到一组<strong>没有EOL的行</strong>)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lines = [x.rstrip() <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(path)]</span><br></pre></td></tr></table></figure>
<p>如果使用open创建文件对象,一定要用close关闭它。关闭文件可以返回操作系统资源：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">f.<span class="keyword">close</span>()</span><br></pre></td></tr></table></figure>
<p>用with语句可以可以更容易地清理打开的文件：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (path) <span class="keyword">as</span> f:</span><br><span class="line">	<span class="keyword">lines</span> = [x.rstrip() <span class="keyword">for</span> x <span class="keyword">in</span> f]</span><br></pre></td></tr></table></figure>
<p>这样可以在退出代码块时,自动关闭文件。向文件写入,可以使用文件的write或writelines方法。例如,创建一个无空行版的</p>
<figure class="highlight sml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="symbol">&#x27;tmp</span>.txt&#x27;,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> <span class="keyword">handle</span>:</span><br><span class="line">	<span class="keyword">handle</span>.writelines(x for x <span class="keyword">in</span> <span class="keyword">open</span>(path) <span class="keyword">if</span> len(x) &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">open</span>(<span class="symbol">&#x27;tmp</span>.txt&#x27;) <span class="keyword">as</span> f:</span><br><span class="line">	lines = f.readlines<span class="literal">()</span></span><br></pre></td></tr></table></figure>
<p>最常用的文件方法如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法              &emsp;</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>read([size])      &emsp;</td>
<td>以字符串形式返回文件数据,可选的size参数用于说明读取的字节数</td>
</tr>
<tr>
<td>readlines([size]) &emsp;</td>
<td>将文件返回为行列表,可选参数size</td>
</tr>
<tr>
<td>write(str)        &emsp;</td>
<td>将字符串写入文件</td>
</tr>
<tr>
<td>close()           &emsp;</td>
<td>关闭句柄</td>
</tr>
<tr>
<td>flush()           &emsp;</td>
<td>清空内部I/O缓存区,并将数据强行写回磁盘</td>
</tr>
<tr>
<td>seek(pos)         &emsp;</td>
<td>移动到指定的文件位置(整数)</td>
</tr>
<tr>
<td>tell              &emsp;</td>
<td>以整数形式返回当前文件位置</td>
</tr>
<tr>
<td>closed()          &emsp;</td>
<td>如果文件已关闭,则为True</td>
</tr>
</tbody>
</table>
</div>
<p>一种更方便的方法将Unicode转换为另一种编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sink_path = <span class="string">&#x27;sink.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path) <span class="keyword">as</span> source:</span><br><span class="line">	<span class="keyword">with</span> <span class="built_in">open</span>(sink_path,<span class="string">&#x27;xt&#x27;</span>,encoding = <span class="string">&#x27;iso-88859-1&#x27;</span>) <span class="keyword">as</span> sink:</span><br><span class="line">		sink.write(source.read())</span><br></pre></td></tr></table></figure>
<p>注意,不要在二进制模式中使用seek。如果文件位置位于定义Unicode字符的字节的中间位置,读取后面会产生错误.</p>
<h3 id="python文件打开方式"><a href="#python文件打开方式" class="headerlink" title="python文件打开方式"></a>python文件打开方式</h3><p>r只读,r+读写,不创建新的文件,w新建文件只写入,w+新建读写,二者都会将文件内容清零。r+：可读可写,若文件不存在,则报错；w+: 可读可写,若文件不存在,则创建一个新的文件。a：附加写方式打开,不可读；a+: 附加读写方式打开。使用’r’一般情况下最常用的,但是在进行读取二进制文件时,可能会出现文档读取不全的现象；使用’rb’按照二进制位进行读取的,不会将读取的字节转换成字符,二进制文件用二进制读取用’rb,’rt‘模式下,python在读取文本时会自动把\r\n转换成\n,文本文件用二进制读取用‘rt’。当我们写文件时,操作系统往往不会立刻把数据写入磁盘,而是放到内存缓存起来,空闲的时候再慢慢写入。只有调用close()方法时,操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘,剩下的丢失了。</p>
<h2 id="python绘图"><a href="#python绘图" class="headerlink" title="python绘图"></a>python绘图</h2><h3 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h3><p>matplotlib 是python中最有名的绘图库,在编写较大的应用程序时使用matplotlib会更加有效。如果需要绘制某种类型的图表,在<a target="_blank" rel="noopener" href="http://matplotlib.sourceforge.net/gallery.html">http://matplotlib.sourceforge.net/gallery.html</a> 这个页面找到对应自己需要的,然后粘贴复制即可,基本上略微的修改就可以直接的拿来使用了。和matlab中的绘图十分的相似,如果熟悉matlab绘图的话,对于了解这块绘图会有十分大的帮助。有的时候不得不佩服那些粘贴复制的,带我兜兜转转,问题没解决掉,反而使得时间浪费了不少。看了<a target="_blank" rel="noopener" href="https://towardsdatascience.com/the-art-of-effective-visualization-of-multi-dimensional-data-6c7202990c57">Dipanjan Sarkar</a>的博客,绘图就是门艺术,这里就简要的说明下seaborn绘图的命令。</p>
<h4 id="显示中文标题"><a href="#显示中文标题" class="headerlink" title="显示中文标题"></a>显示中文标题</h4><p>更改编码方式以及使用本地字体,可用参考如下代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-            </span></span><br><span class="line"><span class="comment">## 上面更改编码方式,下面解决中文显示</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="seaborn-的使用"><a href="#seaborn-的使用" class="headerlink" title="seaborn 的使用"></a>seaborn 的使用</h4><p>在工作的时候遇到的问题,由于需要进行不同参数下的误差对比,所以用到了这个,这里简略的说明几个用法</p>
<ol>
<li><p>ax.set_title(‘your title’), 设置标题</p>
</li>
<li><p>f.savefig(‘yourPic.eps’, dpi=360) ,保存图片,其中dpi可以理解为设置分辨率的。</p>
</li>
<li><p>ax.invert_xaxis(), x轴内容进行转过来显示。</p>
</li>
<li><p>ax.tick_params(axis=’x’,labelsize=6),刻度调整.</p>
</li>
<li><p>sns.set(),样式控制sns.set(style=’white’,palette=’muted’,color_codes=True),style为图表的背景主题,有5种主题可以选择：darkgrid (默认), whitegrid,dark,white,ticks, palette为设置主体颜色,有6种可以选择：deep,muted,pastel,bright,dark,colorblind</p>
</li>
<li><p>用despine进行边框控制：white和ticks参数的样式,都可以删除上方和右方坐标轴上不需要的边框。despine(top=True, right=True, left=False, bottom=False, offset=None, trim=False),默认无参数的情况下,是删除上面及右边的边框。offset可设置边框的偏移距离,trim设置删除边框的范围.</p>
</li>
</ol>
<p>下面给出seaborn.heatmap详细的参数说明,主要摘抄了 <a target="_blank" rel="noopener" href="https://me.csdn.net/ztf312">计科小白兔</a>的博文</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">seaborn.heatmap(data, <span class="attribute">vmin</span>=None, <span class="attribute">vmax</span>=None, <span class="attribute">cmap</span>=None, <span class="attribute">center</span>=None, <span class="attribute">robust</span>=<span class="literal">False</span>,</span><br><span class="line"><span class="attribute">annot</span>=None, <span class="attribute">fmt</span>=<span class="string">&#x27;.2g&#x27;</span>, <span class="attribute">annotkws</span>=None, <span class="attribute">linewidths</span>=0, <span class="attribute">linecolor</span>=<span class="string">&#x27;white&#x27;</span>, <span class="attribute">cbar</span>=<span class="literal">True</span>, </span><br><span class="line"><span class="attribute">cbarkws</span>=None, <span class="attribute">cbar_ax</span>=None, <span class="attribute">square</span>=<span class="literal">False</span>, <span class="attribute">ax</span>=None, <span class="attribute">xticklabels</span>=<span class="literal">True</span>, <span class="attribute">yticklabels</span>=<span class="literal">True</span>, <span class="attribute">mask</span>=None, **kwargs) </span><br></pre></td></tr></table></figure>
<p>1,data：矩阵数据集,可以使numpy的数组(array),如果是pandas的dataframe,则df的index/column信息会分别对应到heatmap的columns和rows.<br>2,vmax,vmin, 图例中最大值和最小值的显示值,没有该参数时默认不显示.<br>3,linewidths,热力图矩阵之间的间隔大小<br>4, cmap,热力图颜色<br>5, ax,绘制图的坐标轴,否则使用当前活动的坐标轴。<br>6, annot,annotate的缩写,annot默认为False,当annot为True时,在heatmap中每个方格写入数据。<br>7, annot_kws,当annot为True时,可设置各个参数,包括大小,颜色,加粗,斜体字等：sns.heatmap(x, annot=True, ax=ax2, annot_kws={‘size’:9,’weight’:’bold’, ‘color’:’blue’})<br>8, fmt,格式设置,决定annot注释的数字格式,小数点后几位等；<br>9, <strong>cbar</strong> : 是否画一个颜色条<br>10, <strong>cbar_kws</strong> : 颜色条的参数</p>
<h2 id="pandas的数据结构介绍"><a href="#pandas的数据结构介绍" class="headerlink" title="pandas的数据结构介绍"></a>pandas的数据结构介绍</h2><p>要使用pandas,得熟悉提供的两个主要数据结构：Series和DataFrame。</p>
<h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><p>Series是一种类似于一维数组的对象,它由一组数据(各种NumPy数据类型)以及一组与之相关 的数据标签(即索引)组成,感觉和字典有一点相似。Series的字符串表现形式为：索引在左边,值在右边。由于我们没有为数据指定索引,于是会自动 创建一个0到N-1(N为数据的长度)的整数型索引。pandas的isnull和notnull函数可用于检测缺失数据。对于许多应用而言,Series最重要的一个功能是,它会根据运算的索引标签自动对齐数据。</p>
<h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>DataFrame是一个表格型的数据结构,它含有一组有序的列,每列可以是不同的值类型(数值、字 符串、布尔值等)。DataFrame既有行索引也有列索引,它可以被看做由Series组成的字典(共用 同一个索引)。DataFrame中的数据是以一个或多个二维块存放的(而不是列表、字典或别的一维数据结构),建DataFrame的办法有很多,最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典。DataFrame构造函数所能接受的各种数据如下所示。</p>
<ol>
<li>Numpy 中的集合函数</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法             &emsp;</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>unique(x)        &emsp;</td>
<td>计算 x 中的唯一元素,并返回有序结果</td>
</tr>
<tr>
<td>intersect1d(x,y) &emsp;</td>
<td>计算 x 和 y 中的公共元素,并返回有序结果</td>
</tr>
<tr>
<td>union1d(x,y)     &emsp;</td>
<td>计算 x 和 y 的并集,并返回有序结果</td>
</tr>
<tr>
<td>in1d(x,y)        &emsp;</td>
<td>得到一个表示“x 的元素是否包含于 y”的布尔型数组</td>
</tr>
<tr>
<td>setdiff1d(x,y)   &emsp;</td>
<td>集合的差,即元素在 x 中且不在 y 中</td>
</tr>
<tr>
<td>setxor1d(x,y)    &emsp;</td>
<td>集合的对称差,即存在于一个数组中但不同时存在于两个数组中的元素</td>
</tr>
</tbody>
</table>
</div>
<p>伪随机数生成,部分 numpy random 函数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数        &emsp;</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>seed        &emsp;</td>
<td>确定随机数生成器的种子</td>
</tr>
<tr>
<td>permutation &emsp;</td>
<td>返回一个序列的随机排列或返回一个随机排列的范围</td>
</tr>
<tr>
<td>shuffle     &emsp;</td>
<td>对一个序列就地随机排列</td>
</tr>
<tr>
<td>rand        &emsp;</td>
<td>产生均匀分布的样本值</td>
</tr>
<tr>
<td>randint     &emsp;</td>
<td>从给定的上下限范围内随机选取整数</td>
</tr>
<tr>
<td>randn       &emsp;</td>
<td>产生正态分布(平均值为 0, 标准差为 1) 的样本值,类似于 MATLAB 接口</td>
</tr>
<tr>
<td>binomial    &emsp;</td>
<td>产生二项分布的样本值</td>
</tr>
<tr>
<td>normal      &emsp;</td>
<td>产生正态(高斯)分布的样本值</td>
</tr>
<tr>
<td>beta        &emsp;</td>
<td>产生 beta 分布的样本值</td>
</tr>
<tr>
<td>chisquare   &emsp;</td>
<td>产生卡方分布的样本值</td>
</tr>
<tr>
<td>gamma       &emsp;</td>
<td>产生 Gamma 分布的样本值</td>
</tr>
<tr>
<td>uniform     &emsp;</td>
<td>产生在[0,1) 中均匀分布的样本值</td>
</tr>
</tbody>
</table>
</div>
<p>这里重点的说一下如何使用 <code>pandas</code> + <code>DataFrame</code> 输出 <code>xlsx</code> 文件,这也是自己在工作中经常会遇到的一个问题,这里字典就会很有用处。这里先介绍下批量生成字符串的一种很简单的方法,比如自己在处理运动指令IP值时,对于机器人来说,有六个轴的,自己写 <code>IP1,IP2,IP3 ...</code>, 久而久之就会很烦的。。。。下面这样就会使得问题变得很简单(类似的,对于字符串可用 <code>%s</code> 来替代)</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">indexNames</span> = [<span class="string">&#x27;IP%d&#x27;</span>%i for i in range(<span class="number">1</span>,<span class="number">7</span>) ]</span><br></pre></td></tr></table></figure>
<p>这样配合着字典,比如</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">  dict<span class="selector-attr">[indexNames[i]</span>] = IP<span class="selector-attr">[:,i]</span>        #这里IP的矩阵大小为N*<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>再利用</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(dic)</span><br><span class="line">df.to_excel(<span class="string">&#x27;test.xlsx&#x27;</span>,<span class="attribute">index</span>=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>即可将结果输出到 <code>*.xlsx</code> 文件中去了, 这里忘了交代个事,就是需要引入相关的包</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="title">from</span> pandas <span class="keyword">import</span> DataFrame</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]  <a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python-merging-two-dictionaries.html">菜鸟教程</a></p>

            </div>



</div>

   <div class="tag-cloud-tags">
    <a href="/tags/CMakeLists/" style="font-size: 10px; color: #f38181">CMakeLists</a> <a href="/tags/Eigen/" style="font-size: 10px; color: #f38181">Eigen</a> <a href="/tags/FCPX/" style="font-size: 10px; color: #f38181">FCPX</a> <a href="/tags/GNU/" style="font-size: 10px; color: #f38181">GNU</a> <a href="/tags/Gazebo/" style="font-size: 10px; color: #f38181">Gazebo</a> <a href="/tags/Git/" style="font-size: 10px; color: #f38181">Git</a> <a href="/tags/Interest/" style="font-size: 10px; color: #f38181">Interest</a> <a href="/tags/IsaacLab/" style="font-size: 10.83px; color: #eb8988">IsaacLab</a> <a href="/tags/KDL/" style="font-size: 10.83px; color: #eb8988">KDL</a> <a href="/tags/Life/" style="font-size: 10px; color: #f38181">Life</a> <a href="/tags/Linux/" style="font-size: 10.83px; color: #eb8988">Linux</a> <a href="/tags/Matrix/" style="font-size: 10px; color: #f38181">Matrix</a> <a href="/tags/ODE/" style="font-size: 10px; color: #f38181">ODE</a> <a href="/tags/PPO/" style="font-size: 10.83px; color: #eb8988">PPO</a> <a href="/tags/QoS/" style="font-size: 10px; color: #f38181">QoS</a> <a href="/tags/ROS/" style="font-size: 12.5px; color: #dc9996">ROS</a> <a href="/tags/Ros/" style="font-size: 10px; color: #f38181">Ros</a> <a href="/tags/UML/" style="font-size: 10px; color: #f38181">UML</a> <a href="/tags/Ubuntu/" style="font-size: 10px; color: #f38181">Ubuntu</a> <a href="/tags/VcXsrv/" style="font-size: 10px; color: #f38181">VcXsrv</a> <a href="/tags/algorithm/" style="font-size: 10.83px; color: #eb8988">algorithm</a> <a href="/tags/algorithms/" style="font-size: 10px; color: #f38181">algorithms</a> <a href="/tags/axis-angle/" style="font-size: 10px; color: #f38181">axis-angle</a> <a href="/tags/bode/" style="font-size: 10px; color: #f38181">bode</a> <a href="/tags/c/" style="font-size: 10px; color: #f38181">c++</a> <a href="/tags/calibration/" style="font-size: 10px; color: #f38181">calibration</a> <a href="/tags/chrome/" style="font-size: 10px; color: #f38181">chrome</a> <a href="/tags/control/" style="font-size: 13.33px; color: #d4a19c">control</a> <a href="/tags/cpp/" style="font-size: 17.5px; color: #adc9bf">cpp</a> <a href="/tags/dB/" style="font-size: 10px; color: #f38181">dB</a> <a href="/tags/data-struct/" style="font-size: 10px; color: #f38181">data_struct</a> <a href="/tags/dots/" style="font-size: 15.83px; color: #bcb9b1">dots</a> <a href="/tags/figure/" style="font-size: 10px; color: #f38181">figure</a> <a href="/tags/gdb/" style="font-size: 10px; color: #f38181">gdb</a> <a href="/tags/git/" style="font-size: 10px; color: #f38181">git</a> <a href="/tags/latex/" style="font-size: 10.83px; color: #eb8988">latex</a> <a href="/tags/launch/" style="font-size: 10px; color: #f38181">launch</a> <a href="/tags/life/" style="font-size: 16.67px; color: #b4c1b8">life</a> <a href="/tags/linux/" style="font-size: 18.33px; color: #a5d1c5">linux</a> <a href="/tags/mac/" style="font-size: 10px; color: #f38181">mac</a> <a href="/tags/math/" style="font-size: 14.17px; color: #cca9a3">math</a> <a href="/tags/matlab/" style="font-size: 11.67px; color: #e3918f">matlab</a> <a href="/tags/memory/" style="font-size: 15px; color: #c4b1aa">memory</a> <a href="/tags/motor/" style="font-size: 10.83px; color: #eb8988">motor</a> <a href="/tags/moveit/" style="font-size: 10px; color: #f38181">moveit</a> <a href="/tags/operator/" style="font-size: 10px; color: #f38181">operator</a> <a href="/tags/optimal-algorithm/" style="font-size: 10px; color: #f38181">optimal algorithm</a> <a href="/tags/python/" style="font-size: 15px; color: #c4b1aa">python</a> <a href="/tags/robot/" style="font-size: 12.5px; color: #dc9996">robot</a> <a href="/tags/robotics/" style="font-size: 14.17px; color: #cca9a3">robotics</a> <a href="/tags/ros/" style="font-size: 15px; color: #c4b1aa">ros</a> <a href="/tags/ros2/" style="font-size: 11.67px; color: #e3918f">ros2</a> <a href="/tags/rtb/" style="font-size: 10px; color: #f38181">rtb</a> <a href="/tags/simulation/" style="font-size: 10.83px; color: #eb8988">simulation</a> <a href="/tags/stl/" style="font-size: 10px; color: #f38181">stl</a> <a href="/tags/thread/" style="font-size: 10.83px; color: #eb8988">thread</a> <a href="/tags/tools/" style="font-size: 19.17px; color: #9dd9cc">tools</a> <a href="/tags/twist/" style="font-size: 10px; color: #f38181">twist</a> <a href="/tags/urdf/" style="font-size: 10px; color: #f38181">urdf</a> <a href="/tags/valgrind/" style="font-size: 10px; color: #f38181">valgrind</a> <a href="/tags/velocity/" style="font-size: 10px; color: #f38181">velocity</a> <a href="/tags/vim/" style="font-size: 14.17px; color: #cca9a3">vim</a> <a href="/tags/web/" style="font-size: 10px; color: #f38181">web</a> <a href="/tags/work/" style="font-size: 20px; color: #95e1d3">work</a> <a href="/tags/wsl/" style="font-size: 10px; color: #f38181">wsl</a> <a href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" style="font-size: 10.83px; color: #eb8988">强化学习</a> <a href="/tags/%E9%85%8D%E7%BD%AE%E7%B1%BB/" style="font-size: 10.83px; color: #eb8988">配置类</a>
</div>



<div align="center"> 
    <li id="footer-info-copyright">网站内容采用<a class="external" rel="nofollow noopener" target="_blank" href="https://www.gnu.org/copyleft/fdl.html">GNU自由文档许可证3或更高版本</a>授权</li> <img src="https://licensebuttons.net/l/by-nc-sa/3.0/88x31.png" alt="知识共享许可协议">



        </div>
    </div>
</body>


</html>
