<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="bookmark" type="image/x-icon" href="/img/favicon.ico">
	<link rel="shortcut icon" href="/img/favicon.ico">
		<!-- Modified by lsqyRobot -->
    <title>
    Beyond The Memory
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="Mbr82TZaQktpHzJ9Wt0AZ4B9JFdVUi1Xjxs8gf20DDM">
    <link rel="stylesheet" href="/css/timeLine.css">
    <link rel="stylesheet" href="/css/lsqy_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="mathematica,robotics,manipulator,ros,vim,matlab,C/C++,python,git,control theory,lsqyRobot">
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url(https://source.unsplash.com/random/1600x900) center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    

    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/dytitle.js"></script>
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/fireworks.js"></script>
    <script src="/js/codeBlockFuction.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>
		


<link rel="stylesheet" href="/css/prism_coy.css">
<link rel="stylesheet" href="/css/typo.css">
<body class="is-loading">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="wrapper" class="fade-in">
        <header id="header">
    <a href="/" class="logo">dots</a>
</header>

        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow"><img src="/img/home.png"></a>
	        </li>

			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1"><img src="/img/folder.png"></a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/Control/">Control</a></li><li><a class="category-link" href="/categories/Git/">Git</a></li><li><a class="category-link" href="/categories/Life/">Life</a></li><li><a class="category-link" href="/categories/Linux/">Linux</a></li><li><a class="category-link" href="/categories/Matlab/">Matlab</a></li><li><a class="category-link" href="/categories/Robot/">Robot</a></li><li><a class="category-link" href="/categories/VS/">VS</a></li><li><a class="category-link" href="/categories/Work/">Work</a></li><li><a class="category-link" href="/categories/latex/">latex</a></li><li><a class="category-link" href="/categories/life/">life</a></li><li><a class="category-link" href="/categories/math/">math</a></li><li><a class="category-link" href="/categories/ros/">ros</a></li><li><a class="category-link" href="/categories/rtb/">rtb</a></li><li><a class="category-link" href="/categories/tools/">tools</a></li><li><a class="category-link" href="/categories/work/">work</a>
	                    </li></ul>
	        </li>
	        


	        <!-- about 关于我   --> 
			<li>
	        
	            <a href="/about/"><img src="/img/about.png"></a>
	        
			</li>



	        <!-- about 关于我的朋友   --> 
			<li>
	        
	            <a href="/friend/"><img src="/img/friend.png"></a>
	        
			</li>




	        <!-- about 关于格言   --> 
			<li>
	        
	            <a href="/quote/"><img src="/img/quote.png"></a>
	        
			</li>










            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
			</ul>
</nav>


        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(/img/postImg/python0/venice-4504597_1280.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>python 学习(二)</h2></a>
            </div>

            <div class="typo" style="padding: 3rem;">
                <!-- vim-markdown-toc GFM -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#numpy">Numpy</a><ul>
<li><a href="#ndarray-对象">ndarray 对象</a></li>
</ul>
</li>
<li><a href="#scipy">SciPy</a><ul>
<li><a href="#优化optimize">优化——optimize</a><ul>
<li><a href="#最小二乘拟合">最小二乘拟合</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pandas">pandas</a><ul>
<li><a href="#series">Series</a></li>
</ul>
</li>
<li><a href="#知识点">知识点</a></li>
<li><a href="#参考">参考</a></li>
</ul>
<!-- vim-markdown-toc -->
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用python有近一年多的时间了，但水平还是很差，闲来无事，记录一些自己感觉有用的东西，仅此而已。</p>
<h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><h2 id="ndarray-对象"><a href="#ndarray-对象" class="headerlink" title="ndarray 对象"></a>ndarray 对象</h2><p>可以通过给 array()函数传递 Python 的序列 对象来创建数组。数组的形状可以通过其shape 属性获得，它是一个描述数组各个轴长度的元组(tuple)。当设置某个轴的元素个数为-1 时，将自动计算此轴的长度。使用数组的 reshape()方法，可以创建指定形状的新数组，而原数组的形状保持不变。zeros()、ones()、empty()可以创建指定形状和类型的数组。其中：empty()仅仅分配数组所使用的内存，不对数组元素进行初始化操作，因此它的运行速度是最快的。</p>
<p>fromfunction()的第一个参数为计算每个数组元素的函数，第二个参数指定数组的形状。如生成9*9的乘法序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(i,j)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (i+<span class="number">1</span>) * (j+<span class="number">1</span>)</span><br><span class="line">print(np.fromfunction(fun, (<span class="number">9</span>,<span class="number">9</span>)))</span><br></pre></td></tr></table></figure>
<p>关于切片，感觉还是利用形象的记忆比较有效，如下图所示</p>
<p><img src="/img/postImg/python0/python切片.png" width="100%" height="100%"></p>
<p>标准Python 中有比 for 循环更快的方案——使用列表推导式。但是列表推导式将产生一个新的列表，而不是直接修改原来列表中的元素。如</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">x = [<span class="built_in">math</span>.<span class="built_in">sin</span>(t) <span class="keyword">for</span> t <span class="keyword">in</span> x]</span><br></pre></td></tr></table></figure>
<h1 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h1><p>SciPy在NumPy的基础上增加了众多的数学、科学以及工程计算中常用的模块，例如线性代数、常微分方程数值求解、信号处理、图像处理、稀疏矩阵，等等。</p>
<h2 id="优化——optimize"><a href="#优化——optimize" class="headerlink" title="优化——optimize"></a>优化——optimize</h2><h3 id="最小二乘拟合"><a href="#最小二乘拟合" class="headerlink" title="最小二乘拟合"></a>最小二乘拟合</h3><p>最小二乘是自己做参数辨识中最常用的一种方法了，假设有一组实验数据(xi , yi)，我们事先知道它们之间应该满足某函数关系yi=f(xi)，通过这些已知信息，需要确定函数f的一些参数。例如，如果函数f是线性函数 f(x)=kx+b，那么参数 k和b 就是需要确定的值。如果用p表示函数中需要确定的参数，那么目标就是找到一组p，使得下面的函数S的值最小：</p>
<script type="math/tex; mode=display">
S(p) = \sum_{i=1}^M[y_i - f(x_i,p)]^2</script><p>这种算法被称为最小二乘拟合(Least-square fitting)。在optimize 模块中，可以使用leastsq()对数据进行最小二乘拟合计算。</p>
<h1 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h1><p>虽然pandas采用了大量的NumPy编码风格，但二者最大的不同是pandas是专门为处理表格和混杂 数据设计的。而NumPy更适合处理统一的数值数组数据。</p>
<p>默认使用使用下面的方式引入pandas:</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<p>因为Series和DataFrame用的次数非常 多，所以将其引入本地命名空间中会更方便：</p>
<figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br></pre></td></tr></table></figure>
<p>要使用pandas，你首先就得熟悉它的两个主要数据结构：Series和DataFrame。</p>
<h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><p>Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关 的数据标签（即索引）组成。仅由一组数据即可产生最简单的Series：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>Series的字符串表现形式为：索引在左边，值在右边。由于没有为数据指定索引，于是会自动创建一个0到N-1（N为数据的长度）的整数型索引。可以通过Series 的values和index属性获取其数组表示形式和索引对象：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">obj</span><span class="selector-class">.values</span></span><br></pre></td></tr></table></figure>
<p>可以通过Series带有可以对各个数据点进行标记的索引：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">obj</span> = pd.Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>], index=[<span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>
<p>这样就可以通过索引的方式选取Series中的单个或一组值, 如：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">obj[<span class="string">'a'</span>]</span><br></pre></td></tr></table></figure>
<p>如果数据被存放在一个python字典中，也可以直接通过这个字典来创建Series：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span> = &#123;<span class="string">'Ohio'</span>: <span class="number">35000</span>, <span class="string">'Texas'</span>: <span class="number">71000</span>, <span class="string">'Oregon'</span>: <span class="number">16000</span>, <span class="string">'Utah'</span>: <span class="number">5000</span>&#125;</span><br><span class="line"><span class="attr">obj</span> = pd.Series(sdata)</span><br></pre></td></tr></table></figure>
<p>对于许多应用而言，Series最重要的一个功能是，它会根据运算的索引标签自动对齐数据。</p>
<h1 id="类函数的编写"><a href="#类函数的编写" class="headerlink" title="类函数的编写"></a>类函数的编写</h1><p>已自己写的简单的串联机器人的运动学为例，</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">class robot:</span><br><span class="line">    def __init__(self,theta0,alpha,a,d,<span class="built_in">beta</span>,tool):</span><br><span class="line">        self.theta0 = deg2Rad(<span class="built_in">np</span>.<span class="built_in">array</span>(theta0))  #这里引入了其他地方写的函数，不过非常简单，就是将输入角度变成弧度</span><br><span class="line">        self.alpha = deg2Rad(<span class="built_in">np</span>.<span class="built_in">array</span>(alpha))</span><br><span class="line">        self.a = <span class="built_in">np</span>.<span class="built_in">array</span>(a)</span><br><span class="line">        self.d = <span class="built_in">np</span>.<span class="built_in">array</span>(d)</span><br><span class="line">        self.<span class="built_in">beta</span> = deg2Rad(<span class="built_in">np</span>.<span class="built_in">array</span>(<span class="built_in">beta</span>))</span><br><span class="line">        self.<span class="built_in">position</span> = []</span><br><span class="line">        self.pose = []</span><br><span class="line">        self.Jacobian = []</span><br><span class="line">        self.tool =<span class="built_in">np</span>.<span class="built_in">array</span>([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,tool[<span class="number">0</span>]],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,tool[<span class="number">1</span>]],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,tool[<span class="number">2</span>]],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">        <span class="built_in">np</span>.set_printoptions(suppress=True)</span><br><span class="line"></span><br><span class="line">    def FK(self,th):</span><br><span class="line">        # 这里theta 的格式为 N*<span class="number">6</span>， 方便一次性处理</span><br><span class="line">        th = <span class="built_in">np</span>.<span class="built_in">array</span>(th).reshape(-<span class="number">1</span>,<span class="number">6</span>)   #主要是担心输入形式为 [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] 这种格式的</span><br><span class="line">        th = deg2Rad(th)</span><br><span class="line">        alpha = self.alpha</span><br><span class="line">        a = self.a</span><br><span class="line">        d = self.d</span><br><span class="line">        <span class="built_in">beta</span> = self.<span class="built_in">beta</span></span><br><span class="line">        #上面这样写不写，都是无所谓的，追求效率的话，这些代码有很多地方可以优化，不过对于自己处理一些文件，足以。</span><br><span class="line">        axis_z = <span class="built_in">np</span>.<span class="built_in">array</span>([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">        T0j = []</span><br><span class="line">        T0j.<span class="built_in">append</span>(<span class="built_in">np</span>.eye(<span class="number">4</span>))</span><br><span class="line">        <span class="keyword">for</span> theta <span class="keyword">in</span> th:</span><br><span class="line">            theta = <span class="built_in">np</span>.<span class="built_in">array</span>(theta) + self.theta0    #以零点作为基准</span><br><span class="line">            T = <span class="built_in">np</span>.eye(<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">                cth = <span class="built_in">np</span>.<span class="built_in">cos</span>(theta[i])</span><br><span class="line">                sth = <span class="built_in">np</span>.<span class="built_in">sin</span>(theta[i])</span><br><span class="line">                ca = <span class="built_in">np</span>.<span class="built_in">cos</span>(alpha[i])</span><br><span class="line">                sa = <span class="built_in">np</span>.<span class="built_in">sin</span>(alpha[i])</span><br><span class="line">                cb = <span class="built_in">np</span>.<span class="built_in">cos</span>(<span class="built_in">beta</span>[i])</span><br><span class="line">                sb = <span class="built_in">np</span>.<span class="built_in">sin</span>(<span class="built_in">beta</span>[i])</span><br><span class="line">                tans =  <span class="built_in">np</span>.<span class="built_in">array</span>(   [[cth, -sth * ca, sth * sa, a[i] * cth],</span><br><span class="line">                                     [sth, cth * ca, -cth * sa, a[i] * sth],</span><br><span class="line">                                     [<span class="number">0</span>,   sa,       ca,        d[i]],</span><br><span class="line">                                     [<span class="number">0</span>,   <span class="number">0</span>,         <span class="number">0</span>,         <span class="number">1</span>]])</span><br><span class="line">                rotBeta = <span class="built_in">np</span>.<span class="built_in">array</span>([[cb, <span class="number">0</span>, sb, <span class="number">0</span>],</span><br><span class="line">                                    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                                    [-sb, <span class="number">0</span>, cb, <span class="number">0</span>],</span><br><span class="line">                                    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])					#标准的DH参数里面，没有用到<span class="built_in">beta</span>参数，即绕Y轴旋转的，根据标定的结果为准。</span><br><span class="line">                A =  <span class="built_in">np</span>.dot(tans, rotBeta)</span><br><span class="line">                T = <span class="built_in">np</span>.dot(T,A)</span><br><span class="line">                T0j.<span class="built_in">append</span>(T)</span><br><span class="line"></span><br><span class="line">            T0t = <span class="built_in">np</span>.dot(T,self.tool)</span><br><span class="line">            self.<span class="built_in">position</span>.<span class="built_in">append</span>(T0t[:<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line">            # 求解雅克比矩阵，雅克比矩阵能用到的地方太多了，也太重要了。</span><br><span class="line">            J = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">                vec_Z = <span class="built_in">np</span>.dot(T0j[i][:<span class="number">3</span>,:<span class="number">3</span>],axis_z)</span><br><span class="line">                Tjt = <span class="built_in">np</span>.dot(<span class="built_in">np</span>.linalg.inv(T0j[i]),T0t)</span><br><span class="line">                vec_P = <span class="built_in">np</span>.dot(T0j[i][:<span class="number">3</span>,:<span class="number">3</span>],Tjt[:<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line">                J.<span class="built_in">append</span>(<span class="built_in">np</span>.cross(vec_Z,vec_P))</span><br><span class="line">            self.Jacobian.<span class="built_in">append</span>(<span class="built_in">np</span>.<span class="built_in">array</span>(J).<span class="built_in">transpose</span>())</span><br></pre></td></tr></table></figure>
<p>调用的话，就比较简单了：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">dhPar = np.array([[ 0,        154,             0,         -90,           0],</span><br><span class="line">                 [-90,          0,       418.865,           0,           0],</span><br><span class="line">                 [  0,          0,       387.265,           0,           0],</span><br><span class="line">                 [ 90,    144.421,             0,          90,           0],</span><br><span class="line">                 [  0,    122.213,             0,          90,           0],</span><br><span class="line">                 [  0,      107.5,             0,           0,           0]])</span><br><span class="line">                 <span class="comment">#输入标定里面的结果</span></span><br><span class="line">theta0 = [0,0,0,0,0,0]  <span class="comment"># 根据具体的标定，去选择修正。 </span></span><br><span class="line">theta0 = dhPar[:,0] - np.array(theta0)</span><br><span class="line">d = dhPar[:,1]</span><br><span class="line">a = dhPar[:,2]</span><br><span class="line">alpha = dhPar[:,3]</span><br><span class="line">beta =  dhPar[:,4]</span><br><span class="line">toolOffset=[44.927,-21.859,62.138]   					 <span class="comment">#工具坐标系</span></span><br><span class="line">yourRobot = robot(theta0,alpha,a,d,beta,toolOffset) 	 <span class="comment">#实例的时候，就会初始化给那些成员函数，和C++非常相似</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thetaTest = [[-18.417,22.954,97.427,-125.640,108.328,-87.907]]  <span class="comment">#可以写入 N*6 行的关节角，方便一次性在函数体内进行计算</span></span><br><span class="line">ECR5.FK(thetaTest)                                              <span class="comment">#通过正解，可以算出很多结果。</span></span><br><span class="line">print(ECR5.position)											<span class="comment">#输出结果，或者是将结果做下一部的转化、或给其他函数做输入等等。</span></span><br></pre></td></tr></table></figure>
<h1 id="处理矩阵经常用到的"><a href="#处理矩阵经常用到的" class="headerlink" title="处理矩阵经常用到的"></a>处理矩阵经常用到的</h1><h2 id="利用行列向量生成对角阵"><a href="#利用行列向量生成对角阵" class="headerlink" title="利用行列向量生成对角阵"></a>利用行列向量生成对角阵</h2><p>这个问题的引入是在自己做辨识的时候用上的，需要将力矩向量变成对角矩阵，然后进行辨识。</p>
<p>大致有三种方法，<code>np.array</code> + <code>np.diag</code>,<code>np.array</code> + <code>np.identity</code>,<code>np.matrix</code> + <code>np.diagflat</code>。其中最快的属于第一种，下面给出第一种的使用：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">tau = <span class="built_in">np</span>.<span class="built_in">array</span>(tau)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len(tau))</span><br><span class="line">	tor = <span class="built_in">np</span>.<span class="built_in">diag</span>(tau[i])</span><br></pre></td></tr></table></figure>
<h1 id="矩阵的合并"><a href="#矩阵的合并" class="headerlink" title="矩阵的合并"></a>矩阵的合并</h1><p>矩阵合并用的最多的是<code>np.append</code>, 比如<code>np.append(m1,m2,axis = 0)</code> 表示合并列，和matlab <code>[a;b]</code>, 很相似，类似的，<code>np.append(m1,m2,axis=1)</code>和 matlab <code>[a,b]</code> 类似，为列合并。</p>
<h1 id="获取xml中的数据"><a href="#获取xml中的数据" class="headerlink" title="获取xml中的数据"></a>获取xml中的数据</h1><p>这个是为了方便自己在读取DH参数的时候用到的。</p>
<h3 id="xml中节点包含的属性："><a href="#xml中节点包含的属性：" class="headerlink" title="xml中节点包含的属性："></a>xml中节点包含的属性：</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>, nodeName——节点名称</span><br><span class="line"><span class="number">2</span>, nodeValue——节点值</span><br><span class="line"><span class="number">3</span>, nodeType——节点类型</span><br><span class="line">   nodeType为<span class="number">1</span>说明是元素节点，nodeType为<span class="number">2</span>说明是属性节点。</span><br></pre></td></tr></table></figure>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>, 元素节点</span><br><span class="line"><span class="number">2</span>, 文本节点</span><br><span class="line"><span class="number">3</span>, 属性节点</span><br></pre></td></tr></table></figure>
<h3 id="python获取xml节点："><a href="#python获取xml节点：" class="headerlink" title="python获取xml节点："></a>python获取xml节点：</h3><p>DH.xml文件 (简单的例子)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DH</span>&gt;</span>            </span><br><span class="line">        <span class="tag">&lt;<span class="name">Axis1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">theta</span>&gt;</span>0<span class="tag">&lt;/<span class="name">theta</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">d</span>&gt;</span>154.0<span class="tag">&lt;/<span class="name">d</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span>&gt;</span>-0.631<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">alpha</span>&gt;</span>-90.045<span class="tag">&lt;/<span class="name">alpha</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">beta</span>&gt;</span>0<span class="tag">&lt;/<span class="name">beta</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Axis1</span>&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">DH</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>代码：</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import lsqyRobot as lR</span><br><span class="line">from xml<span class="selector-class">.dom</span> import minidom</span><br><span class="line"></span><br><span class="line">xmlFile = lR.askFileWhere()</span><br><span class="line">dom=minidom.parse(xmlFile)</span><br><span class="line">root=dom<span class="selector-class">.documentElement</span>       #获取dom对象元素</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(root.nodeName)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(root.nodeValue)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(root.nodeType)</span></span></span><br></pre></td></tr></table></figure>
<p>其中 askFilewhere() 在 <code>lsqyRobot.py</code> (为方便自己写的函数包）代码如下</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">askFileWhere</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    root = tk.Tk()</span><br><span class="line">    root.withdraw()</span><br><span class="line">    file_path = filedialog.askopenfilename()</span><br><span class="line">    <span class="keyword">return</span> file_path</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<p><img src="/img/postImg/python0/xmlEx1.png" alt></p>
<p>这里如果想在打开文件的时候给予提示，可将 <code>askFileWhere()</code>改写为：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">askFileWhere</span><span class="params">(tit)</span></span><span class="symbol">:</span></span><br><span class="line">    root = tk.Tk()</span><br><span class="line">    root.withdraw()</span><br><span class="line">    file_path = filedialog.askopenfilename(title = <span class="string">"&#123;&#125;"</span>.format(tit))</span><br><span class="line">    <span class="keyword">return</span> file_path</span><br></pre></td></tr></table></figure>
<h4 id="打印标签对之间的数据"><a href="#打印标签对之间的数据" class="headerlink" title="打印标签对之间的数据"></a>打印标签对之间的数据</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span>.<span class="title">firstChild</span>.data</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">import lsqyRobot as lR</span><br><span class="line">from xml.dom import minidom</span><br><span class="line"></span><br><span class="line">xmlFile = lR.askFileWhere()</span><br><span class="line">dom=minidom.parse(xmlFile)</span><br><span class="line">thetaValue = dom.getElementsByTagName(<span class="string">"theta"</span>)</span><br><span class="line">dValue= dom.getElementsByTagName(<span class="string">"d"</span>)</span><br><span class="line">aValue= dom.getElementsByTagName(<span class="string">"a"</span>)</span><br><span class="line">alphaValue = dom.getElementsByTagName(<span class="string">"alpha"</span>)</span><br><span class="line">betaValue = dom.getElementsByTagName(<span class="string">"beta"</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果如下（调试状态，其实都可以看到值，感兴趣的自己去尝试下，并不难)</p>
<p><img src="/img/postImg/python0/xmlEx2.png" alt></p>
<p>目前就记录到这，用到再记了。</p>
<h1 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h1><p>事情的起因是要筛选标定程序里的一些点的，由于在标定的时候，自动生成的点位（一般是朝着一个方向，即姿态不怎么发生变化），需要实际去跑这些点位，可有的时候自动生成的点位无法保证是安全的，这样就需要手动去调整，这个时候需要筛选出调整后的点位。比如最后调整好的文件可能是长成这样的：</p>
<p><img src="/img/postImg/python0/targetPoint1.png" alt></p>
<p>不过只需要里面的数字，就是画黄线那部分，还需要将<code>,</code>,变成<code>Tab</code>, 或者是<code>\t</code>，用 vim 的正则等可以非常快的（大概一分钟）就能解决这个问题， 第一步，除了选中部分，其他部分均删除：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">:v /<span class="tag">&lt;<span class="name">target</span>&gt;</span>/d</span><br></pre></td></tr></table></figure>
<p>通过这一步就差不多把需要的给筛选出来了</p>
<p><img src="/img/postImg/python0/targetPoint2.png" alt></p>
<p>剩下的就是简单的vim正则替换了:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">:%s <span class="regexp">/&lt;target&gt;POINTJ&lt;/</span><span class="regexp">/g|%s /</span>)&lt;\<span class="regexp">/target&gt;/</span><span class="regexp">/g|%s /</span>,<span class="regexp">/\t/g</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/postImg/python0/targetPoint3.png" alt></p>
<p><img src="/img/postImg/python0/targetPoint4.png" alt></p>
<p>这个前提是对 <code>vim</code> 的正则替换有些熟悉，哪怕几百万行，替换的时间也是非常短的，当然，这种核心思想在于正则替换，使用python一样可以做。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式提供了一种灵活的在文本中搜索或匹配（通常比前者复杂）字符串模式的方式。正则表 达式，常称作regex，是根据正则表达式语言编写的字符串。Python内置的re模块负责对字符串应 用正则表达式。</p>
<p>re模块的函数可以分为三个大类：模式匹配、替换以及拆分。当然，它们之间是相辅相成的。一个 regex描述了需要在文本中定位的一个模式，它可以用于许多目的。</p>
<h3 id="re-compile-函数"><a href="#re-compile-函数" class="headerlink" title="re.compile 函数"></a>re.compile 函数</h3><p>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。语法格式为：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">re.compile(pattern[, flags])</span><br><span class="line">pattern : 一个字符串形式的正则表达式</span><br><span class="line">flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：</span><br><span class="line">re.I 忽略大小写</span><br><span class="line">re.L 表示特殊字符集 <span class="string">\w,</span> <span class="string">\W,</span> <span class="string">\b,</span> <span class="string">\B,</span> <span class="string">\s,</span> <span class="string">\S</span> 依赖于当前环境</span><br><span class="line">re.M 多行模式</span><br><span class="line">re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）</span><br><span class="line">re.U 表示特殊字符集 <span class="string">\w,</span> <span class="string">\W,</span> <span class="string">\b,</span> <span class="string">\B,</span> <span class="string">\d,</span> <span class="string">\D,</span> <span class="string">\s,</span> <span class="string">\S</span> 依赖于 Unicode 字符属性数据库</span><br><span class="line">re.X 为了增加可读性，忽略空格和 <span class="comment"># 后面的注释</span></span><br></pre></td></tr></table></figure>
<h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><p>1， 在使用np.array的时候，默认是以科学计数法来显示的，在写机器人代码的时候与示教器上的数值进行核对时，会有些费事，使其正常显示可以设置为</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">np.set_printoptions(<span class="attribute">suppress</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>2， 保存高清图像，指定 <code>dpi</code> 与设置bbox_inches=‘tight’,这里dpi越大，越清晰，当然，导出的时间也越慢。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">plt</span><span class="selector-class">.savefig</span>(<span class="string">'./yourPic.jpg'</span>,dpi=<span class="number">500</span>,bbox_inches = <span class="string">'tight'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] 《python 科学计算》—— 张若愚等著</p>
<p>[2] 《利用 Python 进行数据分析》——Mckinney Wes</p>
<p>[3] <a href="https://blog.csdn.net/hju22" target="_blank" rel="noopener">龟的小号</a></p>

            </div>

<div align="center"> 
<li id="footer-info-copyright">网站内容采用<a class="external" rel="nofollow" href="https://www.gnu.org/copyleft/fdl.html">GNU自由文档许可证3或更高版本</a>授权</li> <img src="https://licensebuttons.net/l/by-nc-sa/3.0/88x31.png" alt="知识共享许可协议"></div>


        </div>
    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>


</html>
