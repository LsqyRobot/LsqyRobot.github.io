<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="bookmark" type="image/x-icon" href="/img/favicon.ico">
	<link rel="shortcut icon" href="/img/favicon.ico">
	
				<!-- Modified by lsqyRobot -->
    <title>
    Beyond The Memory
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/lsqy_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="looking backward">
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url(https://source.unsplash.com/random/1600x900) center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/dytitle.js"></script>
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/fireworks.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



	
</head>
    
		



<link rel="stylesheet" href="/css/prism_coy.css">
<link rel="stylesheet" href="/css/typo.css">
<body class="is-loading">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="wrapper" class="fade-in">
        <header id="header">
    <a href="/" class="logo">dots</a>
</header>

        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a></li><li><a class="category-link" href="/categories/C/">C</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/Life/">Life</a></li><li><a class="category-link" href="/categories/Linux/">Linux</a></li><li><a class="category-link" href="/categories/Matlab/">Matlab</a></li><li><a class="category-link" href="/categories/latex/">latex</a></li><li><a class="category-link" href="/categories/tools/">tools</a></li><li><a class="category-link" href="/categories/web/">web</a></li><li><a class="category-link" href="/categories/work/">work</a>
	                    </li></ul>
	        </li>
	        

	        <!-- archives  标签   --> 
	        
	        


	        <!-- archives  归档   --> 
	        
	        <li class="active">
	            <a href="#s1">自定义</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="archive-link" href="/archives/2020/01/">一月 2020</a></li><li><a class="archive-link" href="/archives/2019/11/">十一月 2019</a></li><li><a class="archive-link" href="/archives/2019/09/">九月 2019</a></li><li><a class="archive-link" href="/archives/2019/04/">四月 2019</a>
	                    </li></ul>
	        </li>
	        
	        









		        <!-- Pages 自定义   -->
		        












            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
			</ul>
</nav>


        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://github.com/LsqyRobot/LsqyRobot.github.io/blob/master/images/JiJie201909063.jpg?raw=true);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>C++从入门到放弃</h2></a>
            </div>
            <div class="typo" style="padding: 3rem;">
                <h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>记录一些自己感觉比较有用的概念. 实际上就是一份从入门到放弃的笔记，毕竟还是喜欢从网上逛博客学知识，零散些没什么，能够串起来就很有用了。</p>
<p><strong>尚未整理完, 请先别看</strong></p>
<h4 id="收集的知识点"><a href="#收集的知识点" class="headerlink" title="收集的知识点"></a>收集的知识点</h4><p>下面的内容大多来自于书籍《C++ primer中文版》.</p>
<p>1, 如果文件名用<span id="inline-blue"> 尖括号括 </span>起来,  表明这个文件是一个工程或标准头文件查找过程会<span id="inline-blue"> 检查预定义的 </span>目录;如果文件名用一对<span id="inline-blue"> 引号括 </span>起来则表明该文件是用户提供的头文件查找该文件时将从<span id="inline-blue"> 当前文件目 </span>录开始.</p>
<p>2, C++ 程序可以定义为对象的集合, 这些对象通过调用彼此的方法进行交互.</p>
<p>3, 块注释符是不可以嵌套使用的.</p>
<p>4,  iostream&gt;头文件中定义的操纵符有：  endl:输出时插入换行符并刷新流;endls：输出时在字符 插入NULL作为尾符;flush：刷新缓冲区, 把流从缓冲区输出到目标设备, 并清空缓冲区; ws：输入时略去空白字符;dec：令IO数据按十进制格式;hex:令IO数据按十六进制格式; oct：令IO数据按八进制格式</p>
<p>5, 使用 typedef 为一个已有的类型取一个新的名字;</p>
<p>6, 枚举类型(enumeration)是C++中的一种派生数据类型, 它是由用户定义的若干枚举常量的集合. 如果一个变量只有几种可能的值, 可以定义为枚举(enumeration)类型.所谓”枚举”是指将变量的值一一列举出来, 变量的值只能在列举出来的值的范围内.</p>
<p>7, 把常量定义为大写字母形式, 是一个很好的编程实践.</p>
<p>8, <span id="inline-blue"> const  </span>类型的对象在程序执行期间不能被修改改变.修饰符 volatile 告诉编译器不需要优化volatile声明的变量,让程序可以直接从内存中读取变量.对于一般的变量编译器会对变量进行优化,将内存中的变量值放在寄存器中以加快读写效率.由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式.只有 C99 增加了新的类型限定符 restrict.</p>
<p>9, extern 存储类用于提供一个全局变量的引用,全局变量对所有的程序文件都是可见的.当您使用 ‘extern’ 时,对于无法初始化的变量,会把变量名指向一个之前定义过的存储位置. 当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时,可以在其他文件中使用 extern 来得到已定义的变量或函数的引用.可以这么理解,extern 是用来在另一个文件中声明一个全局变量或函数.</p>
<p>10, “::”在C++中表示作用域,和所属关系.”::”是运算符中等级最高的</p>
<p>11, 预定义的对象 cin 是 iostream 类的一个实例.cin 对象附属到标准输入设备,通常是键盘.cin 是与流提取运算符 &gt;&gt;</p>
<p>12,  array也位于名称空间std中,与数组一样,array对象的长度也是固定的,也使用栈(静态内存分配),而不是自由存储区,因此其效率与数组相同,但更方便,更安全. </p>
<p>13, 类定义是以关键字 class 开头,后跟类的名称.类的主体是包含在一对花括号中.类定义后必须跟着一个分号或一个声明列表.</p>
<p>14, 关键字 public 确定了类成员的访问属性.在类对象作用域内,公共成员在类的外部是可访问的.</p>
<p>15, 点运算符“.”应用于实际的对象,箭头运算符“-&gt;”与一个指针对象的指针一起使用.</p>
<p>16, ::std::vector&lt;&gt; 是一个认真设计的值类型,天生是可以拷贝构造和可赋值的.如果 T 是可比较的,那么 ::std::vector<t> 将自动地是可以比较的. 四个特殊的成员函数 T(); // 缺省构造函数(default constructor) ~T(); // 解构函数(destructor) T( T const&amp; ); // 拷贝构造函数 T&amp; operator=( T const&amp; ); // 拷贝赋值函数</t></p>
<p>17, 容量是指在容器下一次需要增长自己之前能够被加入到容器中的元素的总数连续存储的容器相关.</p>
<p>18, 实际的矩阵是在构造函数中动态分配的 在析构函数中删除的.</p>
<p>19, CLU, Ada 和 Modula-2 是三种支持抽象数据类型的程序设计语言.</p>
<p>20, 条件指示符#ifndef 检查前面是否已经被定义,#ifdef 指示符常被用来判断一个预处理器常量是否已被定义以便有条件地包含程序代码.</p>
<p>21, 不能用赋值操作符把一个数组拷贝到另一个中去.</p>
<p>22, 在C++中,设计 size_t 就是为了适应多个平台的 .size_t的引入增强了程序在不同平台上的可移植性.</p>
<p>23, 每个类对象在被程序最后一次使用之后它的析构函数就会被自动调用.</p>
<p>24, &amp;:取地址,*：间接引用. 预处理命令的操作对象是编译器和连接器。</p>
<p>25, 当指针变量p指向整型变量a时,*p的运算结果就是a本身,而非a的值。</p>
<p>26, 多数情况下,应该在指针间接引用之前检测是否为空指针,从而避免异常错误。</p>
<p>27, p1指向变量a,p2指向变量b,<em>p1等价于a, </em>p2等价于b.</p>
<p>28, 不要返回函数里的局部对象的引用。</p>
<p>29, 结构体对象的指针成员存储的是地址,而不是指向的内容名,这一点与数组成员是不同的。</p>
<p>30, 当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类.</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>asm</strong></th>
<th><strong>else</strong></th>
<th><strong>new</strong></th>
<th><strong>this</strong></th>
<th><strong>auto</strong></th>
<th><strong>enum</strong></th>
<th><strong>throw</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">operator</td>
<td>true</td>
<td></td>
<td>explicit</td>
<td>private</td>
<td></td>
<td>false</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><strong>break</strong></td>
<td><strong>export</strong></td>
<td></td>
<td><strong>catch</strong></td>
<td></td>
<td><strong>bool</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">case</td>
<td>extern</td>
<td>public</td>
<td>typedef</td>
<td></td>
<td>typeid</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><strong>char</strong></td>
<td><strong>float</strong></td>
<td></td>
<td><strong>delete</strong></td>
<td></td>
<td><strong>int</strong></td>
<td><strong>typename</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">reinterpret_cast</td>
<td></td>
<td>static_cast</td>
<td></td>
<td>register</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><strong>class</strong></td>
<td><strong>for</strong></td>
<td><strong>return</strong></td>
<td><strong>union</strong></td>
<td></td>
<td><strong>volatile</strong></td>
<td>namespace</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">const</td>
<td>friend</td>
<td>short</td>
<td>unsigned</td>
<td>do</td>
<td>long</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><strong>const_cast</strong></td>
<td><strong>goto</strong></td>
<td><strong>signed</strong></td>
<td><strong>using</strong></td>
<td><strong>struct</strong></td>
<td><strong>wchar_t</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">continue</td>
<td>if</td>
<td>sizeof</td>
<td>virtual</td>
<td>double</td>
<td>mutable</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><strong>default</strong></td>
<td><strong>inline</strong></td>
<td><strong>static</strong></td>
<td><strong>void</strong></td>
<td><strong>switch</strong></td>
<td><strong>while</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">dynamic_cast</td>
<td></td>
<td>template</td>
<td></td>
<td></td>
<td>protected</td>
<td></td>
</tr>
</tbody>
</table>
<p>####　遇到的问题</p>
<p>真的是新手上路,各种事故.</p>
<p>输出的时候,用双引号,单引号会导致输出的结果有问题.</p>
<h5 id="容器-vector-作为函数参数如何传参"><a href="#容器-vector-作为函数参数如何传参" class="headerlink" title="容器(vector)作为函数参数如何传参"></a>容器(vector)作为函数参数如何传参</h5><p>大致有以下类型源自于此<a href="https://blog.csdn.net/w_linux/article/details/72417896" target="_blank" rel="noopener">博客</a></p>
<p>1,  void 函数名( vector&lt; int&gt; obj );</p>
<p>2,  void 函数名( vector&lt; int&gt;* pobj );</p>
<p>3,  void 函数名( const vector&lt; int&gt;* pobj ); // 在函数内不能改变 pobj 指向的对象 ,//调用时不会调用拷贝构造函数</p>
<p>4,  void 函数名( vector&lt; int&gt;&amp; obj );</p>
<p>5,  void 函数名( const vector&lt; int&gt;&amp; obj ); // 在函数内不能改变 obj 对象,// 在函数调用时调用了vector的拷贝构造函数</p>
<p>表达式放在构析函数中, 如果类的析构函数存在, 那么在每个类的生命期结束时它会被调用.析构函数由类名前面加一个波浪号来标识.</p>
<h5 id="resize-和-reserve"><a href="#resize-和-reserve" class="headerlink" title="resize 和　reserve"></a>resize 和　reserve</h5><p>内容搬运于此<a href="https://blog.csdn.net/jackywgw/article/details/6248342" target="_blank" rel="noopener">博客</a></p>
<p>1, capacity:指容器在分配新的存储空间之前能存储的元素总数.size:指当前容器所存储的元素个数.</p>
<p>2, 1).reserve表示容器预留空间,但并不是真正的创建对象,需要通过insert（）或push_back（）等创建对象.resize既分配了空间,也创建了对象.</p>
<p>3, reserve只修改capacity大小,不修改size大小,resize既修改capacity大小,也修改size大小.</p>
<h6 id="动态内存分配和指针"><a href="#动态内存分配和指针" class="headerlink" title="动态内存分配和指针"></a>动态内存分配和指针</h6><p>对象可以静态分配——即编译器在处理程序源代码时分配配——即程序执行时调用运行时刻库函数来分配灵活性之间的平衡准则不同没有也可以动态分这两种内存分配方法的主要区别是效率与出于静态内存分配是在程序执行之前进行的因而效率比较高但是它缺少灵活性它要求在程序执行之前就知道所需内存的类型和数量. C++支持用指针类型来存放对象的内存地址值.</p>
<p>静态与动态内存分配的两个主要区别是:</p>
<p>1, 静态对象是有名字的变量, 直接对其进行操作,而动态对象是没有名字的变量,通过指针间接地对它进行操作;</p>
<p>2, 静态对象的分配与释放由编译器自动处理事情, 相反,动态对象的分配与释放,必须由程序员显式地管理但不需要做任何事情,相对来说比较容易出错它通过new和delete两个表达式来完成, 对于动态分配的内存惟一的访问方式是通过指针间接地访问</p>
<p>3, 没有办法给动态分配的数组的每个元素显式地指定一个初始值, 当用完了动态分配的对象或对象的数组时, 必须显式地释放这些内存, 可以通过使用 delete 表达式的两个版本之一来完成这件事情,而释放之后的内存则可以被程序重新使用.</p>
<p>4, 如果忘了删除动态分配的内存程序就会在结束时出现内存泄漏 (memory leak) 的问题</p>
<p>5, 由于 C++不允许成员函数与数据成员共享同一个名字, 所以在这样的情况下,一般的习惯是在数据成员名字前面加一个下划线.</p>
<p>6, 在类定义中被定义的成员函数会被自动当作是内联函数,此外我们也可以用inline关键字显式地要求一个函数被视为内联函数</p>
<p>7, 被声明为 static 的数据成员是一类特殊的共享数据成员无论这个类的对象被定义了多少个静态数据成员在程序中也只有一份.</p>
<h5 id="hpp与-h区别"><a href="#hpp与-h区别" class="headerlink" title=".hpp与.h区别"></a><a href="https://www.cnblogs.com/lzhu/p/8034817.html" target="_blank" rel="noopener">.hpp与.h区别</a></h5><p>.hpp,本质就是将.cpp的实现代码混入.h头文件当中,定义与实现都包含在同一文件,则该类的调用者只需要include该.hpp文件即可,无需再将cpp加入到project中进行编译.而实现代码将直接编译到调用者的obj文件中,不再生成单独的obj,采用hpp将大幅度减少调用project中的cpp文件数与编译次数,也不用再发布lib与dll文件,因此非常适合用来编写公用的开源库.</p>
<p>由于.hpp本质上是作为.h被调用者include的,所以当hpp文件中存在全局对象或者全局函数,而该hpp被多个调用者include时,将在链接时导致符号重定义错误.要避免这种情况,需要去除全局对象,将全局函数封装为类的静态方法.</p>
<p>Note: 函数返回运算结果的前提有3个：</p>
<p>1) 使用指针变量作为函数形参。2)用接受运算结果的变量的指针（或地址）作为实参调用函数 3）函数中通过指针间接引用修改这些变量。</p>
<p>Note: 函数名既代表函数,又是函数的指针。 2） delete只能删除由new创建的动态对象,否则将导致程序错误。</p>
<h5 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h5><p>1, 类成员可以是数据, 函数或类型别名。所有成员必须在类的内部声明, 一旦类定义完成后, 就没有任何其他方式再增加成员了。</p>
<p>2, 类定义一般放在程序文件开头, 或者放到头文件中被程序文件包含, 此时这个定义是全局的。在全局作用域内, 该定义处处可见, 因此同一作用域内的所有函数都可以使用它。</p>
<h5 id="成员访问控制"><a href="#成员访问控制" class="headerlink" title="成员访问控制"></a>成员访问控制</h5><p>对类的成员进行访问，来自两个访问源： 类成员和类用户。类成员指的是类本身的成员函数，类用户指的是类外部的使用者，包括全局函数，另一个类的成员函数等。 无论数据成员还是函数成员，类的每个成员都有访问控制属性，由一下三个访问标号说明: public, private, protected.  类成员和类用户都可以访问公有成员，任何一个来自类外部的类用户都必须通过公有成员来访问。显然，public实现了类的外部接口。</p>
<p>只有类成员可以访问私有成员，类用户的访问是不允许的。显然，private实现了私有成员的隐蔽。</p>
<p>保护成员用protected标号说明，在不考虑继承的情况下，protected的性质和private的性质一致，但保护成员可以被派生类的类成员访问。</p>
<p>另外需要说明:</p>
<p>1) 数据成员一般声明为 private，以实现信息的隐蔽.</p>
<p>2) 成员函数一般声明为 public，以提供外界使用的接口.</p>
<p>3) 构造函数一般声明为 public，以便创建类的对象.</p>
<p>4) 创建一个类类型的对象时，编译器会自动使用一个构造函数来初始化该对象，构造函数是一个特殊的、与类同名的成员函数，用于初始化每个数据成员来设置初始值。</p>
<p>5) 构造函数一般使用一个构造函数初始化列表，来初始化对象的数据成员.</p>
<p>6) 在类内部，声明成员函数是必需的，而定义成员函数则可选，可以在类外定义。在类内部定义的函数默认为 inline 函数.</p>
<p>下面需要注意的源自于林锐的《高质量C++/C编程指南》</p>
<p>Note! 在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层,来提高程序运行效率。</p>
<p>Note! 如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面.</p>
<p>Note! Switch 是多分支选择语句，而 f 语句只有两个分支可供选择。虽然可以用嵌套的 if 语句来实现多分支选择，但那样的程序冗长难读。这是 switch 语句存在的理由。</p>
<p>常见的内存错误及其对策如下</p>
<p>1, 内存分配未成功，却使用了它。</p>
<p>2, 内存分配虽然成功，但是尚未初始化就引用它。</p>
<p>3, 内存分配成功并且已经初始化，但操作越过了内存的边界</p>
<p>4, 忘记了释放内存，造成内存泄露。</p>
<p>5, 释放了内存却继续使用它。</p>
<p>Note: </p>
<p>1) 用 malloc 或 new 申请内存之后，应该立即检査指针值是否为 NULL。防止使用指针值为 NULL 的内存</p>
<p>2) 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。</p>
<p>3) 避免数组或指针的下标越界，特别要当心发生“多 1”或者“少 1”操作。</p>
<p>4) 动态内存的申请与释放必须配对，防止内存泄漏。</p>
<p>5)用 free 或 delete 释放了内存之后，立即将指针设置为 NULL，防止产生“野指针”.</p>
<p>Note! malloc 返回值的类型是 void <em>，所以在调用 malloc 时要显式地进行类型转换，将 void </em>转换成所需要的指针类型。</p>
<h3 id="c-关于-类的注意事项"><a href="#c-关于-类的注意事项" class="headerlink" title="c++ 关于 类的注意事项"></a>c++ 关于 类的注意事项</h3><p>作为学习使用，内容摘抄于<a href="https://blog.csdn.net/txl199106/article/details/48622643" target="_blank" rel="noopener">Tham</a>的博客</p>
<p>1) 1. 除了静态 static 数据成员外，数据成员不能在类体中被显式地初始化。</p>
<h3 id="读取以及处理数据"><a href="#读取以及处理数据" class="headerlink" title="读取以及处理数据"></a>读取以及处理数据</h3><p>1) file.good()是在文件读取或者写的过程中出现错误；或者读到文件最后继续读才会返回false;</p>

            </div>

        </div>
    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</body>


 	
</html>
