<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/favicon.ico"/>
	<link rel="shortcut icon" href="/img/favicon.ico">
		<!-- Modified by lsqyRobot -->
    <title>
    Beyond The Memory
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="google-site-verification" content="Mbr82TZaQktpHzJ9Wt0AZ4B9JFdVUi1Xjxs8gf20DDM" />
    <link rel="stylesheet" href="/css/lsqy_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="mathematica,robotics,manipulator,ros,vim,matlab,C/C++,python,git,control theory,lsqyRobot" />
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/myCover.png') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

	    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/dytitle.js"></script>
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
    <script type="text/javascript" src="/js/fireworks.js"></script>
    <script src="/js/codeBlockFuction.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>
		


<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<body class="is-loading">
    <div id="wrapper" class="fade-in">
        <header id="header">
    <a href="/" class="logo">dots</a>
</header>

        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow"><img src="/img/home.png"></a>
	        </li>

			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1"><img src="/img/folder.png"></a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/ALGORITHM/">ALGORITHM</a></li><li><a class="category-link" href="/categories/C/">C++</a></li><li><a class="category-link" href="/categories/CONFIG/">CONFIG</a></li><li><a class="category-link" href="/categories/CONTROL/">CONTROL</a></li><li><a class="category-link" href="/categories/CPP/">CPP</a></li><li><a class="category-link" href="/categories/GIT/">GIT</a></li><li><a class="category-link" href="/categories/HEXO/">HEXO</a></li><li><a class="category-link" href="/categories/LATEX/">LATEX</a></li><li><a class="category-link" href="/categories/LIFE/">LIFE</a></li><li><a class="category-link" href="/categories/LINUX/">LINUX</a></li><li><a class="category-link" href="/categories/MAC-BOOK/">MAC BOOK</a></li><li><a class="category-link" href="/categories/MATLAB/">MATLAB</a></li><li><a class="category-link" href="/categories/PYTHON/">PYTHON</a></li><li><a class="category-link" href="/categories/ROBOTICS/">ROBOTICS</a></li><li><a class="category-link" href="/categories/ROS/">ROS</a></li><li><a class="category-link" href="/categories/TOOLS/">TOOLS</a></li><li><a class="category-link" href="/categories/dataStruct/">dataStruct</a></li><li><a class="category-link" href="/categories/robotics/">robotics</a>
	                    </ul>
	        </li>
	        


	        <!-- about 关于我   --> 
			<li>
	        
	            <a href="/about/" ><img src="/img/about.png"></a>
	        
			</li>



	        <!-- about 关于我的朋友   --> 
			<li>
	        
	            <a href="/friend/" ><img src="/img/friend.png"></a>
	        
			</li>




	        <!-- about 关于格言   --> 
			<li>
	        
	            <a href="/quote/" ><img src="/img/quote.png"></a>
	        
			</li>


	        <!-- about 关于搜索栏   --> 
			<li>
	        
	            <a href="/search/" ><img src="/img/search.png"></a>
	        
			</li>



	        <!-- my lover--> 
			<li>
	        
	            <a href="/dudu/" ><img src="/img/myLoverLogo.png"></a>
	        
			</li>

	        <!-- my tags--> 
			<li>
	        
			</li>


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
			</ul>
</nav>


        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(/img/postImg/18_CPP/logo/halloween-7487706_1280_used.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >C++ 中的容器</h2></a>
            </div>

            <div class="typo" style="padding: 3rem;">
                <!-- vim-markdown-toc GFM -->
<ul>
<li><a href="#什么是stl">什么是STL?</a></li>
<li><a href="#容器containers">容器(Containers)</a><ul>
<li><a href="#vector">vector</a><ul>
<li><a href="#特点">特点</a></li>
<li><a href="#适用场景">适用场景</a></li>
<li><a href="#例子">例子</a></li>
</ul>
</li>
<li><a href="#deque">deque</a><ul>
<li><a href="#特点-1">特点</a></li>
<li><a href="#适用场景-1">适用场景</a></li>
<li><a href="#例子-1">例子</a></li>
</ul>
</li>
<li><a href="#list">list</a><ul>
<li><a href="#特点-2">特点</a></li>
<li><a href="#适用场景-2">适用场景</a></li>
<li><a href="#例子-2">例子</a></li>
</ul>
</li>
<li><a href="#set">set</a><ul>
<li><a href="#特点-3">特点</a></li>
<li><a href="#适用场景-3">适用场景</a></li>
<li><a href="#例子-3">例子</a></li>
</ul>
</li>
<li><a href="#map">map</a><ul>
<li><a href="#特点-4">特点</a></li>
<li><a href="#适用场景-4">适用场景</a></li>
<li><a href="#例子-4">例子</a></li>
</ul>
</li>
<li><a href="#容器配接器">容器配接器</a></li>
</ul>
</li>
<li><a href="#总结">总结</a><ul>
<li><a href="#各容器的特点总结">各容器的特点总结</a><ul>
<li><a href="#各容器的时间复杂度分析">各容器的时间复杂度分析</a></li>
<li><a href="#各容器的共性">各容器的共性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#搬运源">搬运源</a></li>
</ul>
<!-- vim-markdown-toc -->
<h1 id="什么是STL"><a href="#什么是STL" class="headerlink" title="什么是STL?"></a>什么是STL?</h1><p>1、STL(Standard Template Library)，即标准模板库，是一个高效的C++程序库，包含了诸多常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。</p>
<p>2、从逻辑层次来看，在STL中体现了泛型化程序设计的思想(generic programming)。在这种思想里，大部分基本算法被抽象，被泛化，独立于与之对应的数据结构，用于以相同或相近的方式处理各种不同情形。</p>
<p>3、从实现层次看，整个STL是以一种类型参数化(type parameterized)的方式实现的，基于模板(template)。</p>
<p>STL有六大组件，但主要包含容器、迭代器和算法三个部分。</p>
<p><code>容器(Containers)</code>:用来管理某类对象的集合。每一种容器都有其优点和缺点，所以为了应付程序中的不同需求，STL 准备了七种基本容器类型。</p>
<p><code>迭代器(Iterators)</code>:用来在一个对象集合的元素上进行遍历动作。这个对象集合或许是个容器，或许是容器的一部分。每一种容器都提供了自己的迭代器，而这些迭代器了解该种容器的内部结构。</p>
<p><code>算法(Algorithms)</code>:用来处理对象集合中的元素，比如 Sort，Search，Copy，Erase 那些元素。通过迭代器的协助，我们只需撰写一次算法，就可以将它应用于任意容器之上，这是因为所有容器的迭代器都提供一致的接口。</p>
<p>STL 的基本观念就是将数据和操作分离。数据由容器进行管理，操作则由算法进行，而迭代器在两者之间充当粘合剂，使任何算法都可以和任何容器交互运作。这一篇博客暂时只介绍容器，下一篇介绍迭代器。</p>
<h1 id="容器-Containers"><a href="#容器-Containers" class="headerlink" title="容器(Containers)"></a>容器(Containers)</h1><p>容器用来管理某类对象。为了应付程序中的不同需求，STL 准备了两类共七种基本容器类型:</p>
<p><code>序列式容器(Sequence containers)</code>，此为可序群集，其中每个元素均有固定位置—取决于插入时机和地点，和元素值无关。如果你以追加方式对一个群集插入六个元素，它们的排列次序将和插入次序一致。STL提供了三个序列式容器:向量(<code>vector</code>)、双端队列(<code>deque</code>)、列表(<code>list</code>)，此外你也可以把 <code>string</code> 和 <code>array</code> 当做一种序列式容器。</p>
<p><code>关联式容器(Associative containers)</code>，此为已序群集，元素位置取决于特定的排序准则以及元素值，和插入次序无关。如果你将六个元素置入这样的群集中，它们的位置取决于元素值，和插入次序无关。STL提供了四个关联式容器:集合(<code>set</code>)、多重集合(<code>multiset</code>)、映射(<code>map</code>)和多重映射(<code>multimap</code>)。</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector(向量): 是一种序列式容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能动态拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而 vector 正好弥补了这个缺陷，当内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>&bull; 拥有一段连续的内存空间，因此它能非常好的支持随机访问，即 [] 操作符和 .at()，随机访问快。(优点)</p>
<p>&bull; 当向其头部或中间插入或删除元素时，为了保持原本的相对次序，插入或删除点之后的所有元素都必须移动，所以插入或删除的效率比较低。(缺点)</p>
<p>&bull; 在后面插入删除元素最快，此时一般不需要移动内存。(优点)</p>
<p>总结:相当于可拓展的数组(动态数组)，随机访问快，在头部和中间插入或删除效率低，但在尾部插入或删除效率高。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>适用于对象简单，变化较小，并且频繁随机访问的场景。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下例子针对整型定义了一个 vector，插入 6 个元素，然后打印所有元素:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vecTemp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">		vecTemp.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;vecTemp.<span class="built_in">size</span>(); i++)</span><br><span class="line">		cout &lt;&lt; vecTemp[i] &lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 输出:0 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque(double-ended queue)是双向开口的连续内存空间(动态将多个连续空间通过指针数组接合在一起)，随时可以增加一段新的空间。deque 的最大任务就是在这些分段的连续空间上，维护其整体连续的假象，并提供随机存取的接口。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>&bull; 一旦要在 deque 的头部和尾部增加新空间，便配置一段定量连续空间，串在整个 deque 的头部或尾部，因此不论在头部或尾部插入元素都十分迅速。 (优点)</p>
<p>&bull;  在中间部分安插元素则比较费时，因为必须移动其它元素。(缺点)</p>
<p>&bull;  deque 是 list 和 vector 的折中方案。兼有 list 的优点，也有 vector 随机访问效率高的优点。</p>
<p><strong>总结:</strong> 支持随机访问，但效率没有 vector 高，在头部和尾部插入或删除效率高，但在中间插入或删除效率低。</p>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>适用于既要频繁随机访问，又要关心两端数据的插入与删除的场景。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>以下例子声明了一个浮点类型的 deque，并在容器尾部插入 6 个元素，最后打印出所有元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">float</span>&gt; dequeTemp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">		dequeTemp.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;dequeTemp.<span class="built_in">size</span>(); i++)</span><br><span class="line">		cout &lt;&lt; dequeTemp[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出:0 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>List 由双向链表(doubly linked list)实现而成，元素存放在堆中，每个元素都是放在一块内存中。没有空间预留习惯，所以每分配一个元素都会从内存中分配，每删除一个元素都会释放它占用的内存。</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>&bull;  内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随机存取变得非常没有效率，因此它没有提供 [] 操作符的重载。(缺点)<br>由于链表的特点，在任意位置的插入和删除效率都较高。(优点)</p>
<p>&bull; 只支持首尾两个元素的直接存取，想获取其他元素(访问时间一样)，则需要遍历链表。(缺点)</p>
<p><strong>总结:</strong>不支持随机访问，在任意位置的插入和删除效率都较高。</p>
<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>适用于经常进行插入和删除操作并且不经常随机访问的场景。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>以下例子产生一个空 list，准备放置字符，然后将 ‘a’ 至 ‘z’ 的所有字符插入其中，利用循环每次打印并移除集合的第一个元素，从而打印出所有元素:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">char</span>&gt; listTemp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; ++c)</span><br><span class="line">		listTemp.<span class="built_in">push_back</span>(c);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!listTemp.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt;listTemp.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		listTemp.<span class="built_in">pop_front</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员函数empty()的返回值告诉我们容器中是否还有元素，只要这个函数返回 false，循环就继续进行。循环之内，成员函数front()会返回第一个元素，pop_front()函数会删除第一个元素。</p>
<p>注意:list&lt;指针&gt; 完全是性能最低的做法，还不如直接使用 list&lt;对象&gt; 或使用 vector&lt;指针&gt; 好，因为指针没有构造与析构，也不占用很大内存。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set(集合)顾名思义，就是数学上的集合——每个元素最多只出现一次，并且 set 中的元素已经从小到大排好序。</p>
<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>&bull; 使用红黑树实现，其内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复。</p>
<p>&bull; 每次插入值的时候，都需要调整红黑树，效率有一定影响。(缺点)</p>
<p>&bull; map 和 set 的插入或删除效率比用其他序列容器高，因为对于关联容器来说，不需要做内存拷贝和内存移动。(优点)</p>
<p><strong>总结:</strong>由红黑树实现，其内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复，且插入和删除效率比用其他序列容器高。</p>
<h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h3><p>适用于经常查找一个元素是否在某集合中且需要排序的场景。</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>下面的例子演示 set(集合)的两个特点:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; setTemp;</span><br><span class="line"></span><br><span class="line">	setTemp.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">	setTemp.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">	setTemp.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">	setTemp.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = setTemp.<span class="built_in">begin</span>(); it != setTemp.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:1 2 3。一共插入了 4 个数，但是集合中只有 3 个数并且是有序的，可见之前说过的 set 集合的两个特点，有序和不重复。</p>
<p>当 set 集合中的元素为结构体时，该结构体必须实现运算符 ‘&lt;’ 的重载:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> People p) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> age &lt; p.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;People&gt; setTemp;</span><br><span class="line"></span><br><span class="line">	setTemp.<span class="built_in">insert</span>(&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">14</span>&#125;);</span><br><span class="line">	setTemp.<span class="built_in">insert</span>(&#123; <span class="string">&quot;李四&quot;</span>, <span class="number">16</span> &#125;);</span><br><span class="line">	setTemp.<span class="built_in">insert</span>(&#123; <span class="string">&quot;隔壁老王&quot;</span>, <span class="number">10</span> &#125;);</span><br><span class="line"></span><br><span class="line">	set&lt;People&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = setTemp.<span class="built_in">begin</span>(); it != setTemp.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;姓名:%s 年龄:%d\n&quot;</span>, (*it).name.<span class="built_in">c_str</span>(), (*it).age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">姓名:王二麻子 年龄:10</span></span><br><span class="line"><span class="section">姓名:张三 年龄:14</span></span><br><span class="line"><span class="section">姓名:李四 年龄:16</span></span><br></pre></td></tr></table></figure>
<p>可以看到结果是按照年龄由小到大的顺序排列。另外 string 要使用<code>c_str()</code>转换一下，否则打印出的是乱码。</p>
<p>另外 Multiset 和 set 相同，只不过它允许重复元素，也就是说 multiset 可包括多个数值相同的元素。这里不再做过多介绍。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>&bull;  map 由红黑树实现，其元素都是 “键值/实值” 所形成的一个对组(key/value pairs)。</p>
<p>&bull;  map 主要用于资料一对一映射的情况，map 内部自建一颗红黑树，这颗树具有对数据自动排序的功能，所以在 map 内部所有的数据都是有序的。比如一个班级中，每个学生的学号跟他的姓名就存在着一对一映射的关系。</p>
<h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><p>&bull;  每个元素都有一个键，且只能出现一次，不允许重复。</p>
<p>&bull;  根据 key 值快速查找记录，查找的复杂度基本是 O(logN)，如果有 1000 个记录，二分查找最多查找 10次(1024)。(优点)</p>
<p>&bull;  每次插入值的时候，都需要调整红黑树，效率有一定影响。(缺点)</p>
<p>&bull;  增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。(优点)</p>
<p>&bull;  对于迭代器来说，可以修改实值，而不能修改 key。</p>
<p><strong>总结:</strong>元素为键值对，key 和 value 可以是任意你需要的类型，每个元素都有一个键，且只能出现一次，不允许重复，根据 key 快速查找记录。</p>
<h3 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h3><p>适用于需要存储一个数据字典，并要求方便地根据key找value的场景。</p>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, string&gt; mapTemp;</span><br><span class="line"></span><br><span class="line">	mapTemp.<span class="built_in">insert</span>(&#123; <span class="number">5</span>,<span class="string">&quot;张三&quot;</span> &#125;);</span><br><span class="line">	mapTemp.<span class="built_in">insert</span>(&#123; <span class="number">3</span>, <span class="string">&quot;李四&quot;</span>&#125;);</span><br><span class="line">	mapTemp.<span class="built_in">insert</span>(&#123; <span class="number">4</span>, <span class="string">&quot;隔壁老王&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, string&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = mapTemp.<span class="built_in">begin</span>(); it != mapTemp.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;学号:%d 姓名:%s\n&quot;</span>, (*it).first, (*it).second.<span class="built_in">c_str</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">学号:3 姓名:李四</span></span><br><span class="line"><span class="section">学号:4 姓名:隔壁老王</span></span><br><span class="line"><span class="section">学号:5 姓名:张三</span></span><br></pre></td></tr></table></figure>
<p>multimap 和 map 相同，但允许重复元素，也就是说 multimap 可包含多个键值(key)相同的元素。这里不再做过多介绍。</p>
<h2 id="容器配接器"><a href="#容器配接器" class="headerlink" title="容器配接器"></a>容器配接器</h2><p>除了以上七个基本容器类别，为满足特殊需求，STL还提供了一些特别的(并且预先定义好的)容器配接器，根据基本容器类别实现而成。包括:</p>
<p>1、stack</p>
<p>名字说明了一切，stack 容器对元素采取 LIFO(后进先出)的管理策略。</p>
<p>2、queue</p>
<p>queue 容器对元素采取 FIFO(先进先出)的管理策略。也就是说，它是个普通的缓冲区(buffer)。</p>
<p>3、priority_queue</p>
<p>priority_queue 容器中的元素可以拥有不同的优先权。所谓优先权，乃是基于程序员提供的排序准则(缺省使用 operators)而定义。Priority queue 的效果相当于这样一个 buffer:“下一元素永远是queue中优先级最高的元素”。如果同时有多个元素具备最髙优先权，则其次序无明确定义。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="各容器的特点总结"><a href="#各容器的特点总结" class="headerlink" title="各容器的特点总结"></a>各容器的特点总结</h2><p>&bull;  vector 支持随机访问，在头部和中间插入或删除效率低，但在尾部插入或删除效率高。 支持随机访问，但效率没有 vector 高，在头部和尾部插入或删除效率高，但在中间插入或删除效率低。</p>
<p>&bull;  list 不支持随机访问，在任意位置的插入和删除效率都较高。</p>
<p>&bull;  set 由红黑树实现，其内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复，且插入和删除效率比用其他序列容器高。</p>
<p>&bull;  map 的元素为键值对，key 和 value 可以是任意你需要的类型，每个元素都有一个键，且只能出现一次，不允许重复，根据 key 快速查找记录。</p>
<p>在实际使用过程中，到底选择这几种容器中的哪一个，应该根据遵循以下原则:</p>
<p>1、如果需要高效的随机访问，不在乎插入和删除的效率，使用 vector。</p>
<p>2、如果需要随机访问，并且关心两端数据的插入和删除效率，使用 deque。</p>
<p>3、如果需要大量的插入和删除元素，不关心随机访问的效率，使用 list。</p>
<p>4、如果经常查找一个元素是否在某集合中且需要排序，唯一存在的情况使用 set，不唯一存在的情况使用 multiset。</p>
<p>5、如果打算存储数据字典，并且要求方便地根据 key 找到 value，一对一的情况使用 map，一对多的情况使用 multimap。</p>
<h3 id="各容器的时间复杂度分析"><a href="#各容器的时间复杂度分析" class="headerlink" title="各容器的时间复杂度分析"></a>各容器的时间复杂度分析</h3><p>&bull;  vector 在头部和中间位置插入和删除的时间复杂度为 O(N)，在尾部插入和删除的时间复杂度为 O(1)，随机访问的时间复杂度为 O(1)，查找的时间复杂度为 O(N)；</p>
<p>&bull;  deque 在中间位置插入和删除的时间复杂度为 O(N)，在头部和尾部插入和删除的时间复杂度为 O(1)，随机访问的时间复杂度为 O(1)，查找的时间复杂度为 O(N)；</p>
<p>&bull;  list 在任意位置插入和删除的时间复杂度都为 O(1)，查找的时间复杂度为 O(N)；</p>
<p>&bull;  set 和 map 都是通过红黑树实现，因此插入、删除和查找操作的时间复杂度都是 O(log N)。</p>
<h3 id="各容器的共性"><a href="#各容器的共性" class="headerlink" title="各容器的共性"></a>各容器的共性</h3><p>各容器一般来说都有下列函数:默认构造函数、复制构造函数、析构函数、empty()、max_size()、size()、operator=、operator&lt;、operator&lt;=、operator&gt;、operator&gt;=、operator==、operator!=、swap()。</p>
<p>顺序容器和关联容器都共有下列函数:</p>
<p><code>begin()</code>: 返回容器第一个元素的迭代器指针；</p>
<p><code>end()</code>: 返回容器最后一个元素后面一位的迭代器指针；</p>
<p><code>rbegin()</code>: 返回一个逆向迭代器指针，指向容器最后一个元素；</p>
<p><code>rend()</code>: 返回一个逆向迭代器指针，指向容器首个元素前面一位；</p>
<p><code>clear()</code>: 删除容器中的所有的元素；</p>
<p><code>erase(it)</code>: 删除迭代器指针it处元素。</p>
<h1 id="搬运源"><a href="#搬运源" class="headerlink" title="搬运源"></a>搬运源</h1><p>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/linuxAndMcu/p/10254542.html">C++ STL 各容器简单介绍</a></p>

            </div>



</div>

   <div class="tag-cloud-tags">
    <a href="/tags/CMakeLists/" style="font-size: 10px; color: #f38181">CMakeLists</a> <a href="/tags/Eigen/" style="font-size: 10px; color: #f38181">Eigen</a> <a href="/tags/FCPX/" style="font-size: 10px; color: #f38181">FCPX</a> <a href="/tags/GNU/" style="font-size: 10px; color: #f38181">GNU</a> <a href="/tags/Gazebo/" style="font-size: 10px; color: #f38181">Gazebo</a> <a href="/tags/Git/" style="font-size: 10px; color: #f38181">Git</a> <a href="/tags/Interest/" style="font-size: 10px; color: #f38181">Interest</a> <a href="/tags/KDL/" style="font-size: 10.91px; color: #ea8a88">KDL</a> <a href="/tags/Life/" style="font-size: 10px; color: #f38181">Life</a> <a href="/tags/Linux/" style="font-size: 10.91px; color: #ea8a88">Linux</a> <a href="/tags/Matrix/" style="font-size: 10px; color: #f38181">Matrix</a> <a href="/tags/ODE/" style="font-size: 10px; color: #f38181">ODE</a> <a href="/tags/QoS/" style="font-size: 10px; color: #f38181">QoS</a> <a href="/tags/ROS/" style="font-size: 12.73px; color: #d99b97">ROS</a> <a href="/tags/Ros/" style="font-size: 10px; color: #f38181">Ros</a> <a href="/tags/UML/" style="font-size: 10px; color: #f38181">UML</a> <a href="/tags/Ubuntu/" style="font-size: 10px; color: #f38181">Ubuntu</a> <a href="/tags/VcXsrv/" style="font-size: 10px; color: #f38181">VcXsrv</a> <a href="/tags/algorithm/" style="font-size: 10px; color: #f38181">algorithm</a> <a href="/tags/algorithms/" style="font-size: 10px; color: #f38181">algorithms</a> <a href="/tags/axis-angle/" style="font-size: 10px; color: #f38181">axis-angle</a> <a href="/tags/bode/" style="font-size: 10px; color: #f38181">bode</a> <a href="/tags/calibration/" style="font-size: 10px; color: #f38181">calibration</a> <a href="/tags/chrome/" style="font-size: 10px; color: #f38181">chrome</a> <a href="/tags/control/" style="font-size: 13.64px; color: #d1a49f">control</a> <a href="/tags/cpp/" style="font-size: 17.27px; color: #afc7bd">cpp</a> <a href="/tags/dB/" style="font-size: 10px; color: #f38181">dB</a> <a href="/tags/data-struct/" style="font-size: 10px; color: #f38181">data_struct</a> <a href="/tags/dots/" style="font-size: 15.45px; color: #c0b5ae">dots</a> <a href="/tags/figure/" style="font-size: 10px; color: #f38181">figure</a> <a href="/tags/gdb/" style="font-size: 10px; color: #f38181">gdb</a> <a href="/tags/git/" style="font-size: 10px; color: #f38181">git</a> <a href="/tags/latex/" style="font-size: 10.91px; color: #ea8a88">latex</a> <a href="/tags/launch/" style="font-size: 10px; color: #f38181">launch</a> <a href="/tags/life/" style="font-size: 16.36px; color: #b7beb5">life</a> <a href="/tags/linux/" style="font-size: 18.18px; color: #a6d0c4">linux</a> <a href="/tags/mac/" style="font-size: 10px; color: #f38181">mac</a> <a href="/tags/math/" style="font-size: 14.55px; color: #c8ada6">math</a> <a href="/tags/matlab/" style="font-size: 11.82px; color: #e29290">matlab</a> <a href="/tags/memory/" style="font-size: 14.55px; color: #c8ada6">memory</a> <a href="/tags/motor/" style="font-size: 10.91px; color: #ea8a88">motor</a> <a href="/tags/moveit/" style="font-size: 10px; color: #f38181">moveit</a> <a href="/tags/operator/" style="font-size: 10px; color: #f38181">operator</a> <a href="/tags/optimal-algorithm/" style="font-size: 10px; color: #f38181">optimal algorithm</a> <a href="/tags/python/" style="font-size: 15.45px; color: #c0b5ae">python</a> <a href="/tags/robot/" style="font-size: 12.73px; color: #d99b97">robot</a> <a href="/tags/robotics/" style="font-size: 14.55px; color: #c8ada6">robotics</a> <a href="/tags/ros/" style="font-size: 15.45px; color: #c0b5ae">ros</a> <a href="/tags/ros2/" style="font-size: 11.82px; color: #e29290">ros2</a> <a href="/tags/rtb/" style="font-size: 10px; color: #f38181">rtb</a> <a href="/tags/simulation/" style="font-size: 10.91px; color: #ea8a88">simulation</a> <a href="/tags/stl/" style="font-size: 10px; color: #f38181">stl</a> <a href="/tags/thread/" style="font-size: 10.91px; color: #ea8a88">thread</a> <a href="/tags/tools/" style="font-size: 19.09px; color: #9ed8cc">tools</a> <a href="/tags/twist/" style="font-size: 10px; color: #f38181">twist</a> <a href="/tags/urdf/" style="font-size: 10px; color: #f38181">urdf</a> <a href="/tags/velocity/" style="font-size: 10px; color: #f38181">velocity</a> <a href="/tags/vim/" style="font-size: 14.55px; color: #c8ada6">vim</a> <a href="/tags/web/" style="font-size: 10px; color: #f38181">web</a> <a href="/tags/work/" style="font-size: 20px; color: #95e1d3">work</a> <a href="/tags/wsl/" style="font-size: 10px; color: #f38181">wsl</a>
</div>



<div align="center"> 
    <li id="footer-info-copyright">网站内容采用<a class="external" rel="nofollow noopener" target="_blank" href="https://www.gnu.org/copyleft/fdl.html">GNU自由文档许可证3或更高版本</a>授权</li> <img src="https://licensebuttons.net/l/by-nc-sa/3.0/88x31.png" alt="知识共享许可协议">



        </div>
    </div>
</body>


</html>
